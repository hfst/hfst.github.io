<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>HFST - Helsinki Finite-State Transducer Technology - C++ API: HfstTransducer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - C++ API
   &#160;<span id="projectnumber">version 3.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehfst.html">hfst</a></li><li class="navelem"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhfst_1_1HfstTransducer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HfstTransducer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A synchronous finite-state transducer.  
 <a href="classhfst_1_1HfstTransducer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="HfstTransducer_8h_source.html">HfstTransducer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a075567bebabee06c84afb78ff57413e4"><td class="memItemLeft" align="right" valign="top">HFSTDLL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a075567bebabee06c84afb78ff57413e4">compare</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true) const </td></tr>
<tr class="memdesc:a075567bebabee06c84afb78ff57413e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this transducer and <em>another</em> are equivalent.  <a href="#a075567bebabee06c84afb78ff57413e4">More...</a><br /></td></tr>
<tr class="separator:a075567bebabee06c84afb78ff57413e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36804d74b8c4c006d8da9373bdacf661"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a36804d74b8c4c006d8da9373bdacf661">compose</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:a36804d74b8c4c006d8da9373bdacf661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this transducer with <em>another</em>.  <a href="#a36804d74b8c4c006d8da9373bdacf661">More...</a><br /></td></tr>
<tr class="separator:a36804d74b8c4c006d8da9373bdacf661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9559da647ac6e9614768fd56fc41679d"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a9559da647ac6e9614768fd56fc41679d">compose_intersect</a> (const <a class="el" href="namespacehfst.html#a5ffd27e1aebb79fc4226492dcb0d6b35">HfstTransducerVector</a> &amp;v, bool <a class="el" href="classhfst_1_1HfstTransducer.html#a00f7f70fb22b280ed5c5332e465ad15a">invert</a>=false, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:a9559da647ac6e9614768fd56fc41679d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this transducer with the intersection of transducers in <em>v</em>. If <em>invert</em> is true, then compose the intersection of the transducers in <em>v</em> with this transducer.  <a href="#a9559da647ac6e9614768fd56fc41679d">More...</a><br /></td></tr>
<tr class="separator:a9559da647ac6e9614768fd56fc41679d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67f02e73a8bd253a54c08ead8f03c33"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac67f02e73a8bd253a54c08ead8f03c33">concatenate</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:ac67f02e73a8bd253a54c08ead8f03c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate this transducer with <em>another</em>.  <a href="#ac67f02e73a8bd253a54c08ead8f03c33">More...</a><br /></td></tr>
<tr class="separator:ac67f02e73a8bd253a54c08ead8f03c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa652aabc7f81986aa9633dafa01ba209"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa652aabc7f81986aa9633dafa01ba209">convert</a> (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type, std::string options=&quot;&quot;)</td></tr>
<tr class="memdesc:aa652aabc7f81986aa9633dafa01ba209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the transducer into an equivalent transducer in format <em>type</em>.  <a href="#aa652aabc7f81986aa9633dafa01ba209">More...</a><br /></td></tr>
<tr class="separator:aa652aabc7f81986aa9633dafa01ba209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2028bf2511019136749a8dd144d86bb5"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2028bf2511019136749a8dd144d86bb5">cross_product</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:a2028bf2511019136749a8dd144d86bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make cross product of this transducer with <em></em>. It pairs every string of this with every string of <em></em>.  <a href="#a2028bf2511019136749a8dd144d86bb5">More...</a><br /></td></tr>
<tr class="separator:a2028bf2511019136749a8dd144d86bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9470854c25e5b8aa898ad3e9abdefeab"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a9470854c25e5b8aa898ad3e9abdefeab">determinize</a> ()</td></tr>
<tr class="memdesc:a9470854c25e5b8aa898ad3e9abdefeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinize the transducer.  <a href="#a9470854c25e5b8aa898ad3e9abdefeab">More...</a><br /></td></tr>
<tr class="separator:a9470854c25e5b8aa898ad3e9abdefeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45072e8d9d52f484eb931be3d226715"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab45072e8d9d52f484eb931be3d226715">disjunct</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:ab45072e8d9d52f484eb931be3d226715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunct this transducer with <em>another</em>.  <a href="#ab45072e8d9d52f484eb931be3d226715">More...</a><br /></td></tr>
<tr class="separator:ab45072e8d9d52f484eb931be3d226715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab28aa07635b031e966c4f4f26100a2b"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aab28aa07635b031e966c4f4f26100a2b">extract_paths</a> (<a class="el" href="namespacehfst.html#af0d66467d22da6864597a7a2cf700e32">HfstTwoLevelPaths</a> &amp;results, int max_num=-1, int cycles=-1) const </td></tr>
<tr class="memdesc:aab28aa07635b031e966c4f4f26100a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a maximum of <em>max_num</em> paths that are recognized by the transducer following a maximum of <em>cycles</em> cycles and store the paths into <em>results</em>.  <a href="#aab28aa07635b031e966c4f4f26100a2b">More...</a><br /></td></tr>
<tr class="separator:aab28aa07635b031e966c4f4f26100a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520d19db73e0e9e5c86309625852e60d"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a520d19db73e0e9e5c86309625852e60d">extract_paths_fd</a> (<a class="el" href="namespacehfst.html#af0d66467d22da6864597a7a2cf700e32">HfstTwoLevelPaths</a> &amp;results, int max_num=-1, int cycles=-1, bool filter_fd=true) const </td></tr>
<tr class="memdesc:a520d19db73e0e9e5c86309625852e60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a maximum of <em>max_num</em> paths that are recognized by the transducer and are not invalidated by flag diacritic rules following a maximum of <em>cycles</em> cycles and store the paths into <em>results</em>. <em>filter_fd</em> defines whether the flag diacritics themselves are filtered out of the result strings.  <a href="#a520d19db73e0e9e5c86309625852e60d">More...</a><br /></td></tr>
<tr class="separator:a520d19db73e0e9e5c86309625852e60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4541c902e24d684a57f3d604da655f"><td class="memItemLeft" align="right" valign="top">HFSTDLL StringSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a7a4541c902e24d684a57f3d604da655f">get_alphabet</a> () const </td></tr>
<tr class="memdesc:a7a4541c902e24d684a57f3d604da655f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the alphabet of the transducer.  <a href="#a7a4541c902e24d684a57f3d604da655f">More...</a><br /></td></tr>
<tr class="separator:a7a4541c902e24d684a57f3d604da655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0c59073868a3b04c98f6b3e060f7b1"><td class="memItemLeft" align="right" valign="top">HFSTDLL StringSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aee0c59073868a3b04c98f6b3e060f7b1">get_first_input_symbols</a> () const </td></tr>
<tr class="memdesc:aee0c59073868a3b04c98f6b3e060f7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first input level symbols of strings recognized (or rejected, if they end in a non-final state) by the transducer.  <a href="#aee0c59073868a3b04c98f6b3e060f7b1">More...</a><br /></td></tr>
<tr class="separator:aee0c59073868a3b04c98f6b3e060f7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3698093973c52835d6fd4b0d8e8ae6cf"><td class="memItemLeft" align="right" valign="top">HFSTDLL std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3698093973c52835d6fd4b0d8e8ae6cf">get_name</a> () const </td></tr>
<tr class="memdesc:a3698093973c52835d6fd4b0d8e8ae6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the transducer.  <a href="#a3698093973c52835d6fd4b0d8e8ae6cf">More...</a><br /></td></tr>
<tr class="separator:a3698093973c52835d6fd4b0d8e8ae6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b863776f6733c7e6d8fff1fd8c997b"><td class="memItemLeft" align="right" valign="top">HFSTDLL const std::map<br class="typebreak" />
&lt; std::string, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a21b863776f6733c7e6d8fff1fd8c997b">get_properties</a> () const </td></tr>
<tr class="memdesc:a21b863776f6733c7e6d8fff1fd8c997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all properties form transducer.  <a href="#a21b863776f6733c7e6d8fff1fd8c997b">More...</a><br /></td></tr>
<tr class="separator:a21b863776f6733c7e6d8fff1fd8c997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd7382ae555d4684268dbe7f5f17972"><td class="memItemLeft" align="right" valign="top">HFSTDLL std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8bd7382ae555d4684268dbe7f5f17972">get_property</a> (const std::string &amp;property) const </td></tr>
<tr class="memdesc:a8bd7382ae555d4684268dbe7f5f17972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get arbitrary string propert <em>property</em>. get_property("name") works like get_name.  <a href="#a8bd7382ae555d4684268dbe7f5f17972">More...</a><br /></td></tr>
<tr class="separator:a8bd7382ae555d4684268dbe7f5f17972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fbee2fcce877b2644c4ca087466c34"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a98fbee2fcce877b2644c4ca087466c34">get_type</a> (void) const </td></tr>
<tr class="memdesc:a98fbee2fcce877b2644c4ca087466c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation type of the transducer.  <a href="#a98fbee2fcce877b2644c4ca087466c34">More...</a><br /></td></tr>
<tr class="separator:a98fbee2fcce877b2644c4ca087466c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b3fe308abdeefa8d45440c9eb51ac9"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a> (<a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another)</td></tr>
<tr class="memdesc:af3b3fe308abdeefa8d45440c9eb51ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonize transducers this and another.  <a href="#af3b3fe308abdeefa8d45440c9eb51ac9">More...</a><br /></td></tr>
<tr class="separator:af3b3fe308abdeefa8d45440c9eb51ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9e87175c2776cf6a3201016bb7d0e0"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a0f9e87175c2776cf6a3201016bb7d0e0">HfstTransducer</a> ()</td></tr>
<tr class="memdesc:a0f9e87175c2776cf6a3201016bb7d0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an uninitialized transducer (use with care).  <a href="#a0f9e87175c2776cf6a3201016bb7d0e0">More...</a><br /></td></tr>
<tr class="separator:a0f9e87175c2776cf6a3201016bb7d0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839ac6a1a76c09f17184c14b480b0978"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a839ac6a1a76c09f17184c14b480b0978">HfstTransducer</a> (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:a839ac6a1a76c09f17184c14b480b0978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty transducer, i.e. a transducer that does not recognize any string. The type of the transducer is defined by <em>type</em>.  <a href="#a839ac6a1a76c09f17184c14b480b0978">More...</a><br /></td></tr>
<tr class="separator:a839ac6a1a76c09f17184c14b480b0978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1165728fe1c823655d0307a60fbbf95"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae1165728fe1c823655d0307a60fbbf95">HfstTransducer</a> (const std::string &amp;utf8_str, const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;multichar_symbol_tokenizer, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:ae1165728fe1c823655d0307a60fbbf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transducer by tokenizing the utf8 string <em>utf8_string</em> with tokenizer <em>multichar_symbol_tokenizer</em>. The type of the transducer is defined by <em>type</em>.  <a href="#ae1165728fe1c823655d0307a60fbbf95">More...</a><br /></td></tr>
<tr class="separator:ae1165728fe1c823655d0307a60fbbf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8cac73b0ced1fcae363a05059d53f4"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8d8cac73b0ced1fcae363a05059d53f4">HfstTransducer</a> (const std::string &amp;input_utf8_str, const std::string &amp;output_utf8_str, const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;multichar_symbol_tokenizer, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:a8d8cac73b0ced1fcae363a05059d53f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transducer by tokenizing the utf8 input string <em>input_utf8_string</em> and output string <em>output_utf8_string</em> with tokenizer <em>multichar_symbol_tokenizer</em>. The type of the transducer is defined by <em>type</em>.  <a href="#a8d8cac73b0ced1fcae363a05059d53f4">More...</a><br /></td></tr>
<tr class="separator:a8d8cac73b0ced1fcae363a05059d53f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b941c9d120fbec4596002c6a979096"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a80b941c9d120fbec4596002c6a979096">HfstTransducer</a> (<a class="el" href="classhfst_1_1HfstInputStream.html">HfstInputStream</a> &amp;in)</td></tr>
<tr class="memdesc:a80b941c9d120fbec4596002c6a979096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a binary transducer from transducer stream <em>in</em>.  <a href="#a80b941c9d120fbec4596002c6a979096">More...</a><br /></td></tr>
<tr class="separator:a80b941c9d120fbec4596002c6a979096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7665f9d313f11c0d5835b1e52fe4feae"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a7665f9d313f11c0d5835b1e52fe4feae">HfstTransducer</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another)</td></tr>
<tr class="memdesc:a7665f9d313f11c0d5835b1e52fe4feae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of transducer <em>another</em>.  <a href="#a7665f9d313f11c0d5835b1e52fe4feae">More...</a><br /></td></tr>
<tr class="separator:a7665f9d313f11c0d5835b1e52fe4feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0ae54e24b07c1d59645165e5d7304f"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aad0ae54e24b07c1d59645165e5d7304f">HfstTransducer</a> (const <a class="el" href="namespacehfst_1_1implementations.html#a873b7a6485acf29c1a0f450f57ac37aa">hfst::implementations::HfstBasicTransducer</a> &amp;t, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:aad0ae54e24b07c1d59645165e5d7304f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an HFST transducer equivalent to HFST basic transducer <em>t</em>. The type of the created transducer is defined by <em>type</em>.  <a href="#aad0ae54e24b07c1d59645165e5d7304f">More...</a><br /></td></tr>
<tr class="separator:aad0ae54e24b07c1d59645165e5d7304f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b46414790da84bcc6e1b2147c17da1d"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a0b46414790da84bcc6e1b2147c17da1d">HfstTransducer</a> (const std::string &amp;symbol, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:a0b46414790da84bcc6e1b2147c17da1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transducer that recognizes the string pair &lt;"symbol","symbol"&gt;, i.e. [symbol:symbol]. The type of the transducer is defined by <em>type</em>.  <a href="#a0b46414790da84bcc6e1b2147c17da1d">More...</a><br /></td></tr>
<tr class="separator:a0b46414790da84bcc6e1b2147c17da1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aea9bbc09fd0ff059d3fc0cf1d54b9"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a33aea9bbc09fd0ff059d3fc0cf1d54b9">HfstTransducer</a> (const std::string &amp;isymbol, const std::string &amp;osymbol, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:a33aea9bbc09fd0ff059d3fc0cf1d54b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transducer that recognizes the string pair &lt;"isymbol","osymbol"&gt;, i.e [isymbol:osymbol]. The type of the transducer is defined by <em>type</em>.  <a href="#a33aea9bbc09fd0ff059d3fc0cf1d54b9">More...</a><br /></td></tr>
<tr class="separator:a33aea9bbc09fd0ff059d3fc0cf1d54b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01541ff320e0749a4b025f9e92b2d5d6"><td class="memItemLeft" align="right" valign="top">HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a01541ff320e0749a4b025f9e92b2d5d6">HfstTransducer</a> (FILE *ifile, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type, const std::string &amp;epsilon_symbol, unsigned int &amp;linecount)</td></tr>
<tr class="memdesc:a01541ff320e0749a4b025f9e92b2d5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transducer of type <em>type</em> as defined in AT&amp;T format in FILE <em>ifile</em>. <em>epsilon_symbol</em> defines how epsilons are represented.  <a href="#a01541ff320e0749a4b025f9e92b2d5d6">More...</a><br /></td></tr>
<tr class="separator:a01541ff320e0749a4b025f9e92b2d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedc1c93cfc77e20c12fb57683ca8ea1"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#adedc1c93cfc77e20c12fb57683ca8ea1">input_project</a> ()</td></tr>
<tr class="memdesc:adedc1c93cfc77e20c12fb57683ca8ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the input language of the transducer.  <a href="#adedc1c93cfc77e20c12fb57683ca8ea1">More...</a><br /></td></tr>
<tr class="separator:adedc1c93cfc77e20c12fb57683ca8ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4fc79a57dfe964a1d1595ff05a3f67"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#afe4fc79a57dfe964a1d1595ff05a3f67">insert_freely</a> (const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;symbol_pair, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:afe4fc79a57dfe964a1d1595ff05a3f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freely insert symbol pair <em>symbol_pair</em> into the transducer.  <a href="#afe4fc79a57dfe964a1d1595ff05a3f67">More...</a><br /></td></tr>
<tr class="separator:afe4fc79a57dfe964a1d1595ff05a3f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea867d434bc28c63e3ee8278892108f2"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aea867d434bc28c63e3ee8278892108f2">insert_freely</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;tr, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:aea867d434bc28c63e3ee8278892108f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freely insert a copy of <em>tr</em> into the transducer.  <a href="#aea867d434bc28c63e3ee8278892108f2">More...</a><br /></td></tr>
<tr class="separator:aea867d434bc28c63e3ee8278892108f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b15abdea97232b4e9a8f47ece7001"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab49b15abdea97232b4e9a8f47ece7001">insert_to_alphabet</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:ab49b15abdea97232b4e9a8f47ece7001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly insert <em>symbol</em> to the alphabet of the transducer.  <a href="#ab49b15abdea97232b4e9a8f47ece7001">More...</a><br /></td></tr>
<tr class="separator:ab49b15abdea97232b4e9a8f47ece7001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8bf9c5cc6b41c41fbf68fa7904d8a2"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aee8bf9c5cc6b41c41fbf68fa7904d8a2">intersect</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:aee8bf9c5cc6b41c41fbf68fa7904d8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect this transducer with <em>another</em>.  <a href="#aee8bf9c5cc6b41c41fbf68fa7904d8a2">More...</a><br /></td></tr>
<tr class="separator:aee8bf9c5cc6b41c41fbf68fa7904d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f7f70fb22b280ed5c5332e465ad15a"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a00f7f70fb22b280ed5c5332e465ad15a">invert</a> ()</td></tr>
<tr class="memdesc:a00f7f70fb22b280ed5c5332e465ad15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the input and output symbols of each transition in the transducer.  <a href="#a00f7f70fb22b280ed5c5332e465ad15a">More...</a><br /></td></tr>
<tr class="separator:a00f7f70fb22b280ed5c5332e465ad15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991d38da32398b0f78fb1b10c28c92d8"><td class="memItemLeft" align="right" valign="top">HFSTDLL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a991d38da32398b0f78fb1b10c28c92d8">is_automaton</a> (void) const </td></tr>
<tr class="memdesc:a991d38da32398b0f78fb1b10c28c92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is an automaton.  <a href="#a991d38da32398b0f78fb1b10c28c92d8">More...</a><br /></td></tr>
<tr class="separator:a991d38da32398b0f78fb1b10c28c92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d15200648b544ecae3daf4e80447c9c"><td class="memItemLeft" align="right" valign="top">HFSTDLL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2d15200648b544ecae3daf4e80447c9c">is_cyclic</a> (void) const </td></tr>
<tr class="memdesc:a2d15200648b544ecae3daf4e80447c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is cyclic.  <a href="#a2d15200648b544ecae3daf4e80447c9c">More...</a><br /></td></tr>
<tr class="separator:a2d15200648b544ecae3daf4e80447c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93af3422529e5f224785a12cc13be901"><td class="memItemLeft" align="right" valign="top">HFSTDLL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a93af3422529e5f224785a12cc13be901">is_lookdown_infinitely_ambiguous</a> (const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;s) const </td></tr>
<tr class="memdesc:a93af3422529e5f224785a12cc13be901"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Not implemented) Whether lookdown of path <em>s</em> will have infinite results.  <a href="#a93af3422529e5f224785a12cc13be901">More...</a><br /></td></tr>
<tr class="separator:a93af3422529e5f224785a12cc13be901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d01744017bf093961bc1d5e30dff5a"><td class="memItemLeft" align="right" valign="top">HFSTDLL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a28d01744017bf093961bc1d5e30dff5a">is_lookup_infinitely_ambiguous</a> (const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;s) const </td></tr>
<tr class="memdesc:a28d01744017bf093961bc1d5e30dff5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether lookup of path <em>s</em> will have infinite results.  <a href="#a28d01744017bf093961bc1d5e30dff5a">More...</a><br /></td></tr>
<tr class="separator:a28d01744017bf093961bc1d5e30dff5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f458d161e71e1fcb0d4536c5083398"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a39f458d161e71e1fcb0d4536c5083398">lenient_composition</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:a39f458d161e71e1fcb0d4536c5083398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make lenient composition of this transducer with <em></em>. A .O. B = [ A .o. B ] .P. A.  <a href="#a39f458d161e71e1fcb0d4536c5083398">More...</a><br /></td></tr>
<tr class="separator:a39f458d161e71e1fcb0d4536c5083398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6b04f95ba7242840aa5d4d2656ad49"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aef6b04f95ba7242840aa5d4d2656ad49">lookdown</a> (const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;s, ssize_t limit=-1) const </td></tr>
<tr class="memdesc:aef6b04f95ba7242840aa5d4d2656ad49"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Not implemented) Lookdown a single string <em>s</em> and return a maximum of <em>limit</em> results.  <a href="#aef6b04f95ba7242840aa5d4d2656ad49">More...</a><br /></td></tr>
<tr class="separator:aef6b04f95ba7242840aa5d4d2656ad49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5e476d38e5fa6a088516a5ce44cb33"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a1e5e476d38e5fa6a088516a5ce44cb33">lookdown_fd</a> (<a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;s, ssize_t limit=-1) const </td></tr>
<tr class="memdesc:a1e5e476d38e5fa6a088516a5ce44cb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Not implemented) Lookdown a single string minding flag diacritics properly.  <a href="#a1e5e476d38e5fa6a088516a5ce44cb33">More...</a><br /></td></tr>
<tr class="separator:a1e5e476d38e5fa6a088516a5ce44cb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184666baeb7941cd8fa74d80dc114dd0"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a184666baeb7941cd8fa74d80dc114dd0">lookup</a> (const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;s, ssize_t limit=-1, double time_cutoff=0.0) const </td></tr>
<tr class="memdesc:a184666baeb7941cd8fa74d80dc114dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup or apply a single tokenized string <em>s</em> and return a maximum of <em>limit</em> results.  <a href="#a184666baeb7941cd8fa74d80dc114dd0">More...</a><br /></td></tr>
<tr class="separator:a184666baeb7941cd8fa74d80dc114dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208ce1ed83de80e14832057a867aa6d5"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a208ce1ed83de80e14832057a867aa6d5">lookup</a> (const std::string &amp;s, ssize_t limit=-1, double time_cutoff=0.0) const </td></tr>
<tr class="memdesc:a208ce1ed83de80e14832057a867aa6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup or apply a single string <em>s</em> and return a maximum of <em>limit</em> results.  <a href="#a208ce1ed83de80e14832057a867aa6d5">More...</a><br /></td></tr>
<tr class="separator:a208ce1ed83de80e14832057a867aa6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31538571fc5d1fa1682aefeaf1c598d0"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a31538571fc5d1fa1682aefeaf1c598d0">lookup</a> (const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;tok, const std::string &amp;s, ssize_t limit=-1, double time_cutoff=0.0) const </td></tr>
<tr class="memdesc:a31538571fc5d1fa1682aefeaf1c598d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup or apply a single string <em>s</em> and store a maximum of <em>limit</em> results to <em>results</em>. <em>tok</em> defined how <em>s</em> is tokenized.  <a href="#a31538571fc5d1fa1682aefeaf1c598d0">More...</a><br /></td></tr>
<tr class="separator:a31538571fc5d1fa1682aefeaf1c598d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaae1983ca4f2ba7d1e264db707c89f"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a1eaae1983ca4f2ba7d1e264db707c89f">lookup_fd</a> (const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;s, ssize_t limit=-1, double time_cutoff=0.0) const </td></tr>
<tr class="memdesc:a1eaae1983ca4f2ba7d1e264db707c89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup or apply a single string <em>s</em> minding flag diacritics properly and store a maximum of <em>limit</em> results to <em>results</em>.  <a href="#a1eaae1983ca4f2ba7d1e264db707c89f">More...</a><br /></td></tr>
<tr class="separator:a1eaae1983ca4f2ba7d1e264db707c89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f98beeb00a533d348e8dde3b022ed"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8b9f98beeb00a533d348e8dde3b022ed">lookup_fd</a> (const std::string &amp;s, ssize_t limit=-1, double time_cutoff=0.0) const </td></tr>
<tr class="memdesc:a8b9f98beeb00a533d348e8dde3b022ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup or apply a single string <em>s</em> minding flag diacritics properly and store a maximum of <em>limit</em> results to <em>results</em>.  <a href="#a8b9f98beeb00a533d348e8dde3b022ed">More...</a><br /></td></tr>
<tr class="separator:a8b9f98beeb00a533d348e8dde3b022ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4447763b733aced7be4051e92ca649f0"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a4447763b733aced7be4051e92ca649f0">lookup_fd</a> (const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;tok, const std::string &amp;s, ssize_t limit=-1, double time_cutoff=0.0) const </td></tr>
<tr class="memdesc:a4447763b733aced7be4051e92ca649f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup or apply a single string <em>s</em> minding flag diacritics properly and store a maximum of <em>limit</em> results to <em>results</em>. <em>tok</em> defines how s is tokenized.  <a href="#a4447763b733aced7be4051e92ca649f0">More...</a><br /></td></tr>
<tr class="separator:a4447763b733aced7be4051e92ca649f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accda6d6aace9571d8ed91b2f75b48339"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#accda6d6aace9571d8ed91b2f75b48339">minimize</a> ()</td></tr>
<tr class="memdesc:accda6d6aace9571d8ed91b2f75b48339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the transducer.  <a href="#accda6d6aace9571d8ed91b2f75b48339">More...</a><br /></td></tr>
<tr class="separator:accda6d6aace9571d8ed91b2f75b48339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163866f8a96c38ae553174efc582f0fb"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a163866f8a96c38ae553174efc582f0fb">n_best</a> (unsigned int n)</td></tr>
<tr class="memdesc:a163866f8a96c38ae553174efc582f0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract <em>n</em> best paths of the transducer.  <a href="#a163866f8a96c38ae553174efc582f0fb">More...</a><br /></td></tr>
<tr class="separator:a163866f8a96c38ae553174efc582f0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489258a0fdc40997a5ba2196863d2475"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a489258a0fdc40997a5ba2196863d2475">operator=</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another)</td></tr>
<tr class="memdesc:a489258a0fdc40997a5ba2196863d2475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this transducer a new value equivalent to transducer <em>another</em>.  <a href="#a489258a0fdc40997a5ba2196863d2475">More...</a><br /></td></tr>
<tr class="separator:a489258a0fdc40997a5ba2196863d2475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e86f27c11fd6653c214954d651636"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a050e86f27c11fd6653c214954d651636">optionalize</a> ()</td></tr>
<tr class="memdesc:a050e86f27c11fd6653c214954d651636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunct the transducer with an epsilon transducer.  <a href="#a050e86f27c11fd6653c214954d651636">More...</a><br /></td></tr>
<tr class="separator:a050e86f27c11fd6653c214954d651636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef82f01e4c7013a8204bbfd3b9afeaaf"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aef82f01e4c7013a8204bbfd3b9afeaaf">output_project</a> ()</td></tr>
<tr class="memdesc:aef82f01e4c7013a8204bbfd3b9afeaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the output language of the transducer.  <a href="#aef82f01e4c7013a8204bbfd3b9afeaaf">More...</a><br /></td></tr>
<tr class="separator:aef82f01e4c7013a8204bbfd3b9afeaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4385a68bbd9b78b0e92885f1346bd40"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa4385a68bbd9b78b0e92885f1346bd40">priority_union</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another)</td></tr>
<tr class="memdesc:aa4385a68bbd9b78b0e92885f1346bd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make priority union of this transducer with <em>another</em>.  <a href="#aa4385a68bbd9b78b0e92885f1346bd40">More...</a><br /></td></tr>
<tr class="separator:aa4385a68bbd9b78b0e92885f1346bd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a11312b01bc72624b2355fd1eceb80"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a19a11312b01bc72624b2355fd1eceb80">prune</a> ()</td></tr>
<tr class="memdesc:a19a11312b01bc72624b2355fd1eceb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make transducer coaccessible.  <a href="#a19a11312b01bc72624b2355fd1eceb80">More...</a><br /></td></tr>
<tr class="separator:a19a11312b01bc72624b2355fd1eceb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84a74d73eb33d4f8e5887dc6789cc78"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ad84a74d73eb33d4f8e5887dc6789cc78">prune_alphabet</a> (bool force=true)</td></tr>
<tr class="memdesc:ad84a74d73eb33d4f8e5887dc6789cc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all symbols that do not occur in transitions of the transducer from its alphabet.  <a href="#ad84a74d73eb33d4f8e5887dc6789cc78">More...</a><br /></td></tr>
<tr class="separator:ad84a74d73eb33d4f8e5887dc6789cc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69ad5df498af8fd49a2e41cd350ead6"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#af69ad5df498af8fd49a2e41cd350ead6">push_weights</a> (<a class="el" href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587">PushType</a> type)</td></tr>
<tr class="memdesc:af69ad5df498af8fd49a2e41cd350ead6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push weights towards initial or final state(s) as defined by <em>type</em>.  <a href="#af69ad5df498af8fd49a2e41cd350ead6">More...</a><br /></td></tr>
<tr class="separator:af69ad5df498af8fd49a2e41cd350ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3828dcc83e6b2ccfe299f6bbb6dee3d"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab3828dcc83e6b2ccfe299f6bbb6dee3d">remove_epsilons</a> ()</td></tr>
<tr class="memdesc:ab3828dcc83e6b2ccfe299f6bbb6dee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all <em>epsilon:epsilon</em> transitions from the transducer so that the transducer remains equivalent.  <a href="#ab3828dcc83e6b2ccfe299f6bbb6dee3d">More...</a><br /></td></tr>
<tr class="separator:ab3828dcc83e6b2ccfe299f6bbb6dee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b9c181d1e5eabaf1e3bd05f4d0fb2b"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a65b9c181d1e5eabaf1e3bd05f4d0fb2b">remove_from_alphabet</a> (const std::string &amp;symbol)</td></tr>
<tr class="memdesc:a65b9c181d1e5eabaf1e3bd05f4d0fb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>symbol</em> from the alphabet of the transducer. CURRENTLY NOT IMPLEMENTED.  <a href="#a65b9c181d1e5eabaf1e3bd05f4d0fb2b">More...</a><br /></td></tr>
<tr class="separator:a65b9c181d1e5eabaf1e3bd05f4d0fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f29c90c6658d0400a48df89c802156b"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8f29c90c6658d0400a48df89c802156b">repeat_n</a> (unsigned int n)</td></tr>
<tr class="memdesc:a8f29c90c6658d0400a48df89c802156b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of <em>n</em> transducers.  <a href="#a8f29c90c6658d0400a48df89c802156b">More...</a><br /></td></tr>
<tr class="separator:a8f29c90c6658d0400a48df89c802156b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff6223610887b76091883348461c6da"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#abff6223610887b76091883348461c6da">repeat_n_minus</a> (unsigned int n)</td></tr>
<tr class="memdesc:abff6223610887b76091883348461c6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from zero to <em>n</em>, inclusive.  <a href="#abff6223610887b76091883348461c6da">More...</a><br /></td></tr>
<tr class="separator:abff6223610887b76091883348461c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5052ff04682d61e936e99496f2d19e8"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa5052ff04682d61e936e99496f2d19e8">repeat_n_plus</a> (unsigned int n)</td></tr>
<tr class="memdesc:aa5052ff04682d61e936e99496f2d19e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from <em>n</em> to infinity, inclusive.  <a href="#aa5052ff04682d61e936e99496f2d19e8">More...</a><br /></td></tr>
<tr class="separator:aa5052ff04682d61e936e99496f2d19e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6605c70a9c615a9d51188a001445910"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa6605c70a9c615a9d51188a001445910">repeat_n_to_k</a> (unsigned int n, unsigned int k)</td></tr>
<tr class="memdesc:aa6605c70a9c615a9d51188a001445910"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from <em>n</em> to <em>k</em>, inclusive.  <a href="#aa6605c70a9c615a9d51188a001445910">More...</a><br /></td></tr>
<tr class="separator:aa6605c70a9c615a9d51188a001445910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da338f754080944f305e0d11fc4538e"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3da338f754080944f305e0d11fc4538e">repeat_plus</a> ()</td></tr>
<tr class="memdesc:a3da338f754080944f305e0d11fc4538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from one to infinity.  <a href="#a3da338f754080944f305e0d11fc4538e">More...</a><br /></td></tr>
<tr class="separator:a3da338f754080944f305e0d11fc4538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682f84143a794ae4d34963da284ff74c"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a682f84143a794ae4d34963da284ff74c">repeat_star</a> ()</td></tr>
<tr class="memdesc:a682f84143a794ae4d34963da284ff74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from zero to infinity.  <a href="#a682f84143a794ae4d34963da284ff74c">More...</a><br /></td></tr>
<tr class="separator:a682f84143a794ae4d34963da284ff74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8717fc51ef80751e5c8cd92e965a0d"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ace8717fc51ef80751e5c8cd92e965a0d">reverse</a> ()</td></tr>
<tr class="memdesc:ace8717fc51ef80751e5c8cd92e965a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the transducer.  <a href="#ace8717fc51ef80751e5c8cd92e965a0d">More...</a><br /></td></tr>
<tr class="separator:ace8717fc51ef80751e5c8cd92e965a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519cbee51f47f1a5c22b7dd50027e8c6"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a519cbee51f47f1a5c22b7dd50027e8c6">set_final_weights</a> (float weight, bool increment=false)</td></tr>
<tr class="memdesc:a519cbee51f47f1a5c22b7dd50027e8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weights of all final states to <em>weight</em>. <em>increment</em> defines whether the old weight is incremented by <em>weight</em> or overwritten.  <a href="#a519cbee51f47f1a5c22b7dd50027e8c6">More...</a><br /></td></tr>
<tr class="separator:a519cbee51f47f1a5c22b7dd50027e8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5260b9627048b854b45d05ed34adc22"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ad5260b9627048b854b45d05ed34adc22">set_name</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad5260b9627048b854b45d05ed34adc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the transducer <em>name</em>.  <a href="#ad5260b9627048b854b45d05ed34adc22">More...</a><br /></td></tr>
<tr class="separator:ad5260b9627048b854b45d05ed34adc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d85426ec06e6c739709ab2dc2179d10"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3d85426ec06e6c739709ab2dc2179d10">set_property</a> (const std::string &amp;property, const std::string &amp;value)</td></tr>
<tr class="memdesc:a3d85426ec06e6c739709ab2dc2179d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set arbitrary string property <em>property</em> to <em>value</em>. set_property("name") equals <code>set_name(string&amp;)</code>.  <a href="#a3d85426ec06e6c739709ab2dc2179d10">More...</a><br /></td></tr>
<tr class="separator:a3d85426ec06e6c739709ab2dc2179d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2d7b6a06f54fb16f7a021374ea0c6c"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a0b2d7b6a06f54fb16f7a021374ea0c6c">substitute</a> (bool(*func)(const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;sp, <a class="el" href="namespacehfst.html#a7e6c1068373d2f96ddf9874c94bdb428">StringPairSet</a> &amp;sps))</td></tr>
<tr class="memdesc:a0b2d7b6a06f54fb16f7a021374ea0c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all transition <em>sp</em> with transitions <em>sps</em> as defined by function <em>func</em>.  <a href="#a0b2d7b6a06f54fb16f7a021374ea0c6c">More...</a><br /></td></tr>
<tr class="separator:a0b2d7b6a06f54fb16f7a021374ea0c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9279c8f4cf08254d50c3d7dc95fad7a"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae9279c8f4cf08254d50c3d7dc95fad7a">substitute</a> (const std::string &amp;old_symbol, const std::string &amp;new_symbol, bool input_side=true, bool output_side=true)</td></tr>
<tr class="memdesc:ae9279c8f4cf08254d50c3d7dc95fad7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all transition symbols equal to <em>old_symbol</em> with symbol <em>new_symbol</em>. <em>input_side</em> and <em>output_side</em> define whether the substitution is made on input and output sides.  <a href="#ae9279c8f4cf08254d50c3d7dc95fad7a">More...</a><br /></td></tr>
<tr class="separator:ae9279c8f4cf08254d50c3d7dc95fad7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000f103a29ce02b1d42e4653729fcfc9"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a000f103a29ce02b1d42e4653729fcfc9">substitute</a> (const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;old_symbol_pair, const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;new_symbol_pair)</td></tr>
<tr class="memdesc:a000f103a29ce02b1d42e4653729fcfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all transition symbol pairs equal to <em>old_symbol_pair</em> with <em>new_symbol_pair</em>.  <a href="#a000f103a29ce02b1d42e4653729fcfc9">More...</a><br /></td></tr>
<tr class="separator:a000f103a29ce02b1d42e4653729fcfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386626d5d12bcce63694b1ad782ae073"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a386626d5d12bcce63694b1ad782ae073">substitute</a> (const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;old_symbol_pair, const <a class="el" href="namespacehfst.html#a7e6c1068373d2f96ddf9874c94bdb428">StringPairSet</a> &amp;new_symbol_pair_set)</td></tr>
<tr class="memdesc:a386626d5d12bcce63694b1ad782ae073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all transitions equal to <em>old_symbol_pair</em> with a set of transitions equal to <em>new_symbol_pair_set</em>.  <a href="#a386626d5d12bcce63694b1ad782ae073">More...</a><br /></td></tr>
<tr class="separator:a386626d5d12bcce63694b1ad782ae073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4db00ae1e826d31caad13cf0a70346f"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac4db00ae1e826d31caad13cf0a70346f">substitute</a> (const <a class="el" href="namespacehfst.html#a21db22f2a65366b5c47d8ee32ac6ffe6">HfstSymbolSubstitutions</a> &amp;substitutions)</td></tr>
<tr class="memdesc:ac4db00ae1e826d31caad13cf0a70346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all transition symbols as defined in <em>substitutions</em>.  <a href="#ac4db00ae1e826d31caad13cf0a70346f">More...</a><br /></td></tr>
<tr class="separator:ac4db00ae1e826d31caad13cf0a70346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae8279af356aca415019545de4f960f"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a6ae8279af356aca415019545de4f960f">substitute</a> (const <a class="el" href="namespacehfst.html#aa5665d03e1ee19779e624ab8ccbeb83d">HfstSymbolPairSubstitutions</a> &amp;substitutions)</td></tr>
<tr class="memdesc:a6ae8279af356aca415019545de4f960f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all transition symbol pairs as defined in <em>substitutions</em>.  <a href="#a6ae8279af356aca415019545de4f960f">More...</a><br /></td></tr>
<tr class="separator:a6ae8279af356aca415019545de4f960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cff8bcd807864d03ebb645e1a9ab75"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab9cff8bcd807864d03ebb645e1a9ab75">substitute</a> (const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;symbol_pair, <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;transducer, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:ab9cff8bcd807864d03ebb645e1a9ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all transitions equal to <em>symbol_pair</em> with a copy of transducer <em>transducer</em>.  <a href="#ab9cff8bcd807864d03ebb645e1a9ab75">More...</a><br /></td></tr>
<tr class="separator:ab9cff8bcd807864d03ebb645e1a9ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245e72d62ba9f7136e587a880a657a66"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a245e72d62ba9f7136e587a880a657a66">subtract</a> (const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;another, bool <a class="el" href="classhfst_1_1HfstTransducer.html#af3b3fe308abdeefa8d45440c9eb51ac9">harmonize</a>=true)</td></tr>
<tr class="memdesc:a245e72d62ba9f7136e587a880a657a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract transducer <em>another</em> from this transducer.  <a href="#a245e72d62ba9f7136e587a880a657a66">More...</a><br /></td></tr>
<tr class="separator:a245e72d62ba9f7136e587a880a657a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dae0477240e20ad9e75680a73202c0"><td class="memItemLeft" align="right" valign="top">HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a86dae0477240e20ad9e75680a73202c0">transform_weights</a> (float(*func)(float))</td></tr>
<tr class="memdesc:a86dae0477240e20ad9e75680a73202c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform all transition and state weights as defined in <em>func</em>.  <a href="#a86dae0477240e20ad9e75680a73202c0">More...</a><br /></td></tr>
<tr class="separator:a86dae0477240e20ad9e75680a73202c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89a5acd4eab4cf872d0d4375c05e585"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac89a5acd4eab4cf872d0d4375c05e585">write_in_att_format</a> (FILE *ofile, bool write_weights=true) const </td></tr>
<tr class="memdesc:ac89a5acd4eab4cf872d0d4375c05e585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to FILE <em>ofile</em>. <em>write_weights</em> defines whether weights are written.  <a href="#ac89a5acd4eab4cf872d0d4375c05e585">More...</a><br /></td></tr>
<tr class="separator:ac89a5acd4eab4cf872d0d4375c05e585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33bedc587a07a5444d68431a030d82"><td class="memItemLeft" align="right" valign="top">HFSTDLL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#acb33bedc587a07a5444d68431a030d82">write_in_att_format</a> (const std::string &amp;filename, bool write_weights=true) const </td></tr>
<tr class="memdesc:acb33bedc587a07a5444d68431a030d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to FILE named <em>filename</em>. <em>write_weights</em> defines whether weights are written.  <a href="#acb33bedc587a07a5444d68431a030d82">More...</a><br /></td></tr>
<tr class="separator:acb33bedc587a07a5444d68431a030d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94360762e776798e95abea12ef6ea26"><td class="memItemLeft" align="right" valign="top">virtual HFSTDLL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab94360762e776798e95abea12ef6ea26">~HfstTransducer</a> (void)</td></tr>
<tr class="memdesc:ab94360762e776798e95abea12ef6ea26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab94360762e776798e95abea12ef6ea26">More...</a><br /></td></tr>
<tr class="separator:ab94360762e776798e95abea12ef6ea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaa669593b6f51b0d2f1d3e5ba6c7e6cf"><td class="memItemLeft" align="right" valign="top">static HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aaa669593b6f51b0d2f1d3e5ba6c7e6cf">identity_pair</a> (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:aaa669593b6f51b0d2f1d3e5ba6c7e6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create identity pair transducer of <em>type</em>.  <a href="#aaa669593b6f51b0d2f1d3e5ba6c7e6cf">More...</a><br /></td></tr>
<tr class="separator:aaa669593b6f51b0d2f1d3e5ba6c7e6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323d87b86ca0779a146a21ec62de66db"><td class="memItemLeft" align="right" valign="top">static HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a323d87b86ca0779a146a21ec62de66db">read_lexc_ptr</a> (const std::string &amp;filename, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type, bool verbose)</td></tr>
<tr class="memdesc:a323d87b86ca0779a146a21ec62de66db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a lexc file in file <em>filename</em> into an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> of type <em>type</em> and return the transducer.  <a href="#a323d87b86ca0779a146a21ec62de66db">More...</a><br /></td></tr>
<tr class="separator:a323d87b86ca0779a146a21ec62de66db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4545be0a3d195966e420acb85d4aae73"><td class="memItemLeft" align="right" valign="top">static HFSTDLL <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a4545be0a3d195966e420acb85d4aae73">universal_pair</a> (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> type)</td></tr>
<tr class="memdesc:a4545be0a3d195966e420acb85d4aae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create universal pair transducer of <em>type</em>.  <a href="#a4545be0a3d195966e420acb85d4aae73">More...</a><br /></td></tr>
<tr class="separator:a4545be0a3d195966e420acb85d4aae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a60c0951f70379f9fe75b655d95349e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a60c0951f70379f9fe75b655d95349e8b">apply</a> (SFST::Transducer *(*sfst_funct)(SFST::Transducer *), fst::StdVectorFst *(*tropical_ofst_funct)(fst::StdVectorFst *), fsm *(*foma_funct)(fsm *), bool dummy)</td></tr>
<tr class="memdesc:a60c0951f70379f9fe75b655d95349e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">declarations for HFST functions that take two or more parameters  <a href="#a60c0951f70379f9fe75b655d95349e8b">More...</a><br /></td></tr>
<tr class="separator:a60c0951f70379f9fe75b655d95349e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a678ea3e5d75241dba9d3ba3956f3366f"><td class="memItemLeft" align="right" valign="top">HFSTDLL friend std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a678ea3e5d75241dba9d3ba3956f3366f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;t)</td></tr>
<tr class="memdesc:a678ea3e5d75241dba9d3ba3956f3366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write transducer <em>t</em> in AT&amp;T format to ostream <em>out</em>.  <a href="#a678ea3e5d75241dba9d3ba3956f3366f">More...</a><br /></td></tr>
<tr class="separator:a678ea3e5d75241dba9d3ba3956f3366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A synchronous finite-state transducer. </p>
<h1><a class="anchor" id="argument_handling"></a>
Argument handling</h1>
<pre class="fragment">Transducer functions modify their calling object and return 
a reference to the calling object after modification, 
unless otherwise mentioned.
Transducer arguments are usually not modified.
</pre> <pre class="fragment">    // transducer is reversed
    transducer.reverse();
    // transducer2 is not modified, but a copy of it is disjuncted with
    // transducer1 
    transducer1.disjunct(transducer2);                                       
    // a chain of functions is possible
    transducer.reverse().determinize().reverse().determinize();      
</pre><h1><a class="anchor" id="implementation_types"></a>
Implementation types</h1>
<pre class="fragment">Currently, an HfstTransducer has four implementation types as 
defined by the enumeration ImplementationType.
When an HfstTransducer is created, its type is defined with an 
ImplementationType argument.
For functions that take a transducer as an argument, the type of 
the calling transducer
must be the same as the type of the argument transducer:
</pre> <pre class="fragment">    // this will cause an error
    log_transducer.disjunct(sfst_transducer);                        
    // this works, but weights are lost in the conversion
    log_transducer.convert(SFST_TYPE).disjunct(sfst_transducer);     
    // this works, information is not lost
    log_transducer.disjunct(sfst_transducer.convert(LOG_OPENFST_TYPE)); 
</pre><h1><a class="anchor" id="creating_transducers"></a>
Creating transducers</h1>
<pre class="fragment">With HfstTransducer constructors it is possible to create empty, 
epsilon, one-transition and single-path transducers.
Transducers can also be created from scratch with HfstBasicTransducer
and converted to an HfstTransducer.
More complex transducers can be combined from simple ones with various 
functions.

&lt;a name="symbols"&gt;&lt;/a&gt; 
</pre> <h1><a class="anchor" id="special_symbols"></a>
Special symbols</h1>
<pre class="fragment">The HFST transducers support transitions with epsilon, unknown 
and identity symbols.
The special symbols are explained in documentation of datatype #String.
</pre><p>An example: </p><pre class="fragment">  // In the xerox formalism used here, "?" means the unknown symbol
  // and "?:?" the identity pair 

  HfstBasicTransducer tr1;
  tr1.add_state(1);
  tr1.set_final_weight(1, 0);
  tr1.add_transition
    (0, HfstBasicTransition(1, "@_UNKNOWN_SYMBOL_@", "foo", 0) );

  // tr1 is now [ ?:foo ]
  
  HfstBasicTransducer tr2;
  tr2.add_state(1);
  tr2.add_state(2);
  tr2.set_final_weight(2, 0);
  tr2.add_transition
    (0, HfstBasicTransition(1, "@_IDENTITY_SYMBOL_@", 
                    "@_IDENTITY_SYMBOL_@", 0) );
  tr2.add_transition
    (1, HfstBasicTransition(2, "bar", "bar", 0) );

  // tr2 is now [ [ ?:? ] [ bar:bar ] ]

  ImplementationType type = SFST_TYPE;
  HfstTransducer Tr1(tr1, type);
  HfstTransducer Tr2(tr2, type);
  Tr1.disjunct(Tr2);

  // Tr1 is now [ [ ?:foo | bar:foo ]  |  [[ ?:? | foo:foo ] [ bar:bar ]] ]</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0f9e87175c2776cf6a3201016bb7d0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an uninitialized transducer (use with care). </p>
<dl class="section note"><dt>Note</dt><dd>This constructor leaves the backend implementation variable uninitialized. An uninitialized transducer is likely to cause a <a class="el" href="structTransducerHasWrongTypeException.html" title="Transducer has wrong type. ">TransducerHasWrongTypeException</a> at some point unless it is given a value at some point. </dd></dl>

</div>
</div>
<a class="anchor" id="a839ac6a1a76c09f17184c14b480b0978"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty transducer, i.e. a transducer that does not recognize any string. The type of the transducer is defined by <em>type</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>("@_EPSILON_SYMBOL_@") to create an epsilon transducer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1165728fe1c823655d0307a60fbbf95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;&#160;</td>
          <td class="paramname"><em>multichar_symbol_tokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transducer by tokenizing the utf8 string <em>utf8_string</em> with tokenizer <em>multichar_symbol_tokenizer</em>. The type of the transducer is defined by <em>type</em>. </p>
<p><em>utf8_str</em> is read one token at a time and for each token a new transition is created in the resulting transducer. The input and output symbols of that transition are the same as the token read.</p>
<p>An example: </p><pre class="fragment">       std::string ustring = "foobar";
       HfstTokenizer TOK;
       HfstTransducer tr(ustring, TOK, LOG_OPENFST_TYPE);
       // tr now contains one path [f o o b a r]
</pre> <pre class="fragment">    @see HfstTokenizer  </pre> 
</div>
</div>
<a class="anchor" id="a8d8cac73b0ced1fcae363a05059d53f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_utf8_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_utf8_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;&#160;</td>
          <td class="paramname"><em>multichar_symbol_tokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transducer by tokenizing the utf8 input string <em>input_utf8_string</em> and output string <em>output_utf8_string</em> with tokenizer <em>multichar_symbol_tokenizer</em>. The type of the transducer is defined by <em>type</em>. </p>
<p><em>input_utf8_str</em> and <em>output_utf8_str</em> are read one token at a time and for each token a new transition is created in the resulting transducer. The input and output symbols of that transition are the same as the input and output tokens read. If either string contains less tokens than another, epsilons are used as transition symbols for the shorter string.</p>
<p>An example: </p><pre class="fragment">       std::string input = "foo";
       std::string output = "barr";
       HfstTokenizer TOK;
       HfstTransducer tr(input, output, TOK, SFST_TYPE);
       // tr now contains one path [f:b o:a o:r 0:r]
</pre> <pre class="fragment">    @see HfstTokenizer  </pre> 
</div>
</div>
<a class="anchor" id="a80b941c9d120fbec4596002c6a979096"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhfst_1_1HfstInputStream.html">HfstInputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a binary transducer from transducer stream <em>in</em>. </p>
<p>The stream can contain HFST tranducers or OpenFst, foma or SFST transducers without an HFST header. If the backend implementations are used as such, they are converted into HFST transducers.</p>
<p>For more information on transducer conversions and the HFST header structure, see <a href="https://kitwiki.csc.fi/twiki/bin/view/KitWiki/HfstTransducerHeader">here</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>( in.is_eof() == in.is_bad() == false &amp;&amp; in.is_fst() ). Otherwise, an exception is thrown.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structNotTransducerStreamException.html" title="The stream does not contain transducers. ">NotTransducerStreamException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structStreamNotReadableException.html" title="Stream cannot be read. ">StreamNotReadableException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structStreamIsClosedException.html" title="Stream is closed. ">StreamIsClosedException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structTransducerTypeMismatchException.html" title="Two or more transducers do not have the same type. ">TransducerTypeMismatchException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structMissingOpenFstInputSymbolTableException.html" title="An OpenFst transducer does not have an input symbol table. ">MissingOpenFstInputSymbolTableException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstInputStream.html" title="A stream for reading HFST binary transducers. ">HfstInputStream</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7665f9d313f11c0d5835b1e52fe4feae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a deep copy of transducer <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="aad0ae54e24b07c1d59645165e5d7304f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst_1_1implementations.html#a873b7a6485acf29c1a0f450f57ac37aa">hfst::implementations::HfstBasicTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an HFST transducer equivalent to HFST basic transducer <em>t</em>. The type of the created transducer is defined by <em>type</em>. </p>

</div>
</div>
<a class="anchor" id="a0b46414790da84bcc6e1b2147c17da1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transducer that recognizes the string pair &lt;"symbol","symbol"&gt;, i.e. [symbol:symbol]. The type of the transducer is defined by <em>type</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33aea9bbc09fd0ff059d3fc0cf1d54b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>isymbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>osymbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transducer that recognizes the string pair &lt;"isymbol","osymbol"&gt;, i.e [isymbol:osymbol]. The type of the transducer is defined by <em>type</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a01541ff320e0749a4b025f9e92b2d5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>ifile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>epsilon_symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>linecount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transducer of type <em>type</em> as defined in AT&amp;T format in FILE <em>ifile</em>. <em>epsilon_symbol</em> defines how epsilons are represented. </p>
<p>In AT&amp;T format, the transition lines are of the form:</p>
<pre class="fragment">        [0-9]+[\w]+[0-9]+[\w]+[^\w]+[\w]+[^\w]([\w]+(-)[0-9]+(\.[0-9]+)) 
</pre> <pre class="fragment">    and final state lines:
</pre><pre class="fragment">        [0-9]+[\w]+([\w]+(-)[0-9]+(\.[0-9]+))
</pre> <pre class="fragment">    If several transducers are listed in the same file, 
    they are separated by lines of 
    two consecutive hyphens "--". If the weight 
    (&lt;tt&gt;([\\w]+(-)[0-9]+(\.[0-9]+))&lt;/tt&gt;) 
    is missing, the transition or final state is given a zero weight.

    NOTE: If transition symbols contains spaces, they must be escaped
    as "@_SPACE_@" because spaces are used as field separators.
    Both "@0@" and "@_EPSILON_SYMBOL_@" are always interpreted as
    epsilons.
</pre><p>An example: </p><pre class="fragment">0      1      foo      bar      0.3
1      0.5
--
0      0.0
--
--
0      0.0
0      0      a        &lt;eps&gt;    0.2
</pre> <pre class="fragment">    The example lists four transducers in AT&amp;T format: 
    one transducer accepting the string pair &amp;lt;"foo","bar"&amp;gt;, one
    epsilon transducer, one empty transducer and one transducer 
    that accepts any number of 'a's and produces an empty string
    in all cases. The transducers
    can be read with the following commands (from a file named 
    "testfile.att"):
</pre> <pre class="fragment">std::vector&lt;HfstTransducer&gt; transducers;
FILE * ifile = fopen("testfile.att", "rb");
try {
  while (not eof(ifile))
    {
    HfstTransducer t(ifile, TROPICAL_OPENFST_TYPE, "&lt;eps&gt;");
    transducers.push_back(t);
    printf("read one transducer\n");
    }
} catch (NotValidAttFormatException e) {
    printf("Error reading transducer: not valid AT&amp;T format.\n"); }
fclose(ifile);
fprintf(stderr, "Read %i transducers in total.\n", (int)transducers.size());
</pre><p>Epsilon will be represented as "@_EPSILON_SYMBOL_@" in the resulting transducer. The argument <em>epsilon_symbol</em> only denotes how epsilons are represented in <em>ifile</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structNotValidAttFormatException.html" title="The stream is not in valid AT&T format. ">NotValidAttFormatException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structStreamNotReadableException.html" title="Stream cannot be read. ">StreamNotReadableException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structStreamIsClosedException.html" title="Stream is closed. ">StreamIsClosedException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#ac89a5acd4eab4cf872d0d4375c05e585" title="Write the transducer in AT&T format to FILE ofile. write_weights defines whether weights are written...">write_in_att_format(FILE*,bool)const </a> </dd>
<dd>
<a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab94360762e776798e95abea12ef6ea26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a60c0951f70379f9fe75b655d95349e8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a>&amp; apply </td>
          <td>(</td>
          <td class="paramtype">SFST::Transducer *(*)(SFST::Transducer *)&#160;</td>
          <td class="paramname"><em>sfst_funct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fst::StdVectorFst *(*)(fst::StdVectorFst *)&#160;</td>
          <td class="paramname"><em>tropical_ofst_funct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fsm *(*)(fsm *)&#160;</td>
          <td class="paramname"><em>foma_funct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dummy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>declarations for HFST functions that take two or more parameters </p>

</div>
</div>
<a class="anchor" id="a075567bebabee06c84afb78ff57413e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this transducer and <em>another</em> are equivalent. </p>
<p>Two transducers are equivalent iff they accept the same input/output string pairs with the same weights and the same alignments. </p>

</div>
</div>
<a class="anchor" id="a36804d74b8c4c006d8da9373bdacf661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; compose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="a9559da647ac6e9614768fd56fc41679d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; compose_intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a5ffd27e1aebb79fc4226492dcb0d6b35">HfstTransducerVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this transducer with the intersection of transducers in <em>v</em>. If <em>invert</em> is true, then compose the intersection of the transducers in <em>v</em> with this transducer. </p>
<p>The algorithm used by this function is faster than intersecting all transducers one by one and then composing this transducer with the intersection.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The transducers in <em>v</em> are deterministic and epsilon-free. </dd></dl>

</div>
</div>
<a class="anchor" id="ac67f02e73a8bd253a54c08ead8f03c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="aa652aabc7f81986aa9633dafa01ba209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the transducer into an equivalent transducer in format <em>type</em>. </p>
<p>If a weighted transducer is converted into an unweighted one, all weights are lost. In the reverse case, all weights are initialized to the semiring's one.</p>
<p>A transducer of type <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a>, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a>, <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada289203865dd3ec445f7b73921568c5e2">LOG_OPENFST_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a> can be converted into an <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada74c04de498ac29cbc8e2d337cd11e14a">HFST_OL_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada45e027dcf5ddc6c74297d5e0800fcb22">HFST_OLW_TYPE</a> transducer, but an <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada74c04de498ac29cbc8e2d337cd11e14a">HFST_OL_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada45e027dcf5ddc6c74297d5e0800fcb22">HFST_OLW_TYPE</a> transducer cannot be converted to any other type.</p>
<dl class="section note"><dt>Note</dt><dd>For conversion between <a class="el" href="classhfst_1_1implementations_1_1HfstTransitionGraph.html" title="A simple transition graph format that consists of states and transitions between those states...">implementations::HfstTransitionGraph</a> and <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>, see <a class="el" href="classhfst_1_1HfstTransducer.html#aad0ae54e24b07c1d59645165e5d7304f" title="Create an HFST transducer equivalent to HFST basic transducer t. The type of the created transducer i...">HfstTransducer(const hfst::implementations::HfstBasicTransducer&amp;, ImplementationType)</a> and <a class="el" href="classhfst_1_1implementations_1_1HfstTransitionGraph.html#a229c4a1f822bf095f296a3966b7d0bd4" title="Create an HfstTransitionGraph equivalent to HfstTransducer transducer. FIXME: move to a separate file...">hfst::implementations::HfstTransitionGraph::HfstTransitionGraph(const hfst::HfstTransducer&amp;)</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2028bf2511019136749a8dd144d86bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; cross_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make cross product of this transducer with <em></em>. It pairs every string of this with every string of <em></em>. </p>
<p>Both transducers must be automata, i.e. map strings onto themselves.</p>
<p>If strings are not the same length, epsilon padding will be added in the end of the shorter string. </p>

</div>
</div>
<a class="anchor" id="a9470854c25e5b8aa898ad3e9abdefeab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; determinize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determinize the transducer. </p>
<p>Determinizing a transducer yields an equivalent transducer that has no state with two or more transitions whose input:output symbol pairs are the same. </p>

</div>
</div>
<a class="anchor" id="ab45072e8d9d52f484eb931be3d226715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; disjunct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunct this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="aab28aa07635b031e966c4f4f26100a2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#af0d66467d22da6864597a7a2cf700e32">HfstTwoLevelPaths</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_num</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cycles</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a maximum of <em>max_num</em> paths that are recognized by the transducer following a maximum of <em>cycles</em> cycles and store the paths into <em>results</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>The extracted paths are inserted here. </td></tr>
    <tr><td class="paramname">max_num</td><td>The total number of resulting strings is capped at <em>max_num</em>, with 0 or negative indicating unlimited. </td></tr>
    <tr><td class="paramname">cycles</td><td>Indicates how many times a cycle will be followed, with negative numbers indicating unlimited.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a version of extract_paths that handles flag diacritics as ordinary symbols and does not validate the sequences prior to outputting as opposed to <a class="el" href="classhfst_1_1HfstTransducer.html#a520d19db73e0e9e5c86309625852e60d" title="Extract a maximum of max_num paths that are recognized by the transducer and are not invalidated by f...">extract_paths_fd(HfstTwoLevelPaths &amp;, int, int, bool) const</a>.</p>
<p>If this function is called on a cyclic transducer with unlimited values for both <em>max_num</em> and <em>cycles</em>, an exception will be thrown.</p>
<p>This example</p>
<pre class="fragment">    ImplementationType type = SFST_TYPE;
    HfstTransducer tr1("a", "b", type);
    tr1.repeat_star();
    HfstTransducer tr2("c", "d", type);
    tr2.repeat_star();
    tr1.concatenate(tr2).minimize();
    HfstTwoLevelPaths results;
    tr1.extract_paths(results, MAX_NUM, CYCLES);

    // Go through all paths.
    for (HfstTwoLevelPaths::const_iterator it = results.begin();
         it != results.end(); it++)
      {
        std::string istring;
        std::string ostring;

        for (StringPairVector::const_iterator IT = it-&gt;second.begin();
             IT != it-&gt;second.end(); IT++)
          {
            istring.append(IT-&gt;first);
            ostring.append(IT-&gt;second);
          }
        // Print input and output strings of each path
        std::cerr &lt;&lt; istring &lt;&lt; ":" &lt;&lt; ostring; 
        // and optionally the weight of the path.
        //std::cerr &lt;&lt; "\t" &lt;&lt; it-&gt;first;
        std::cerr &lt;&lt; std::endl; 
      }
</pre> <pre class="fragment">    prints with values MAX_NUM == -1 and CYCLES == 1 all paths
    that have no consecutive cycles:
</pre><pre class="fragment">a : b
ac : bd
acc : bdd
c : d
cc : dd
</pre> <pre class="fragment">    and with values MAX_NUM == 7 and CYCLES == 2 a maximum of 7 paths
    that follow a cycle a maximum of 2 times (there are 11 such paths,
    but MAX_NUM limits their number to 7):
</pre><pre class="fragment">a : b
aa : bb
aac : bbd
aacc : bbdd
c : d
cc : dd
ccc : ddd
</pre><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Does not work for HFST_OL_TYPE or HFST_OLW_TYPE? <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structTransducerIsCyclicException.html" title="Transducer is cyclic. ">TransducerIsCyclicException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a163866f8a96c38ae553174efc582f0fb" title="Extract n best paths of the transducer. ">n_best</a> </dd>
<dd>
<a class="el" href="classhfst_1_1HfstTransducer.html#a520d19db73e0e9e5c86309625852e60d" title="Extract a maximum of max_num paths that are recognized by the transducer and are not invalidated by f...">hfst::HfstTransducer::extract_paths_fd(hfst::HfstTwoLevelPaths&amp;, int, int, bool) const</a> </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a520d19db73e0e9e5c86309625852e60d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_paths_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#af0d66467d22da6864597a7a2cf700e32">HfstTwoLevelPaths</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_num</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cycles</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter_fd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a maximum of <em>max_num</em> paths that are recognized by the transducer and are not invalidated by flag diacritic rules following a maximum of <em>cycles</em> cycles and store the paths into <em>results</em>. <em>filter_fd</em> defines whether the flag diacritics themselves are filtered out of the result strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>The extracted paths are inserted here. </td></tr>
    <tr><td class="paramname">max_num</td><td>The total number of resulting strings is capped at <em>max_num</em>, with 0 or negative indicating unlimited. </td></tr>
    <tr><td class="paramname">cycles</td><td>Indicates how many times a cycle will be followed, with negative numbers indicating unlimited. </td></tr>
    <tr><td class="paramname">filter_fd</td><td>Whether the flag diacritics are filtered out of the result strings.</td></tr>
  </table>
  </dd>
</dl>
<p>If this function is called on a cyclic transducer with unlimited values for both <em>max_num</em> and <em>cycles</em>, an exception will be thrown.</p>
<p>Flag diacritics are of the form @[PNDRCU][.][A-Z]+([.][A-Z]+)?</p>
<p>For example the transducer</p>
<pre class="fragment">[[@P.FEATURE.FOO@ foo] | [@P.FEATURE.BAR@ bar]]  |  [[foo @U.FEATURE.FOO@] | [bar @U.FEATURE.BAR@]]
</pre> <pre class="fragment">    will yield the paths &lt;CODE&gt;[foo foo]&lt;/CODE&gt; and &lt;CODE&gt;[bar bar]&lt;/CODE&gt;.
    &lt;CODE&gt;[foo bar]&lt;/CODE&gt; and &lt;CODE&gt;[bar foo]&lt;/CODE&gt; are invalidated
    by the flag diacritics so thay will not be included in \a results.
</pre><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>Does not work for HFST_OL_TYPE or HFST_OLW_TYPE? <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structTransducerIsCyclicException.html" title="Transducer is cyclic. ">TransducerIsCyclicException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#aab28aa07635b031e966c4f4f26100a2b" title="Extract a maximum of max_num paths that are recognized by the transducer following a maximum of cycle...">extract_paths(HfstTwoLevelPaths&amp;, int, int) const </a> </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7a4541c902e24d684a57f3d604da655f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringSet get_alphabet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the alphabet of the transducer. </p>
<p>The alphabet is defined as the set of symbols known to the transducer. </p>

</div>
</div>
<a class="anchor" id="aee0c59073868a3b04c98f6b3e060f7b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringSet get_first_input_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get first input level symbols of strings recognized (or rejected, if they end in a non-final state) by the transducer. </p>

</div>
</div>
<a class="anchor" id="a3698093973c52835d6fd4b0d8e8ae6cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the transducer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#ad5260b9627048b854b45d05ed34adc22" title="Rename the transducer name. ">set_name</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a21b863776f6733c7e6d8fff1fd8c997b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; string, string &gt; &amp; get_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all properties form transducer. </p>

</div>
</div>
<a class="anchor" id="a8bd7382ae555d4684268dbe7f5f17972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string get_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get arbitrary string propert <em>property</em>. get_property("name") works like get_name. </p>

</div>
</div>
<a class="anchor" id="a98fbee2fcce877b2644c4ca087466c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> get_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The implementation type of the transducer. </p>

</div>
</div>
<a class="anchor" id="af3b3fe308abdeefa8d45440c9eb51ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void harmonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonize transducers this and another. </p>
<dl class="section note"><dt>Note</dt><dd>In harmonization, the symbol-to-number correspondencies of this transducer are recoded so that they are equivalent to the ones used in transducer another. Then the unknown and identity symbols are expanded in both transducers. If this and <em>another</em> have type FOMA_TYPE, nothing is done, since foma takes care of harmonization. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa669593b6f51b0d2f1d3e5ba6c7e6cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> identity_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create identity pair transducer of <em>type</em>. </p>
<p>The transducer has only one state, and it accepts: Identity:Identity</p>
<p>Transducer weight is 0. </p>

</div>
</div>
<a class="anchor" id="adedc1c93cfc77e20c12fb57683ca8ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; input_project </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the input language of the transducer. </p>
<p>All transition symbol pairs <em>isymbol:osymbol</em> are changed to <em>isymbol:isymbol</em>. </p>

</div>
</div>
<a class="anchor" id="afe4fc79a57dfe964a1d1595ff05a3f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; insert_freely </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freely insert symbol pair <em>symbol_pair</em> into the transducer. </p>
<p>To each state in this transducer is added a transition that leads from that state to itself with input and output symbols defined by <em>symbol_pair</em>.</p>
<p>If harmonize is true, then identity and unknown symbols in the transducer will be exapanded byt the symbols in symbol pair. Otherwise they aren't. </p>

</div>
</div>
<a class="anchor" id="aea867d434bc28c63e3ee8278892108f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; insert_freely </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freely insert a copy of <em>tr</em> into the transducer. </p>
<p>A copy of <em>tr</em> is attached with epsilon transitions to each state of this transducer. After the operation, for each state S in this transducer, there is an epsilon transition that leads from state S to the initial state of <em>tr</em>, and for each final state of <em>tr</em>, there is an epsilon transition that leads from that final state to state S in this transducer. The weights of the final states in <em>tr</em> are copied to the epsilon transitions leading to state S.</p>
<p>Implemented only for <a class="el" href="namespacehfst_1_1implementations.html#a873b7a6485acf29c1a0f450f57ac37aa" title="An HfstTransitionGraph with transitions of type HfstTropicalTransducerTransitionData and weight type ...">implementations::HfstBasicTransducer</a>. Conversion is carried out for an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>, if this function is called. </p>

</div>
</div>
<a class="anchor" id="ab49b15abdea97232b4e9a8f47ece7001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_to_alphabet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly insert <em>symbol</em> to the alphabet of the transducer. </p>
<dl class="section note"><dt>Note</dt><dd>Usually this function is not needed since new symbols are added to the alphabet by default. </dd></dl>

</div>
</div>
<a class="anchor" id="aee8bf9c5cc6b41c41fbf68fa7904d8a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersect this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="a00f7f70fb22b280ed5c5332e465ad15a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the input and output symbols of each transition in the transducer. </p>

</div>
</div>
<a class="anchor" id="a991d38da32398b0f78fb1b10c28c92d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_automaton </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is an automaton. </p>

</div>
</div>
<a class="anchor" id="a2d15200648b544ecae3daf4e80447c9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cyclic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is cyclic. </p>

</div>
</div>
<a class="anchor" id="a93af3422529e5f224785a12cc13be901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_lookdown_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Not implemented) Whether lookdown of path <em>s</em> will have infinite results. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>todo </dd></dl>

</div>
</div>
<a class="anchor" id="a28d01744017bf093961bc1d5e30dff5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_lookup_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether lookup of path <em>s</em> will have infinite results. </p>
<p>Currently, this function will return whether the transducer is infinitely ambiguous on any lookup path found in the transducer, i.e. the argument <em>s</em> is ignored.</p>
<dl class="section see"><dt>See also</dt><dd>lookup(HfstOneLevelPaths&amp;, const StringVector&amp;, ssize_t) const  </dd></dl>

</div>
</div>
<a class="anchor" id="a39f458d161e71e1fcb0d4536c5083398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; lenient_composition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make lenient composition of this transducer with <em></em>. A .O. B = [ A .o. B ] .P. A. </p>

</div>
</div>
<a class="anchor" id="aef6b04f95ba7242840aa5d4d2656ad49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> * lookdown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Not implemented) Lookdown a single string <em>s</em> and return a maximum of <em>limit</em> results. </p>
<p>Traverse all paths on logical second level of the transducer to produce all possible inputs on the first. This is in effect a fast composition of single path from left hand side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to look down</td></tr>
    <tr><td class="paramname">limit</td><td>number of strings to extract. -1 tries to extract all and may get stuck if infinitely ambiguous </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output parameter to store unique results </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>todo </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5e476d38e5fa6a088516a5ce44cb33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> * lookdown_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Not implemented) Lookdown a single string minding flag diacritics properly. </p>
<p>This is a version of lookdown that handles flag diacritics as epsilons and validates the sequences prior to outputting.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#aef6b04f95ba7242840aa5d4d2656ad49" title="(Not implemented) Lookdown a single string s and return a maximum of limit results. ">lookdown</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>todo </dd></dl>

</div>
</div>
<a class="anchor" id="a184666baeb7941cd8fa74d80dc114dd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> * lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_cutoff</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup or apply a single tokenized string <em>s</em> and return a maximum of <em>limit</em> results. </p>
<p>This is a version of lookup that handles flag diacritics as ordinary symbols and does not validate the sequences prior to outputting. Currently, this function calls lookup_fd.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Handle flag diacritics as ordinary symbols instead of calling lookup_fd. <dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a1eaae1983ca4f2ba7d1e264db707c89f" title="Lookup or apply a single string s minding flag diacritics properly and store a maximum of limit resul...">lookup_fd</a> </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a208ce1ed83de80e14832057a867aa6d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> * lookup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_cutoff</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup or apply a single string <em>s</em> and return a maximum of <em>limit</em> results. </p>
<p>This is an overloaded lookup function that leaves tokenizing to the transducer. </p>

</div>
</div>
<a class="anchor" id="a31538571fc5d1fa1682aefeaf1c598d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> * lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;&#160;</td>
          <td class="paramname"><em>tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_cutoff</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup or apply a single string <em>s</em> and store a maximum of <em>limit</em> results to <em>results</em>. <em>tok</em> defined how <em>s</em> is tokenized. </p>
<p>This function is the same as <a class="el" href="classhfst_1_1HfstTransducer.html#a184666baeb7941cd8fa74d80dc114dd0" title="Lookup or apply a single tokenized string s and return a maximum of limit results. ">lookup(const StringVector&amp;, ssize_t, double) const</a> but lookup is not done using a string and a tokenizer instead of a StringVector. </p>

</div>
</div>
<a class="anchor" id="a1eaae1983ca4f2ba7d1e264db707c89f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> * lookup_fd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_cutoff</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup or apply a single string <em>s</em> minding flag diacritics properly and store a maximum of <em>limit</em> results to <em>results</em>. </p>
<p>Traverse all paths on logical first level of the transducer to produce all possible outputs on the second. This is in effect a fast composition of single path from left hand side.</p>
<p>This is a version of lookup that handles flag diacritics as epsilons and validates the sequences prior to outputting. Epsilons on the second level are represented by empty strings in <em>results</em>. For an example of flag diacritics, see <a class="el" href="classhfst_1_1HfstTransducer.html#a520d19db73e0e9e5c86309625852e60d" title="Extract a maximum of max_num paths that are recognized by the transducer and are not invalidated by f...">hfst::HfstTransducer::extract_paths_fd(hfst::HfstTwoLevelPaths&amp;, int, int, bool) const</a></p>
<dl class="section pre"><dt>Precondition</dt><dd>The transducer must be of type <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada74c04de498ac29cbc8e2d337cd11e14a">HFST_OL_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada45e027dcf5ddc6c74297d5e0800fcb22">HFST_OLW_TYPE</a>. This function is not implemented for other transducer types.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to look up. The weight is ignored. </td></tr>
    <tr><td class="paramname">limit</td><td>(Currently ignored.) Number of strings to look up. -1 tries to look up all and may get stuck if infinitely ambiguous. </td></tr>
    <tr><td class="paramname">time_cutoff</td><td>Number of seconds that can pass before lookup is stopped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>{A pointer to a HfstOneLevelPaths container allocated by callee}</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTokenizer.html#af1f36a7d21180755e08be6ab3fc092ea" title="Tokenize the string input_string. ">HfstTokenizer::tokenize_one_level</a> </dd>
<dd>
<a class="el" href="classhfst_1_1HfstTransducer.html#a28d01744017bf093961bc1d5e30dff5a" title="Whether lookup of path s will have infinite results. ">is_lookup_infinitely_ambiguous(const StringVector&amp;) const</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Do not ignore argument <em>limit</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b9f98beeb00a533d348e8dde3b022ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a> * lookup_fd </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_cutoff</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup or apply a single string <em>s</em> minding flag diacritics properly and store a maximum of <em>limit</em> results to <em>results</em>. </p>
<p>This is an overloaded lookup_fd that leaves tokenizing to the transducer.</p>
<dl class="section warning"><dt>Warning</dt><dd>{This function will convert the transducer into HFST_OLW_TYPE which may be very slow for large transducers. Lookup speed can therefore be <em>extremely</em> slow.} <pre class="fragment">   @param s  String to look up. The weight is ignored.
   @param limit  (Currently ignored.) Number of strings to look up. 
                 -1 tries to look up all and may get stuck 
                 if infinitely ambiguous.
   @param time_cutoff Number of seconds that can pass before lookup is stopped.
   \return{A pointer to a HfstOneLevelPaths container allocated by callee}


  @sa lookup_fd  </pre> </dd></dl>

</div>
</div>
<a class="anchor" id="a4447763b733aced7be4051e92ca649f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HFSTDLL <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a>* lookup_fd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a> &amp;&#160;</td>
          <td class="paramname"><em>tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_cutoff</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup or apply a single string <em>s</em> minding flag diacritics properly and store a maximum of <em>limit</em> results to <em>results</em>. <em>tok</em> defines how s is tokenized. </p>
<p>The same as <a class="el" href="classhfst_1_1HfstTransducer.html#a1eaae1983ca4f2ba7d1e264db707c89f" title="Lookup or apply a single string s minding flag diacritics properly and store a maximum of limit resul...">lookup_fd(const StringVector&amp;, ssize_t, double) const </a> but uses a tokenizer and a string instead of a StringVector. </p>

</div>
</div>
<a class="anchor" id="accda6d6aace9571d8ed91b2f75b48339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; minimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the transducer. </p>
<p>Minimizing a transducer yields an equivalent transducer with the smallest number of states.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>OpenFst's minimization algorithm seems to add epsilon transitions to weighted transducers? </dd></dl>

</div>
</div>
<a class="anchor" id="a163866f8a96c38ae553174efc582f0fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; n_best </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract <em>n</em> best paths of the transducer. </p>
<p>In the case of a weighted transducer (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada289203865dd3ec445f7b73921568c5e2">LOG_OPENFST_TYPE</a>), best paths are defined as paths with the lowest weight. In the case of an unweighted transducer (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a>), the function returns random paths.</p>
<p>This function is not implemented for <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a>. If this function is called by an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> of type <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a>, it is converted to <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a>, paths are extracted and it is converted back to <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a>. If HFST is not linked to OpenFst library, an <a class="el" href="structImplementationTypeNotAvailableException.html" title="The library required by the implementation type requested is not linked to HFST. ">ImplementationTypeNotAvailableException</a> is thrown. </p>

</div>
</div>
<a class="anchor" id="a489258a0fdc40997a5ba2196863d2475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign this transducer a new value equivalent to transducer <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="a050e86f27c11fd6653c214954d651636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; optionalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunct the transducer with an epsilon transducer. </p>

</div>
</div>
<a class="anchor" id="aef82f01e4c7013a8204bbfd3b9afeaaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; output_project </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the output language of the transducer. </p>
<p>All transition symbol pairs <em>isymbol:osymbol</em> are changed to <em>osymbol:osymbol</em>. </p>

</div>
</div>
<a class="anchor" id="aa4385a68bbd9b78b0e92885f1346bd40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; priority_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make priority union of this transducer with <em>another</em>. </p>
<p>For the operation t1.priority_union(t2), the result is a union of t1 and t2, except that whenever t1 and t2 have the same string on the upper side, the path in t1 overrides the path in t2.</p>
<p>Example</p>
<p>Transducer 1 (t1): a : a b : b</p>
<p>Transducer 2 (t2): b : B c : C</p>
<p>Result ( t1.priority_union(t2) ): a : a b : b c : C</p>
<p>For more information, read: www.fsmbook.com </p>

</div>
</div>
<a class="anchor" id="a19a11312b01bc72624b2355fd1eceb80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; prune </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make transducer coaccessible. </p>

</div>
</div>
<a class="anchor" id="ad84a74d73eb33d4f8e5887dc6789cc78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; prune_alphabet </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all symbols that do not occur in transitions of the transducer from its alphabet. </p>
<p>If unknown or identity symbols occur in transitions of the transducer, pruning is not carried out by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>Whether unused symbols are removed even if unknown or identity symbols occur in transitions.</td></tr>
  </table>
  </dd>
</dl>
<p>Epsilon, unknown and identity <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">symbols</a> are always included in the alphabet. </p>

</div>
</div>
<a class="anchor" id="af69ad5df498af8fd49a2e41cd350ead6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; push_weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587">PushType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push weights towards initial or final state(s) as defined by <em>type</em>. </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a>), nothing is done. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587" title="The type of a push operation. ">PushType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a323d87b86ca0779a146a21ec62de66db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> * read_lexc_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile a lexc file in file <em>filename</em> into an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> of type <em>type</em> and return the transducer. </p>

</div>
</div>
<a class="anchor" id="ab3828dcc83e6b2ccfe299f6bbb6dee3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; remove_epsilons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all <em>epsilon:epsilon</em> transitions from the transducer so that the transducer remains equivalent. </p>

</div>
</div>
<a class="anchor" id="a65b9c181d1e5eabaf1e3bd05f4d0fb2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_from_alphabet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <em>symbol</em> from the alphabet of the transducer. CURRENTLY NOT IMPLEMENTED. </p>
<dl class="section pre"><dt>Precondition</dt><dd><em>symbol</em> does not occur in any transition of the transducer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use with care, removing a symbol that occurs in a transition of the transducer can have unexpected results. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f29c90c6658d0400a48df89c802156b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; repeat_n </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of <em>n</em> transducers. </p>

</div>
</div>
<a class="anchor" id="abff6223610887b76091883348461c6da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; repeat_n_minus </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from zero to <em>n</em>, inclusive. </p>

</div>
</div>
<a class="anchor" id="aa5052ff04682d61e936e99496f2d19e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; repeat_n_plus </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from <em>n</em> to infinity, inclusive. </p>

</div>
</div>
<a class="anchor" id="aa6605c70a9c615a9d51188a001445910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; repeat_n_to_k </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from <em>n</em> to <em>k</em>, inclusive. </p>

</div>
</div>
<a class="anchor" id="a3da338f754080944f305e0d11fc4538e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; repeat_plus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from one to infinity. </p>

</div>
</div>
<a class="anchor" id="a682f84143a794ae4d34963da284ff74c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; repeat_star </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from zero to infinity. </p>

</div>
</div>
<a class="anchor" id="ace8717fc51ef80751e5c8cd92e965a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the transducer. </p>
<p>A reverted transducer accepts the string "n(0) n(1) ... n(N)" iff the original transducer accepts the string "n(N) n(N-1) ... n(0)" </p>

</div>
</div>
<a class="anchor" id="a519cbee51f47f1a5c22b7dd50027e8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; set_final_weights </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>increment</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the weights of all final states to <em>weight</em>. <em>increment</em> defines whether the old weight is incremented by <em>weight</em> or overwritten. </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a>), nothing is done. </p>

</div>
</div>
<a class="anchor" id="ad5260b9627048b854b45d05ed34adc22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename the transducer <em>name</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a3698093973c52835d6fd4b0d8e8ae6cf" title="Get the name of the transducer. ">get_name</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d85426ec06e6c739709ab2dc2179d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set arbitrary string property <em>property</em> to <em>value</em>. set_property("name") equals <code>set_name(string&amp;)</code>. </p>
<dl class="section note"><dt>Note</dt><dd>While this function is capable of creating endless amounts of arbitrary metadata, it is suggested that property names are drawn from central repository, or prefixed with "x-". A property that does not follow this convention may affect the behavior of transducer in future releases. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b2d7b6a06f54fb16f7a021374ea0c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; substitute </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;sp, <a class="el" href="namespacehfst.html#a7e6c1068373d2f96ddf9874c94bdb428">StringPairSet</a> &amp;sps)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all transition <em>sp</em> with transitions <em>sps</em> as defined by function <em>func</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A pointer to a function that takes as its argument a StringPair sp and inserts to StringPairSet sps all StringPairs with which sp is to be substituted. Returns whether any substituting string pairs were inserted in sps, i.e. whether there is a need to perform substitution on transition sp.</td></tr>
  </table>
  </dd>
</dl>
<p>An example: </p><pre class="fragment">bool function(const StringPair &amp;sp, StringPairSet &amp;sps) 
{
  if (sp.second.compare(sp.first) != 0)
    return false;

  std::string isymbol = sp.first;
  std::string osymbol;

  if (sp.second.compare("a") == 0 ||
      sp.second.compare("o") == 0 ||
      sp.second.compare("u") == 0)
    osymbol = std::string("&lt;back_wovel&gt;");
  if (sp.second.compare("e") == 0 ||
      sp.second.compare("i") == 0)
    osymbol = std::string("&lt;front_wovel&gt;");

  sps.insert(StringPair(isymbol, osymbol));
  return true;
}

...

// For all transitions in transducer t whose input and output wovels 
// are equivalent, substitute the output wovel with a symbol that defines
// whether the wovel in question is a front or back wovel.
t.substitute(&amp;function);
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae9279c8f4cf08254d50c3d7dc95fad7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>old_symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>input_side</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output_side</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all transition symbols equal to <em>old_symbol</em> with symbol <em>new_symbol</em>. <em>input_side</em> and <em>output_side</em> define whether the substitution is made on input and output sides. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_symbol</td><td>Symbol to be substituted. </td></tr>
    <tr><td class="paramname">new_symbol</td><td>The substituting symbol. </td></tr>
    <tr><td class="paramname">input_side</td><td>Whether the substitution is made on the input side of a transition. </td></tr>
    <tr><td class="paramname">output_side</td><td>Whether the substitution is made on the output side of a transition.</td></tr>
  </table>
  </dd>
</dl>
<p>The transition weights remain the same.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a000f103a29ce02b1d42e4653729fcfc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;&#160;</td>
          <td class="paramname"><em>old_symbol_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;&#160;</td>
          <td class="paramname"><em>new_symbol_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all transition symbol pairs equal to <em>old_symbol_pair</em> with <em>new_symbol_pair</em>. </p>
<p>The transition weights remain the same.</p>
<p>Implemented only for <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a> and <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada289203865dd3ec445f7b73921568c5e2">LOG_OPENFST_TYPE</a>. If this function is called by an unweighted <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>, it is converted to a weighted one, substitution is made and the transducer is converted back to the original format.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a386626d5d12bcce63694b1ad782ae073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;&#160;</td>
          <td class="paramname"><em>old_symbol_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a7e6c1068373d2f96ddf9874c94bdb428">StringPairSet</a> &amp;&#160;</td>
          <td class="paramname"><em>new_symbol_pair_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all transitions equal to <em>old_symbol_pair</em> with a set of transitions equal to <em>new_symbol_pair_set</em>. </p>
<p>The weight of the original transition is copied to all new transitions.</p>
<p>Implemented only for <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a> and <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada289203865dd3ec445f7b73921568c5e2">LOG_OPENFST_TYPE</a>. If this function is called by an unweighted <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a>), it is converted to <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a>, substitution is done and it is converted back to the original format.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac4db00ae1e826d31caad13cf0a70346f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a21db22f2a65366b5c47d8ee32ac6ffe6">HfstSymbolSubstitutions</a> &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all transition symbols as defined in <em>substitutions</em>. </p>
<p>Each symbol old_symbol is substituted with symbol new_symbol, iff substitutions.find(old_symbol) == new_symbol != substitutions.end(). Otherwise, old_symbol remains the same.</p>
<p>This function performs all substitutions at the same time, so it is more efficient than calling substitute separately for each substitution. </p>

</div>
</div>
<a class="anchor" id="a6ae8279af356aca415019545de4f960f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#aa5665d03e1ee19779e624ab8ccbeb83d">HfstSymbolPairSubstitutions</a> &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all transition symbol pairs as defined in <em>substitutions</em>. </p>
<p>Each symbol pair old_isymbol:old_osymbol is substituted with symbol pair new_isymbol:new_osymbol, iff substitutions.find(old_isymbol:old_osymbol) == new_isymbol:new_osymbol != substitutions.end(). Otherwise, old_isymbol:old_osymbol remains the same.</p>
<p>This function performs all substitutions at the same time, so it is more efficient than calling substitute separately for each substitution. </p>

</div>
</div>
<a class="anchor" id="ab9cff8bcd807864d03ebb645e1a9ab75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>transducer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all transitions equal to <em>symbol_pair</em> with a copy of transducer <em>transducer</em>. </p>
<p>A copy of <em>transducer</em> is attached (using epsilon transitions) between the source and target states of the transition to be substituted. The weight of the original transition is copied to the epsilon transition leaving from the source state.</p>
<p>Implemented only for <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a> and <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada289203865dd3ec445f7b73921568c5e2">LOG_OPENFST_TYPE</a>. If this function is called by an unweighted <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> (<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a> or <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a>), it is converted to <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a>, substitution is done and it is converted back to the original format.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff" title="A UTF-8 symbol in a transition. ">String</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a245e72d62ba9f7136e587a880a657a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>another</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>harmonize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract transducer <em>another</em> from this transducer. </p>

</div>
</div>
<a class="anchor" id="a86dae0477240e20ad9e75680a73202c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp; transform_weights </td>
          <td>(</td>
          <td class="paramtype">float(*)(float)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform all transition and state weights as defined in <em>func</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A pointer to a function that takes a weight as its argument and returns a weight that will be the new value of the weight given as the argument.</td></tr>
  </table>
  </dd>
</dl>
<p>An example: </p><pre class="fragment">float func(float f) { 
  return 2*f + 0.5; 
}

...

// All transition and final weights are multiplied by two and summed with 0.5.
transducer.transform_weights(&amp;func);
</pre> <pre class="fragment">If the HfstTransducer is of unweighted type 
(#SFST_TYPE or #FOMA_TYPE), nothing is done.</pre> 
</div>
</div>
<a class="anchor" id="a4545be0a3d195966e420acb85d4aae73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> universal_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create universal pair transducer of <em>type</em>. </p>
<p>The transducer has only one state, and it accepts: Identity:Identity, Unknown:Unknown, Unknown:Epsilon and Epsilon:Unknown</p>
<p>Transducer weight is 0. </p>

</div>
</div>
<a class="anchor" id="ac89a5acd4eab4cf872d0d4375c05e585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_in_att_format </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>ofile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to FILE <em>ofile</em>. <em>write_weights</em> defines whether weights are written. </p>
<p>The fields in the resulting AT&amp;T format are separated by tabulator characters.</p>
<p>NOTE: If the transition symbols contain space characters, the spaces are printed as "@_SPACE_@" because whitespace characters are used as field separators in AT&amp;T format. Epsilon symbols are printed as "@0@".</p>
<pre class="fragment">    If several transducers are written in the same file, they must 
    be separated by a line of two consecutive hyphens "--", so that
    they will be read correctly by 
    HfstTransducer(FILE*, ImplementationType, const std::string&amp;).
</pre><p>An example: </p><pre class="fragment">ImplementationType type = FOMA_TYPE;
HfstTransducer foobar("foo","bar",type);
HfstTransducer epsilon("@_EPSILON_SYMBOL_@",type);
HfstTransducer empty(type);
HfstTransducer a_star("a",type);
a_star.repeat_star();

FILE * ofile = fopen("testfile.att", "wb");
foobar.write_in_att_format(ofile);
fprintf(ofile, "--\n");
epsilon.write_in_att_format(ofile);
fprintf(ofile, "--\n");
empty.write_in_att_format(ofile);
fprintf(ofile, "--\n");
a_star.write_in_att_format(ofile);
fclose(ofile);
</pre><p>This will yield a file "testfile.att" that looks as follows: </p><pre class="fragment">0    1    foo  bar  0.0
1    0.0
--
0    0.0
--
--
0    0.0
0    0    a    a    0.0
</pre> <pre class="fragment">    @throws StreamCannotBeWrittenException 
    @throws StreamIsClosedException

    @see operator&lt;&lt;(std::ostream &amp;out, const HfstTransducer &amp;t)
    @see HfstTransducer(FILE*, ImplementationType, const std::string&amp;)  </pre> 
</div>
</div>
<a class="anchor" id="acb33bedc587a07a5444d68431a030d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_in_att_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to FILE named <em>filename</em>. <em>write_weights</em> defines whether weights are written. </p>
<p>If the file exists, it is overwritten. If the file does not exist, it is created.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#ac89a5acd4eab4cf872d0d4375c05e585" title="Write the transducer in AT&T format to FILE ofile. write_weights defines whether weights are written...">write_in_att_format</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a678ea3e5d75241dba9d3ba3956f3366f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HFSTDLL friend std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write transducer <em>t</em> in AT&amp;T format to ostream <em>out</em>. </p>
<p>The same as <a class="el" href="classhfst_1_1HfstTransducer.html#ac89a5acd4eab4cf872d0d4375c05e585" title="Write the transducer in AT&T format to FILE ofile. write_weights defines whether weights are written...">hfst::HfstTransducer::write_in_att_format(FILE*, bool) const </a> with ostreams. Weights are written if the type of <em>t</em> is weighted. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/eaxelson/hfst-git/hfst/libhfst/src/<a class="el" href="HfstTransducer_8h_source.html">HfstTransducer.h</a></li>
<li>/home/eaxelson/hfst-git/hfst/libhfst/src/HfstTransducer.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 15 2016 12:06:10 for HFST - Helsinki Finite-State Transducer Technology - C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
