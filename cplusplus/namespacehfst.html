<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>HFST - Helsinki Finite-State Transducer Technology - C++ API: hfst Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - C++ API
   &#160;<span id="projectnumber">version 3.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hfst Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A namespace for HFST functions and datatypes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehfst_1_1implementations"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1implementations.html">implementations</a></td></tr>
<tr class="memdesc:namespacehfst_1_1implementations"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace for all code that forms a bridge between backend libraries and HFST. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehfst_1_1rules"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1rules.html">rules</a></td></tr>
<tr class="memdesc:namespacehfst_1_1rules"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace for functions that create two-level, replace, restriction and coercion rule transducers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehfst_1_1xeroxRules"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1xeroxRules.html">xeroxRules</a></td></tr>
<tr class="memdesc:namespacehfst_1_1xeroxRules"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace for HFST <a class="el" href="namespacehfst_1_1xeroxRules.html" title="A namespace for HFST xeroxRules functions and data types. ">xeroxRules</a> functions and data types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstInputStream.html">HfstInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for reading HFST binary transducers.  <a href="classhfst_1_1HfstInputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstOutputStream.html">HfstOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for writing binary transducers.  <a href="classhfst_1_1HfstOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tokenizer for creating transducers from UTF-8 strings.  <a href="classhfst_1_1HfstTokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synchronous finite-state transducer.  <a href="classhfst_1_1HfstTransducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa4a7c22eee3432b580225fab7d3029af"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; float, <br class="typebreak" />
<a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#aa4a7c22eee3432b580225fab7d3029af">HfstOneLevelPath</a></td></tr>
<tr class="memdesc:aa4a7c22eee3432b580225fab7d3029af"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path of one level of arcs with collected weight.  <a href="#aa4a7c22eee3432b580225fab7d3029af">More...</a><br /></td></tr>
<tr class="separator:aa4a7c22eee3432b580225fab7d3029af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77d8555d43f38781ea8d51d86b18f03"><td class="memItemLeft" align="right" valign="top">typedef std::set<br class="typebreak" />
&lt; <a class="el" href="namespacehfst.html#aa4a7c22eee3432b580225fab7d3029af">HfstOneLevelPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a></td></tr>
<tr class="memdesc:ae77d8555d43f38781ea8d51d86b18f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of simple paths.  <a href="#ae77d8555d43f38781ea8d51d86b18f03">More...</a><br /></td></tr>
<tr class="separator:ae77d8555d43f38781ea8d51d86b18f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5665d03e1ee19779e624ab8ccbeb83d"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a>, <br class="typebreak" />
<a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#aa5665d03e1ee19779e624ab8ccbeb83d">HfstSymbolPairSubstitutions</a></td></tr>
<tr class="memdesc:aa5665d03e1ee19779e624ab8ccbeb83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of substitutions used when performing multiple symbol pair-to-symbol pair substitutions.  <a href="#aa5665d03e1ee19779e624ab8ccbeb83d">More...</a><br /></td></tr>
<tr class="separator:aa5665d03e1ee19779e624ab8ccbeb83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21db22f2a65366b5c47d8ee32ac6ffe6"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>, <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a21db22f2a65366b5c47d8ee32ac6ffe6">HfstSymbolSubstitutions</a></td></tr>
<tr class="memdesc:a21db22f2a65366b5c47d8ee32ac6ffe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of substitutions used when performing multiple symbol-to-symbol substitutions.  <a href="#a21db22f2a65366b5c47d8ee32ac6ffe6">More...</a><br /></td></tr>
<tr class="separator:a21db22f2a65366b5c47d8ee32ac6ffe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938efd3cb9d5bb7fb0dd2d0984276968"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak" />
&lt; <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a>, <br class="typebreak" />
<a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a938efd3cb9d5bb7fb0dd2d0984276968">HfstTransducerPair</a></td></tr>
<tr class="memdesc:a938efd3cb9d5bb7fb0dd2d0984276968"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of transducers.  <a href="#a938efd3cb9d5bb7fb0dd2d0984276968">More...</a><br /></td></tr>
<tr class="separator:a938efd3cb9d5bb7fb0dd2d0984276968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2acebcbcbc335382c56574db5b5528"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak" />
&lt; <a class="el" href="namespacehfst.html#a938efd3cb9d5bb7fb0dd2d0984276968">HfstTransducerPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a3e2acebcbcbc335382c56574db5b5528">HfstTransducerPairVector</a></td></tr>
<tr class="memdesc:a3e2acebcbcbc335382c56574db5b5528"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of transducer pairs.  <a href="#a3e2acebcbcbc335382c56574db5b5528">More...</a><br /></td></tr>
<tr class="separator:a3e2acebcbcbc335382c56574db5b5528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffd27e1aebb79fc4226492dcb0d6b35"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak" />
&lt; <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a5ffd27e1aebb79fc4226492dcb0d6b35">HfstTransducerVector</a></td></tr>
<tr class="memdesc:a5ffd27e1aebb79fc4226492dcb0d6b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">a vector of transducers for methods applying a cascade of automata  <a href="#a5ffd27e1aebb79fc4226492dcb0d6b35">More...</a><br /></td></tr>
<tr class="separator:a5ffd27e1aebb79fc4226492dcb0d6b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226589a7ee24b92cab72cbb570e3e33d"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; float, <br class="typebreak" />
<a class="el" href="namespacehfst.html#a15bf6500cb543515e5c6270328a18142">StringPairVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a226589a7ee24b92cab72cbb570e3e33d">HfstTwoLevelPath</a></td></tr>
<tr class="memdesc:a226589a7ee24b92cab72cbb570e3e33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path of two level of arcs with collected weight.  <a href="#a226589a7ee24b92cab72cbb570e3e33d">More...</a><br /></td></tr>
<tr class="separator:a226589a7ee24b92cab72cbb570e3e33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d66467d22da6864597a7a2cf700e32"><td class="memItemLeft" align="right" valign="top">typedef std::set<br class="typebreak" />
&lt; <a class="el" href="namespacehfst.html#a226589a7ee24b92cab72cbb570e3e33d">HfstTwoLevelPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#af0d66467d22da6864597a7a2cf700e32">HfstTwoLevelPaths</a></td></tr>
<tr class="memdesc:af0d66467d22da6864597a7a2cf700e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of two-level weighted paths.  <a href="#af0d66467d22da6864597a7a2cf700e32">More...</a><br /></td></tr>
<tr class="separator:af0d66467d22da6864597a7a2cf700e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeda3fd1bdc8c37d01bdf9f5c8274ff"><td class="memItemLeft" align="right" valign="top">typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a></td></tr>
<tr class="memdesc:afbeda3fd1bdc8c37d01bdf9f5c8274ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-8 symbol in a transition.  <a href="#afbeda3fd1bdc8c37d01bdf9f5c8274ff">More...</a><br /></td></tr>
<tr class="separator:afbeda3fd1bdc8c37d01bdf9f5c8274ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a68055e08ad15dcad790e426e0d68ce"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>, <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a></td></tr>
<tr class="memdesc:a0a68055e08ad15dcad790e426e0d68ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol pair in a transition.  <a href="#a0a68055e08ad15dcad790e426e0d68ce">More...</a><br /></td></tr>
<tr class="separator:a0a68055e08ad15dcad790e426e0d68ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6c1068373d2f96ddf9874c94bdb428"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a7e6c1068373d2f96ddf9874c94bdb428">StringPairSet</a></td></tr>
<tr class="memdesc:a7e6c1068373d2f96ddf9874c94bdb428"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of symbol pairs used in substituting symbol pairs and in rule functions.  <a href="#a7e6c1068373d2f96ddf9874c94bdb428">More...</a><br /></td></tr>
<tr class="separator:a7e6c1068373d2f96ddf9874c94bdb428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bf6500cb543515e5c6270328a18142"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::pair<br class="typebreak" />
&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a15bf6500cb543515e5c6270328a18142">StringPairVector</a></td></tr>
<tr class="memdesc:a15bf6500cb543515e5c6270328a18142"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of string pairs.  <a href="#a15bf6500cb543515e5c6270328a18142">More...</a><br /></td></tr>
<tr class="separator:a15bf6500cb543515e5c6270328a18142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa650136e4c78fa3a0eacfd66ae7fd13b"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a></td></tr>
<tr class="memdesc:aa650136e4c78fa3a0eacfd66ae7fd13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of strings.  <a href="#aa650136e4c78fa3a0eacfd66ae7fd13b">More...</a><br /></td></tr>
<tr class="separator:aa650136e4c78fa3a0eacfd66ae7fd13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a38d09b24b35cffd241147dd83303baad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a> { <br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c">SFST_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317">TROPICAL_OPENFST_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada289203865dd3ec445f7b73921568c5e2">LOG_OPENFST_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547">FOMA_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada951956f65d095b4c0baa7a1f68eb06a1">XFSM_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada74c04de498ac29cbc8e2d337cd11e14a">HFST_OL_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada45e027dcf5ddc6c74297d5e0800fcb22">HFST_OLW_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baadaabf158bd75c7e4968631342fc8f29043">HFST2_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada92a9dda6afda145732f17abcb01c806a">UNSPECIFIED_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baada4264d2d69604d4adf5c3d11ac7292b7a">ERROR_TYPE</a>
<br />
 }</td></tr>
<tr class="memdesc:a38d09b24b35cffd241147dd83303baad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an HfstTransducer.  <a href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">More...</a><br /></td></tr>
<tr class="separator:a38d09b24b35cffd241147dd83303baad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524e5aa1a59ef57d159a082ff58ca587"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587">PushType</a> { <br />
&#160;&#160;<a class="el" href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587af004bb3ceba2b173e3745318175e67c0">TO_INITIAL_STATE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587ae9a9f4653ada9bb20369808a0cf720ad">TO_FINAL_STATE</a>
<br />
 }</td></tr>
<tr class="memdesc:a524e5aa1a59ef57d159a082ff58ca587"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a push operation.  <a href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587">More...</a><br /></td></tr>
<tr class="separator:a524e5aa1a59ef57d159a082ff58ca587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e046d9354037c3e2b7843957bf9ac2c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a8e046d9354037c3e2b7843957bf9ac2c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &amp;t)</td></tr>
<tr class="memdesc:a8e046d9354037c3e2b7843957bf9ac2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write transducer <em>t</em> in AT&amp;T format to ostream <em>out</em>.  <a href="#a8e046d9354037c3e2b7843957bf9ac2c">More...</a><br /></td></tr>
<tr class="separator:a8e046d9354037c3e2b7843957bf9ac2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for HFST functions and datatypes. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aa4a7c22eee3432b580225fab7d3029af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; float, <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a> &gt; <a class="el" href="namespacehfst.html#aa4a7c22eee3432b580225fab7d3029af">HfstOneLevelPath</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A path of one level of arcs with collected weight. </p>
<p>Used as the source and result data type for lookups and downs. In the first case, the float is ignored. In the latter case, the float represents the weight of the path.</p>
<dl class="section see"><dt>See also</dt><dd>HfstTokenizer::lookup_tokenize </dd>
<dd>
<a class="el" href="classhfst_1_1HfstTransducer.html#a184666baeb7941cd8fa74d80dc114dd0" title="Lookup or apply a single tokenized string s and return a maximum of limit results. ">HfstTransducer::lookup</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae77d8555d43f38781ea8d51d86b18f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="namespacehfst.html#aa4a7c22eee3432b580225fab7d3029af">HfstOneLevelPath</a>&gt; <a class="el" href="namespacehfst.html#ae77d8555d43f38781ea8d51d86b18f03">HfstOneLevelPaths</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of simple paths. </p>
<p>Used as return type of lookup with multiple, unique results. </p>

</div>
</div>
<a class="anchor" id="aa5665d03e1ee19779e624ab8ccbeb83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a>, <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a>&gt; <a class="el" href="namespacehfst.html#aa5665d03e1ee19779e624ab8ccbeb83d">HfstSymbolPairSubstitutions</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map of substitutions used when performing multiple symbol pair-to-symbol pair substitutions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a6ae8279af356aca415019545de4f960f" title="Substitute all transition symbol pairs as defined in substitutions. ">HfstTransducer::substitute(const HfstSymbolPairSubstitutions&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a21db22f2a65366b5c47d8ee32ac6ffe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>, <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&gt; <a class="el" href="namespacehfst.html#a21db22f2a65366b5c47d8ee32ac6ffe6">HfstSymbolSubstitutions</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map of substitutions used when performing multiple symbol-to-symbol substitutions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#ac4db00ae1e826d31caad13cf0a70346f" title="Substitute all transition symbols as defined in substitutions. ">HfstTransducer::substitute(const HfstSymbolSubstitutions&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a938efd3cb9d5bb7fb0dd2d0984276968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a>,<a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a>&gt; <a class="el" href="namespacehfst.html#a938efd3cb9d5bb7fb0dd2d0984276968">HfstTransducerPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair of transducers. </p>
<p>Used by functions in namespace <a class="el" href="namespacehfst_1_1rules.html">rules</a> </p>

</div>
</div>
<a class="anchor" id="a3e2acebcbcbc335382c56574db5b5528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacehfst.html#a938efd3cb9d5bb7fb0dd2d0984276968">HfstTransducerPair</a>&gt; <a class="el" href="namespacehfst.html#a3e2acebcbcbc335382c56574db5b5528">HfstTransducerPairVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of transducer pairs. </p>
<p>Used by functions in namespace <a class="el" href="namespacehfst_1_1rules.html">rules</a> </p>

</div>
</div>
<a class="anchor" id="a5ffd27e1aebb79fc4226492dcb0d6b35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a> &gt; <a class="el" href="namespacehfst.html#a5ffd27e1aebb79fc4226492dcb0d6b35">HfstTransducerVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a vector of transducers for methods applying a cascade of automata </p>
<p>A vector of transducers.</p>
<p>Used by compose_intersect. </p>

</div>
</div>
<a class="anchor" id="a226589a7ee24b92cab72cbb570e3e33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; float, <a class="el" href="namespacehfst.html#a15bf6500cb543515e5c6270328a18142">StringPairVector</a> &gt; <a class="el" href="namespacehfst.html#a226589a7ee24b92cab72cbb570e3e33d">HfstTwoLevelPath</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A path of two level of arcs with collected weight. </p>

</div>
</div>
<a class="anchor" id="af0d66467d22da6864597a7a2cf700e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt; <a class="el" href="namespacehfst.html#a226589a7ee24b92cab72cbb570e3e33d">HfstTwoLevelPath</a> &gt; <a class="el" href="namespacehfst.html#af0d66467d22da6864597a7a2cf700e32">HfstTwoLevelPaths</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of two-level weighted paths. </p>

</div>
</div>
<a class="anchor" id="afbeda3fd1bdc8c37d01bdf9f5c8274ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::string <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-8 symbol in a transition. </p>
<p>Strings <em>"@_EPSILON_SYMBOL_@"</em>, <em>"@_UNKNOWN_SYMBOL_@"</em> and <em>"@_IDENTITY_SYMBOL_@"</em> are reserved.</p>
<ul>
<li><em>"@_EPSILON_SYMBOL_@"</em> denotes the epsilon (in AT&amp;T formalism <code>[0]</code>).</li>
<li><em>"@_UNKNOWN_SYMBOL_@"</em> denotes an unknown symbol, i.e. any symbol that does not occur or has not occurred in the transducer (in AT&amp;T formalism <code>[?], [?:x], [x:?]</code>).</li>
<li><p class="startli"><em>"@_IDENTITY_SYMBOL_@"</em> denotes any unknown symbol that is the same on the input and output side of a transition (in AT&amp;T formalism <code>[?:?]</code>).</p>
<p class="startli">For an example of special symbols, see HFST transducer <a href="classhfst_1_1HfstTransducer.html#symbols">documentation</a>.</p>
</li>
</ul>
<p>Strings of form <code> @[PNDRCU][.][A-Z]+([.][A-Z]+)?@ </code> are reserved for flag diacritics. For an example of flag diacritics, see <a class="el" href="classhfst_1_1HfstTransducer.html#a520d19db73e0e9e5c86309625852e60d" title="Extract a maximum of max_num paths that are recognized by the transducer and are not invalidated by f...">hfst::HfstTransducer::extract_paths_fd(hfst::HfstTwoLevelPaths&amp;, int, int, bool) const</a>. For more information on flag diacritics, see Finite State Morphology (Beesley &amp; Karttunen, 2003). </p>

</div>
</div>
<a class="anchor" id="a0a68055e08ad15dcad790e426e0d68ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>, <a class="el" href="namespacehfst.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&gt; <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A symbol pair in a transition. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a000f103a29ce02b1d42e4653729fcfc9" title="Substitute all transition symbol pairs equal to old_symbol_pair with new_symbol_pair. ">HfstTransducer::substitute(const StringPair&amp;, const StringPair&amp;)</a> and other substitute functions </dd></dl>

</div>
</div>
<a class="anchor" id="a7e6c1068373d2f96ddf9874c94bdb428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a>&gt; <a class="el" href="namespacehfst.html#a7e6c1068373d2f96ddf9874c94bdb428">StringPairSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of symbol pairs used in substituting symbol pairs and in rule functions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a386626d5d12bcce63694b1ad782ae073" title="Substitute all transitions equal to old_symbol_pair with a set of transitions equal to new_symbol_pai...">HfstTransducer::substitute(const StringPair&amp;, const StringPairSet &amp;)</a> <a class="el" href="namespacehfst_1_1rules.html" title="A namespace for functions that create two-level, replace, restriction and coercion rule transducers...">hfst::rules</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a15bf6500cb543515e5c6270328a18142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="namespacehfst.html#a0a68055e08ad15dcad790e426e0d68ce">StringPair</a> &gt; <a class="el" href="namespacehfst.html#a15bf6500cb543515e5c6270328a18142">StringPairVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of string pairs. </p>
<p>A vector of transitions that represents a path in a transducer.</p>
<p>Used by typedef HfstTwoLevelPath.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTokenizer.html" title="A tokenizer for creating transducers from UTF-8 strings. ">HfstTokenizer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa650136e4c78fa3a0eacfd66ae7fd13b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; std::string &gt; <a class="el" href="namespacehfst.html#aa650136e4c78fa3a0eacfd66ae7fd13b">StringVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of strings. </p>
<p>Used by typedef HfstOneLevelPath. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a38d09b24b35cffd241147dd83303baad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehfst.html#a38d09b24b35cffd241147dd83303baad">ImplementationType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada9c77d95bb5618dc05aed7877347cd65c"></a>SFST_TYPE&#160;</td><td class="fielddoc">
<p>An SFST transducer, unweighted. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada3e9ae0cfdd2849f1075b9a51a4b17317"></a>TROPICAL_OPENFST_TYPE&#160;</td><td class="fielddoc">
<p>An OpenFst transducer with tropical weights. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada289203865dd3ec445f7b73921568c5e2"></a>LOG_OPENFST_TYPE&#160;</td><td class="fielddoc">
<p>An OpenFst transducer with logarithmic weights. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada95fbf943fa8007f8224d4ce9d6f6e547"></a>FOMA_TYPE&#160;</td><td class="fielddoc">
<p>A foma transducer, unweighted. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada951956f65d095b4c0baa7a1f68eb06a1"></a>XFSM_TYPE&#160;</td><td class="fielddoc">
<p>An xfsm transducer, unweighted (mostly for testing purposes). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada74c04de498ac29cbc8e2d337cd11e14a"></a>HFST_OL_TYPE&#160;</td><td class="fielddoc">
<p>An HFST optimized lookup transducer, unweighted </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada45e027dcf5ddc6c74297d5e0800fcb22"></a>HFST_OLW_TYPE&#160;</td><td class="fielddoc">
<p>An HFST optimized lookup transducer with weights </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baadaabf158bd75c7e4968631342fc8f29043"></a>HFST2_TYPE&#160;</td><td class="fielddoc">
<p>HFST2 header present, conversion required </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada92a9dda6afda145732f17abcb01c806a"></a>UNSPECIFIED_TYPE&#160;</td><td class="fielddoc">
<p>Format left open by e.g. default constructor </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a38d09b24b35cffd241147dd83303baada4264d2d69604d4adf5c3d11ac7292b7a"></a>ERROR_TYPE&#160;</td><td class="fielddoc">
<p>Type not recognised. This type might be returned by a function if an error occurs. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a524e5aa1a59ef57d159a082ff58ca587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehfst.html#a524e5aa1a59ef57d159a082ff58ca587">PushType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a push operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#af69ad5df498af8fd49a2e41cd350ead6" title="Push weights towards initial or final state(s) as defined by type. ">HfstTransducer::push_weights</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a524e5aa1a59ef57d159a082ff58ca587af004bb3ceba2b173e3745318175e67c0"></a>TO_INITIAL_STATE&#160;</td><td class="fielddoc">
<p>Push weights towards initial state. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a524e5aa1a59ef57d159a082ff58ca587ae9a9f4653ada9bb20369808a0cf720ad"></a>TO_FINAL_STATE&#160;</td><td class="fielddoc">
<p>Push weights towards final state(s). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8e046d9354037c3e2b7843957bf9ac2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HFSTDLL std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HfstTransducer &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write transducer <em>t</em> in AT&amp;T format to ostream <em>out</em>. </p>
<p>The same as <a class="el" href="classhfst_1_1HfstTransducer.html#ac89a5acd4eab4cf872d0d4375c05e585" title="Write the transducer in AT&T format to FILE ofile. write_weights defines whether weights are written...">hfst::HfstTransducer::write_in_att_format(FILE*, bool) const </a> with ostreams. Weights are written if the type of <em>t</em> is weighted. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 15 2016 12:06:10 for HFST - Helsinki Finite-State Transducer Technology - C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
