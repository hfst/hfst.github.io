<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>HFST - Helsinki Finite-State Transducer Technology - C++ API: Adding your own implementation under the HFST API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - C++ API
   &#160;<span id="projectnumber">version 3.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Adding your own implementation under the HFST API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The HFST API is currently implemented with three finite-state libraries, SFST, OpenFst and foma. The API is designed so that it is relatively easy to add a new implementation to it. There are some places in the code where you must make modifications but they are all clearly marked in the files inside comments. Most of these modifications just make HFST aware that there is a new implementation available and are quite straightforward to carry out. The new backend implementation itself is written in a separate file that must fulfil an interface common to all backend implementations. This interface defines functions that create and operate on transducers as well as datatypes for writing and reading binary transducers. This interface is used for cooperation between the different finite-state libraries and the HFST API that is visible to the end-user.</p>
<p>We first tell what functions and datatypes your implementation must must offer so that it can be connected as a part of the HFST API. We then go through the modifications that you must do to the code when adding your implementation to the HFST API. All these modifications are also indicated in the code inside comments, so we do not handle each change here but advise you to see the files instead. Finally we tell what changes must be done in the configuration file.</p>
<p><br />
</p>
<h2>The interaction between HFST and the new finite-state library</h2>
<p>The directory libhfst/src/implementations contains two files per each library that is added under HFST. For instance for SFST there are files <a class="el" href="SfstTransducer_8h.html" title="Declarations of functions and datatypes that form a bridge between HFST API and SFST. ">SfstTransducer.h</a> and SfstTransducer.cc. If a library offers more than one transducer format, there are separate files for each format. For example for OpenFst there are files TropicalWeightTransducer.cc and .h and LogWeightTransducer.cc and .h. Each pair of files contains three static classes that act as an interface between HFST and the finite-state library in question. For instance the files <a class="el" href="FomaTransducer_8h.html" title="Declarations of functions and datatypes that form a bridge between HFST API and foma. ">FomaTransducer.h</a> and FomaTransducer.cc contain classes FomaTransducer, FomaInputStream and FomaOutputStream that take care of interoperation between the foma library and HFST.</p>
<p>The directory contains skeleton files <a class="el" href="MyTransducerLibraryTransducer_8h.html" title="Declarations of functions and datatypes that form a bridge between the HFST API and your transducer l...">MyTransducerLibraryTransducer.h</a> and MyTransducerLibraryTransducer.cc. These files define a group of static classes MyTransducerLibraryTransducer, MyTransducerLibraryInputStream and MyTransducerLibraryOutputStream that contain functions that operate on transducers and streams. These classes act as an interface between HFST and your library. You should write your implementations to these files. The assumption is that most of the functionalities are found already in the finite-state library that you are using and you just have to modify them a little so that thay can be accessed via a standardized interface that works similarily for all implementations.</p>
<p>All functions in the skeleton files return a <a class="el" href="structFunctionNotImplementedException.html" title="Function has not been implemented (yet). ">FunctionNotImplementedException</a> as they have no implementation. When starting to write your own implementation, you can also return the same exception for all functions that you have not yet implemented.</p>
<p>In the same directory there are files <a class="el" href="ConvertTransducerFormat_8h.html" title="Declarations of functions for converting between transducer backend formats. ">ConvertTransducerFormat.h</a> ConvertTransducerFormat.cc that contain functions that convert between HFST's own transducer format, <a class="el" href="namespacehfst_1_1implementations.html#a873b7a6485acf29c1a0f450f57ac37aa" title="An HfstTransitionGraph with transitions of type HfstTropicalTransducerTransitionData and weight type ...">hfst::implementations::HfstBasicTransducer</a>, and the transducer formats of different implementations. Add here functions that convert between HfstBasicTransducer and your transducer class (change MyFst to the name of your transducer class, my_namespace to the namespace where it is written and "my_transducer_library" to the name of your transducer library or some other descriptive name):</p>
<pre class="fragment">  #if HAVE_MY_TRANSDUCER_LIBRARY
  static HfstBasicTransducer * 
    my_transducer_library_transducer_to_hfst_basic_transducer
      (my_namespace::MyFst * t);
  
  static my_namespace::MyFst * 
    hfst_basic_transducer_to_my_transducer_library_transducer
      (const HfstBasicTransducer * t);
  #endif // HAVE_MY_TRANSDUCER_LIBRARY
</pre><p>Add also the following lines to libhfst/src/implementations/Makefile.am:</p>
<pre class="fragment">if WANT_MY_TRANSDUCER_LIBRARY
MAYBE_MY_TRANSDUCER_LIBRARY=MyTransducerLibraryTransducer.cc
endif
</pre><p>and the variable <code></code> to the list of source files:</p>
<pre class="fragment">BRIDGE_SRCS=$(MAYBE_SFST) $(MAYBE_OPENFST) $(MAYBE_FOMA) $(MAYBE_HFSTOL) # $(MAYBE_MY_TRANSDUCER_LIBRARY)
</pre> <pre class="fragment"> &lt;BR&gt;


 &lt;H2&gt;Making HFST aware of your implementation&lt;/H2&gt;

 When you have written your implementation, you must connect it to
 HFST.

 In file HfstDataTypes.h there is an enum ImplementationType that
 lists all possible HfstTransducer implementation types.
 It needs a new enumerator:
</pre><pre class="fragment">     MY_TRANSDUCER_LIBRARY_TYPE, 
</pre> <pre class="fragment"> In file HfstTransducer.h you must include the header file 
 MyTransducerLibraryTransducer.h.
</pre><pre class="fragment">#if HAVE_MY_TRANSDUCER_LIBRARY
#include "implementations/MyTransducerLibraryTransducer.h"
#endif
</pre> <pre class="fragment"> and declare that you are using the static class MyTransducerLibraryTransducer:
</pre><pre class="fragment">#if HAVE_MY_TRANSDUCER_LIBRARY
  using hfst::implementations::MyTransducerLibraryTransducer;
#endif // #if HAVE_MY_TRANSDUCER_LIBRARY
</pre><p>You must add the transducer type of the finite-state library that you are using to TransducerImplementation, the union of possible transducer backend implementations:</p>
<pre class="fragment">#if HAVE_MY_TRANSDUCER_LIBRARY
  hfst::implementations::MyFst * my_transducer_library;
#endif
</pre><p>The transducer type is the only thing that HFST is directly aware of the new finite-state library. All other functionalities are accessed through classes MyTransducerLibraryTransducer, MyTransducerLibraryInputStream and MyTransducerLibraryOutputStream.</p>
<p>You also need and interface to the class MyTransducerLibraryTransducer:</p>
<pre class="fragment">#if HAVE_MY_TRANSDUCER_LIBRARY
  static hfst::implementations::MyTransducerLibraryTransducer
    my_transducer_library_interface;
#endif
</pre><p>In file HfstTransducer.cc, you must define the interface between HFST and your transducer library:</p>
<pre class="fragment">#if HAVE_MY_TRANSDUCER_LIBRARY
  hfst::implementations::MyTransducerLibraryTransducer 
    HfstTransducer::my_transducer_library_interface;
#endif
</pre><p>In file <a class="el" href="HfstInputStream_8h.html" title="Declaration of class HfstInputStream. ">HfstInputStream.h</a> union StreamImplementation needs a new value:</p>
<pre class="fragment">#if HAVE_MY_TRANSDUCER_LIBRARY
      hfst::implementations::MyTransducerLibraryInputStream * 
        my_transducer_library;
#endif
</pre><p>as well as enum TransducerType:</p>
<pre class="fragment">      MY_TRANSDUCER_LIBRARY_, /* Your transducer type */
</pre><p>In file <a class="el" href="HfstOutputStream_8h.html" title="Declaration of class HfstOutputStream. ">HfstOutputStream.h</a> union StreamImplementation needs a new value:</p>
<pre class="fragment">#if HAVE_MY_TRANSDUCER_LIBRARY
      hfst::implementations::MyTransducerLibraryOutputStream * 
        my_transducer_library;
#endif
</pre><p>The function declarations in file hfst_apply_schemas.h and their implementations in file HfstApply.cc need an additional argument which is a pointer to a function of the new implementation. See the comments in the files for more information.</p>
<p><br />
</p>
<h2>Using your implementation in HFST</h2>
<p>For all functions, constructors and destructors of classes HfstTransducer, HfstInputStream and HfstOutputStream as well as functions defined in file HfstApply.cc, you must add a piece of code that calls the implementation of that functionality in the class MyTransducerLibraryTransducer, MyTransducerLibraryInputStream or MyTransducerLibraryOutputStream. For some functions you have to call two or more MyTransducerLibraryTransducer functions. However, usually more complex functions are implemented with HFST API basic functions, so they do not have to be implemented separately for each library. By default all functionalities throw a <a class="el" href="structFunctionNotImplementedException.html" title="Function has not been implemented (yet). ">FunctionNotImplementedException</a> if the implementation type requested is not handled as a separate case in the function. This should make it easy for you to start adding your implementations gradually.</p>
<p>You shoud go through carefully files HfstTransducer.cc, HfstInputStream.cc, HfstOutputStream.cc and HfstApply.cc and add for each functionality add a case that calls the implementation of the new finite-state library if the implementation type requires it. We give here some examples of the pattern that it used in HFST to handle different cases and choose the right implementation.</p>
<p>An example of a constructor that creates an empty HfstTransducer:</p>
<pre class="fragment">  HfstTransducer::HfstTransducer(ImplementationType type):
    type(type),anonymous(false),is_trie(true), name("")
  {
    if (not is_implementation_type_available(type))
      HFST_THROW(ImplementationTypeNotAvailableException);

    switch (type)
      {
#if HAVE_SFST
      case SFST_TYPE:
        implementation.sfst = sfst_interface.create_empty_transducer();
        break;
#endif
#if HAVE_OPENFST
      case TROPICAL_OFST_TYPE:
        implementation.tropical_ofst = 
          tropical_ofst_interface.create_empty_transducer();
        this-&gt;type = TROPICAL_OFST_TYPE;
        break;
      case LOG_OFST_TYPE:
        implementation.log_ofst = 
          log_ofst_interface.create_empty_transducer();
        break;
#endif
#if HAVE_FOMA
      case FOMA_TYPE:
        implementation.foma = foma_interface.create_empty_transducer();
        break;
#endif
        /* Add here your implementation. */
        //#if HAVE_MY_TRANSDUCER_LIBRARY
      //case MY_TRANSDUCER_LIBRARY_TYPE:
        //implementation.my_transducer_library 
        //  = my_transducer_library_interface.create_empty_transducer();
        //break;
        //#endif
      case HFST_OL_TYPE:
      case HFST_OLW_TYPE:
        implementation.hfst_ol = hfst_ol_interface.create_empty_transducer
          (type==HFST_OLW_TYPE?true:false);
        break;
      case ERROR_TYPE:
        HFST_THROW(TransducerHasWrongTypeException);
      default:
        HFST_THROW(FunctionNotImplementedException);
      }
  }
</pre><p>Many functions call a function in file HfstApply.cc that takes as parameters pointers to all backend implementation functions that are available. For example the function remove_epsilons</p>
<pre class="fragment">  HfstTransducer &amp;HfstTransducer::remove_epsilons()
  { is_trie = false;
    return apply(
#if HAVE_SFST
       &amp;hfst::implementations::SfstTransducer::remove_epsilons,
#endif
#if HAVE_OPENFST
       &amp;hfst::implementations::TropicalWeightTransducer::remove_epsilons,
       &amp;hfst::implementations::LogWeightTransducer::remove_epsilons,
#endif
#if HAVE_FOMA
       &amp;hfst::implementations::FomaTransducer::remove_epsilons,
#endif
       /* Add here your implementation. */
       //#if HAVE_MY_TRANSDUCER_LIBRARY
       //&amp;hfst::implementations::MyTransducerLibraryTransducer::remove_epsilons,
       //#endif
       false ); }</pre><p>calls the function</p>
<pre class="fragment">HfstTransducer &amp;apply(
#if HAVE_SFST
 SFST::Transducer * (*sfst_funct)(SFST::Transducer *),
#endif
#if HAVE_OPENFST
 fst::StdVectorFst * (*tropical_ofst_funct)(fst::StdVectorFst *),
 hfst::implementations::LogFst * (*log_ofst_funct)(hfst::implementations::LogFst *),
#endif
#if HAVE_FOMA
 fsm * (*foma_funct)(fsm *),
#endif
 /* Add your library here */
 //#if HAVE_MY_TRANSDUCER_LIBRARY
 //my_namespace::MyFst * (*my_transducer_library_funct)(my_namespace::MyFst *),
 //#endif
 bool dummy /* makes sure there is always a parameter after the function pointer parameters,
             * so commas between parameters are easier to handle */
);  
</pre><p>Then the function 'apply' chooses the right function pointer to use according to the type of the transducer:</p>
<pre class="fragment">  HfstTransducer &amp;HfstTransducer::apply(
#if HAVE_SFST
 SFST::Transducer * (*sfst_funct)(SFST::Transducer *), 
#endif
#if HAVE_OPENFST
 fst::StdVectorFst * (*tropical_ofst_funct)(fst::StdVectorFst *),
 hfst::implementations::LogFst * (*log_ofst_funct)(hfst::implementations::LogFst *),
#endif
#if HAVE_FOMA
 fsm * (*foma_funct)(fsm *),
#endif
 /* Add your library. */
 //#if HAVE_MY_TRANSDUCER_LIBRARY
 //my_namespace::MyFst * (*my_transducer_library_funct)(my_namespace::MyFst *),
 //#endif
  bool foo )
    {
      (void)foo;
    switch(this-&gt;type)
      {
#if HAVE_SFST
      case SFST_TYPE:
        {
          SFST::Transducer * sfst_temp = 
            sfst_funct(implementation.sfst);
          delete implementation.sfst;
          implementation.sfst = sfst_temp;
          break;
        }
#endif
#if HAVE_OPENFST
      case TROPICAL_OFST_TYPE:
        {
          fst::StdVectorFst * tropical_ofst_temp =
            tropical_ofst_funct(implementation.tropical_ofst);
          delete implementation.tropical_ofst;
          implementation.tropical_ofst = tropical_ofst_temp;
          break;
        }
      case LOG_OFST_TYPE:
        {
          hfst::implementations::LogFst * log_ofst_temp =
            log_ofst_funct(implementation.log_ofst);
          delete implementation.log_ofst;
          implementation.log_ofst = log_ofst_temp;
          break;
        }
#endif
#if HAVE_FOMA
      case FOMA_TYPE:
        {
      fsm * foma_temp =
            foma_funct(implementation.foma);
          this-&gt;foma_interface.delete_foma(implementation.foma);
          implementation.foma = foma_temp;
          break;
        }
#endif
        /* Add your library here. */
        //#if HAVE_MY_TRANSDUCER_LIBRARY
        //case MY_TRANSDUCER_LIBRARY_TYPE:
        //{
        //  my_namespace::MyFst * my_fst_temp =
        //  my_transducer_library_funct(implementation.my_transducer_library);
        //delete implementation.my_transducer_library;
        //implementation.my_transducer_library = my_fst_temp;
        //break;
        //}
        //#endif
        case ERROR_TYPE:
        default:
          HFST_THROW(TransducerHasWrongTypeException);
      }
    return *this;
  }
</pre><p>Finally, in file libhfst/src/Makefile.am you must add your library to the list HFST_HDRS:</p>
<pre class="fragment">        implementations/MyTransducerLibraryTransducer.h
</pre><pre class="fragment">  &lt;BR&gt;

  &lt;H2&gt;Configuring&lt;/H2&gt;

  The configuration file must be aware of the new implementation and the finite-state library.
  You have to add the following pieces of code to the file configure.ac
  (change "MY_TRANSDUCER_LIBRARY" etc. to the name of your transducer library):
</pre><pre class="fragment">AC_ARG_WITH([my_transducer_library],
            [AS_HELP_STRING([--with-my-transducer-library],
                            [process unweighted fsts with my transducer library @&lt;:@default=no@:&gt;@])],
            [],
            [with_my_transducer_library=no])
AS_IF([test "x$with_my_transducer_library" != xno], [AC_DEFINE([HAVE_MY_TRANSDUCER_LIBRARY], [1],
                                              [Define to compile my transducer library support in HFST])])
AM_CONDITIONAL([WANT_MY_TRANSDUCER_LIBRARY], [test x$with_my_transducer_library != xno])</pre><pre class="fragment">AS_IF([test "x$with_my_transducer_library" != "xno"],
      [AC_CHECK_LIB([my_transducer_library], [main], [],
                [AC_MSG_FAILURE([my transducer library test failed (--without-my-transducer-library to disable)])])])</pre><pre class="fragment">AS_IF([test "x$with_my_transducer_library" != "xno"],
      [AC_CHECK_HEADERS([my_transducer_library/MyTransducerLibrary.h])])</pre><pre class="fragment">    *         with my transducer library: $with_my_transducer_library</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 15 2016 12:06:10 for HFST - Helsinki Finite-State Transducer Technology - C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
