<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>HFST - Helsinki Finite-State Transducer Technology - Python API: libhfst Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="HFST - Helsinki Finite-State Transducer Technology - Python API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - Python API
   &#160;<span id="projectnumber">version 3.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">libhfst Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>HFST API for Python3.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1ContextTransducersAreNotAutomataException.html">ContextTransducersAreNotAutomataException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducers given as rule context are not automata.  <a href="classlibhfst_1_1ContextTransducersAreNotAutomataException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1EmptySetOfContextsException.html">EmptySetOfContextsException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of transducer pairs is empty.  <a href="classlibhfst_1_1EmptySetOfContextsException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1EmptyStringException.html">EmptyStringException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument string is an empty string.  <a href="classlibhfst_1_1EmptyStringException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1EndOfStreamException.html">EndOfStreamException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is at end.  <a href="classlibhfst_1_1EndOfStreamException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1FlagDiacriticsAreNotIdentitiesException.html">FlagDiacriticsAreNotIdentitiesException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag diacritics encountered on one but not the other side of a transition.  <a href="classlibhfst_1_1FlagDiacriticsAreNotIdentitiesException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1FunctionNotImplementedException.html">FunctionNotImplementedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function has not been implemented (yet).  <a href="classlibhfst_1_1FunctionNotImplementedException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html">HfstBasicTransducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple transducer class with tropical weights.  <a href="classlibhfst_1_1HfstBasicTransducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransition.html">HfstBasicTransition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transition class that consists of a target state, input and output symbols and a a tropical weight.  <a href="classlibhfst_1_1HfstBasicTransition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstException.html">HfstException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for HfstExceptions.  <a href="classlibhfst_1_1HfstException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstFatalException.html">HfstFatalException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error happened probably due to a bug in the HFST code.  <a href="classlibhfst_1_1HfstFatalException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstFile.html">HfstFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for file operations.  <a href="classlibhfst_1_1HfstFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstInputStream.html">HfstInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for reading HFST binary transducers.  <a href="classlibhfst_1_1HfstInputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstOutputStream.html">HfstOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for writing binary transducers.  <a href="classlibhfst_1_1HfstOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstTokenizer.html">HfstTokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tokenizer for creating transducers from UTF-8 strings.  <a href="classlibhfst_1_1HfstTokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstTransducer.html">HfstTransducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synchronous finite-state transducer.  <a href="classlibhfst_1_1HfstTransducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstTransducerTypeMismatchException.html">HfstTransducerTypeMismatchException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two or more HfstTransducers are not of the same type.  <a href="classlibhfst_1_1HfstTransducerTypeMismatchException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1ImplementationTypeNotAvailableException.html">ImplementationTypeNotAvailableException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The library required by the implementation type requested is not linked to HFST.  <a href="classlibhfst_1_1ImplementationTypeNotAvailableException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1IncorrectUtf8CodingException.html">IncorrectUtf8CodingException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String is not valid utf-8.  <a href="classlibhfst_1_1IncorrectUtf8CodingException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1LexcCompiler.html">LexcCompiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compiler holding information contained in lexc style lexicons.  <a href="classlibhfst_1_1LexcCompiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1MetadataException.html">MetadataException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A piece of metadata in an HFST header is not supported.  <a href="classlibhfst_1_1MetadataException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1MissingOpenFstInputSymbolTableException.html">MissingOpenFstInputSymbolTableException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An OpenFst transducer does not have an input symbol table.  <a href="classlibhfst_1_1MissingOpenFstInputSymbolTableException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1MultiCharSymbolTrie.html">MultiCharSymbolTrie</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: documentation ???  <a href="classlibhfst_1_1MultiCharSymbolTrie.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1NotTransducerStreamException.html">NotTransducerStreamException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream does not contain transducers.  <a href="classlibhfst_1_1NotTransducerStreamException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1NotValidAttFormatException.html">NotValidAttFormatException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream is not in valid AT&amp;T format.  <a href="classlibhfst_1_1NotValidAttFormatException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1NotValidLexcFormatException.html">NotValidLexcFormatException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input is not in valid LexC format.  <a href="classlibhfst_1_1NotValidLexcFormatException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1NotValidPrologFormatException.html">NotValidPrologFormatException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input is not in valid prolog format.  <a href="classlibhfst_1_1NotValidPrologFormatException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1SpecifiedTypeRequiredException.html">SpecifiedTypeRequiredException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a transducer is not specified.  <a href="classlibhfst_1_1SpecifiedTypeRequiredException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1StateIndexOutOfBoundsException.html">StateIndexOutOfBoundsException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state number argument is not valid.  <a href="classlibhfst_1_1StateIndexOutOfBoundsException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1StateIsNotFinalException.html">StateIsNotFinalException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State is not final (and cannot have a final weight).  <a href="classlibhfst_1_1StateIsNotFinalException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1StreamCannotBeWrittenException.html">StreamCannotBeWrittenException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream cannot be written.  <a href="classlibhfst_1_1StreamCannotBeWrittenException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1StreamIsClosedException.html">StreamIsClosedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream is closed.  <a href="classlibhfst_1_1StreamIsClosedException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1StreamNotReadableException.html">StreamNotReadableException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream cannot be read.  <a href="classlibhfst_1_1StreamNotReadableException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1SymbolNotFoundException.html">SymbolNotFoundException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bug in the HFST code.  <a href="classlibhfst_1_1SymbolNotFoundException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1TransducerHasWrongTypeException.html">TransducerHasWrongTypeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer has wrong type.  <a href="classlibhfst_1_1TransducerHasWrongTypeException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1TransducerHeaderException.html">TransducerHeaderException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer has a malformed HFST header.  <a href="classlibhfst_1_1TransducerHeaderException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1TransducerIsCyclicException.html">TransducerIsCyclicException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducer is cyclic.  <a href="classlibhfst_1_1TransducerIsCyclicException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1TransducersAreNotAutomataException.html">TransducersAreNotAutomataException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transducers are not automata.  <a href="classlibhfst_1_1TransducersAreNotAutomataException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1TransducerTypeMismatchException.html">TransducerTypeMismatchException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two or more transducers do not have the same type.  <a href="classlibhfst_1_1TransducerTypeMismatchException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1XreCompiler.html">XreCompiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compiler holding information needed to compile XREs.  <a href="classlibhfst_1_1XreCompiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a853cf5f12d54ef93ac3b7e271e29fdb1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a853cf5f12d54ef93ac3b7e271e29fdb1">coercion</a></td></tr>
<tr class="memdesc:a853cf5f12d54ef93ac3b7e271e29fdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that requires that one of the mappings defined by <em>mapping</em> must occur in each context in <em>contexts</em>.  <a href="#a853cf5f12d54ef93ac3b7e271e29fdb1">More...</a><br /></td></tr>
<tr class="separator:a853cf5f12d54ef93ac3b7e271e29fdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c209bc11d17149a612827815a05044"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a58c209bc11d17149a612827815a05044">compile_lexc_file</a></td></tr>
<tr class="memdesc:a58c209bc11d17149a612827815a05044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile lexc file <em>filename</em> into a transducer.  <a href="#a58c209bc11d17149a612827815a05044">More...</a><br /></td></tr>
<tr class="separator:a58c209bc11d17149a612827815a05044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c46c61a5ed6ee5fa5fa942e620fcb81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a6c46c61a5ed6ee5fa5fa942e620fcb81">compile_xfst_file</a></td></tr>
<tr class="memdesc:a6c46c61a5ed6ee5fa5fa942e620fcb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile (is 'run' a better term?) xfst file <em>filename</em>.  <a href="#a6c46c61a5ed6ee5fa5fa942e620fcb81">More...</a><br /></td></tr>
<tr class="separator:a6c46c61a5ed6ee5fa5fa942e620fcb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caa30528ec0fd102f20fc5ead3410c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a8caa30528ec0fd102f20fc5ead3410c3">deep_coercion</a></td></tr>
<tr class="memdesc:a8caa30528ec0fd102f20fc5ead3410c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that specifies that a string from the output language of the transducer <em>mapping</em> always has to be mapped to one of its input strings (according to transducer <em>mappings</em>) if it appears in any of the contexts in <em>contexts</em>.  <a href="#a8caa30528ec0fd102f20fc5ead3410c3">More...</a><br /></td></tr>
<tr class="separator:a8caa30528ec0fd102f20fc5ead3410c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88157941b6b13ddcc5abee514758af63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a88157941b6b13ddcc5abee514758af63">deep_restriction</a></td></tr>
<tr class="memdesc:a88157941b6b13ddcc5abee514758af63"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that specifies that a string from the output language of the transducer <em>mapping</em> may only be mapped to one of its input strings (according to transducer <em>mappings</em>) if it appears in any of the contexts in <em>contexts.Symbols</em> outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>.  <a href="#a88157941b6b13ddcc5abee514758af63">More...</a><br /></td></tr>
<tr class="separator:a88157941b6b13ddcc5abee514758af63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e16512ef5f3fdcd95cb124b27a74443"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a3e16512ef5f3fdcd95cb124b27a74443">deep_restriction_and_coercion</a></td></tr>
<tr class="memdesc:a3e16512ef5f3fdcd95cb124b27a74443"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that is equivalent to the intersection of deep_restriction and deep_coercion.  <a href="#a3e16512ef5f3fdcd95cb124b27a74443">More...</a><br /></td></tr>
<tr class="separator:a3e16512ef5f3fdcd95cb124b27a74443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4380dd1a61159dba3762591d8c9c728d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a4380dd1a61159dba3762591d8c9c728d">empty_fst</a></td></tr>
<tr class="memdesc:a4380dd1a61159dba3762591d8c9c728d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an empty transducer.  <a href="#a4380dd1a61159dba3762591d8c9c728d">More...</a><br /></td></tr>
<tr class="separator:a4380dd1a61159dba3762591d8c9c728d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87c140df8c1d868f1c185ca12bc5fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a2f87c140df8c1d868f1c185ca12bc5fc">epsilon_fst</a></td></tr>
<tr class="memdesc:a2f87c140df8c1d868f1c185ca12bc5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an epsilon transducer.  <a href="#a2f87c140df8c1d868f1c185ca12bc5fc">More...</a><br /></td></tr>
<tr class="separator:a2f87c140df8c1d868f1c185ca12bc5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78302bf5a1722d116ce224b72c94ecea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a78302bf5a1722d116ce224b72c94ecea">fst</a></td></tr>
<tr class="memdesc:a78302bf5a1722d116ce224b72c94ecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer that recognizes one or more paths.  <a href="#a78302bf5a1722d116ce224b72c94ecea">More...</a><br /></td></tr>
<tr class="separator:a78302bf5a1722d116ce224b72c94ecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0244a81282da35362407f228ca3f3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#aab0244a81282da35362407f228ca3f3c">fst_type_to_string</a></td></tr>
<tr class="memdesc:aab0244a81282da35362407f228ca3f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of transducer implementation type <em>type</em>.  <a href="#aab0244a81282da35362407f228ca3f3c">More...</a><br /></td></tr>
<tr class="separator:aab0244a81282da35362407f228ca3f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcafeb1242676bb61f894ede83b114bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#adcafeb1242676bb61f894ede83b114bb">get_default_fst_type</a></td></tr>
<tr class="memdesc:adcafeb1242676bb61f894ede83b114bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default transducer implementation type.  <a href="#adcafeb1242676bb61f894ede83b114bb">More...</a><br /></td></tr>
<tr class="separator:adcafeb1242676bb61f894ede83b114bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eef5db4554deffab701c7bec5909e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ab3eef5db4554deffab701c7bec5909e2">hfst_open</a></td></tr>
<tr class="memdesc:ab3eef5db4554deffab701c7bec5909e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open file named <em>filename</em> in mode <em>mode</em>.  <a href="#ab3eef5db4554deffab701c7bec5909e2">More...</a><br /></td></tr>
<tr class="separator:ab3eef5db4554deffab701c7bec5909e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1c1a95d5a828cb964614d14a1a8603"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a0a1c1a95d5a828cb964614d14a1a8603">hfst_stderr</a></td></tr>
<tr class="memdesc:a0a1c1a95d5a828cb964614d14a1a8603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file that points to standard error stream.  <a href="#a0a1c1a95d5a828cb964614d14a1a8603">More...</a><br /></td></tr>
<tr class="separator:a0a1c1a95d5a828cb964614d14a1a8603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4076988f003540ead42f52a0deac6cf5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a4076988f003540ead42f52a0deac6cf5">hfst_stdin</a></td></tr>
<tr class="memdesc:a4076988f003540ead42f52a0deac6cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file that points to standard input.  <a href="#a4076988f003540ead42f52a0deac6cf5">More...</a><br /></td></tr>
<tr class="separator:a4076988f003540ead42f52a0deac6cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6009c66c9a8cdf41e87c02b4aea9c44"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ae6009c66c9a8cdf41e87c02b4aea9c44">hfst_stdout</a></td></tr>
<tr class="memdesc:ae6009c66c9a8cdf41e87c02b4aea9c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file that points to standard output.  <a href="#ae6009c66c9a8cdf41e87c02b4aea9c44">More...</a><br /></td></tr>
<tr class="separator:ae6009c66c9a8cdf41e87c02b4aea9c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fa4194421aa722564c561bd36e513d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a90fa4194421aa722564c561bd36e513d">is_diacritic</a></td></tr>
<tr class="memdesc:a90fa4194421aa722564c561bd36e513d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether symbol <em>symbol</em> is a flag diacritic.  <a href="#a90fa4194421aa722564c561bd36e513d">More...</a><br /></td></tr>
<tr class="separator:a90fa4194421aa722564c561bd36e513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4f2f59d529db2c2e5adff5848c1aaa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#aab4f2f59d529db2c2e5adff5848c1aaa">left_replace_down</a></td></tr>
<tr class="memdesc:aab4f2f59d529db2c2e5adff5848c1aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion of the replace_up and the result needs to be composed on the upper side of the input language.  <a href="#aab4f2f59d529db2c2e5adff5848c1aaa">More...</a><br /></td></tr>
<tr class="separator:aab4f2f59d529db2c2e5adff5848c1aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0464fed91b87b0e676f522647234d12"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ad0464fed91b87b0e676f522647234d12">left_replace_down_karttunen</a></td></tr>
<tr class="memdesc:ad0464fed91b87b0e676f522647234d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion of the replace_up and the result needs to be composed on the upper side of the input language.  <a href="#ad0464fed91b87b0e676f522647234d12">More...</a><br /></td></tr>
<tr class="separator:ad0464fed91b87b0e676f522647234d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c3368e85242df3041c070d2c9d64ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a99c3368e85242df3041c070d2c9d64ab">left_replace_left</a></td></tr>
<tr class="memdesc:a99c3368e85242df3041c070d2c9d64ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion of the replace_up and the result needs to be composed on the upper side of the input language.  <a href="#a99c3368e85242df3041c070d2c9d64ab">More...</a><br /></td></tr>
<tr class="separator:a99c3368e85242df3041c070d2c9d64ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0c563db323783e731a48ce26e5bc5c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a7c0c563db323783e731a48ce26e5bc5c">left_replace_right</a></td></tr>
<tr class="memdesc:a7c0c563db323783e731a48ce26e5bc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion of the replace_up and the result needs to be composed on the upper side of the input language.  <a href="#a7c0c563db323783e731a48ce26e5bc5c">More...</a><br /></td></tr>
<tr class="separator:a7c0c563db323783e731a48ce26e5bc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5663ae95349bcc58f9b0bf45c6697a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ae5663ae95349bcc58f9b0bf45c6697a8">left_replace_up</a></td></tr>
<tr class="memdesc:ae5663ae95349bcc58f9b0bf45c6697a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion of the replace_up and the result needs to be composed on the upper side of the input language.  <a href="#ae5663ae95349bcc58f9b0bf45c6697a8">More...</a><br /></td></tr>
<tr class="separator:ae5663ae95349bcc58f9b0bf45c6697a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5663ae95349bcc58f9b0bf45c6697a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ae5663ae95349bcc58f9b0bf45c6697a8">left_replace_up</a></td></tr>
<tr class="memdesc:ae5663ae95349bcc58f9b0bf45c6697a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion of the replace_up and the result needs to be composed on the upper side of the input language.  <a href="#ae5663ae95349bcc58f9b0bf45c6697a8">More...</a><br /></td></tr>
<tr class="separator:ae5663ae95349bcc58f9b0bf45c6697a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae995d84f919df6a6036c33a00a592aa4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ae995d84f919df6a6036c33a00a592aa4">read_att</a></td></tr>
<tr class="memdesc:ae995d84f919df6a6036c33a00a592aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next transducer from AT&amp;T file pointed by <em>f</em>.  <a href="#ae995d84f919df6a6036c33a00a592aa4">More...</a><br /></td></tr>
<tr class="separator:ae995d84f919df6a6036c33a00a592aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc3944e5de202789cfe39d5e2470978"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a5bc3944e5de202789cfe39d5e2470978">read_att_input</a></td></tr>
<tr class="memdesc:a5bc3944e5de202789cfe39d5e2470978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read AT&amp;T input from the user and return a transducer.  <a href="#a5bc3944e5de202789cfe39d5e2470978">More...</a><br /></td></tr>
<tr class="separator:a5bc3944e5de202789cfe39d5e2470978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9de1d6d117758cc4c4d21d6f9e5b67"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#aeb9de1d6d117758cc4c4d21d6f9e5b67">read_att_string</a></td></tr>
<tr class="memdesc:aeb9de1d6d117758cc4c4d21d6f9e5b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a multiline string <em>att</em> and return a transducer.  <a href="#aeb9de1d6d117758cc4c4d21d6f9e5b67">More...</a><br /></td></tr>
<tr class="separator:aeb9de1d6d117758cc4c4d21d6f9e5b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9194004fd5bf766fad03bff5d514c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#abe9194004fd5bf766fad03bff5d514c7">read_prolog</a></td></tr>
<tr class="memdesc:abe9194004fd5bf766fad03bff5d514c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next transducer from prolog file pointed by <em>f</em>.  <a href="#abe9194004fd5bf766fad03bff5d514c7">More...</a><br /></td></tr>
<tr class="separator:abe9194004fd5bf766fad03bff5d514c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2611f16a0c0596d4564ce42149a8ba86"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a2611f16a0c0596d4564ce42149a8ba86">regex</a></td></tr>
<tr class="memdesc:a2611f16a0c0596d4564ce42149a8ba86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer as defined by regular expression <em>regexp</em>.  <a href="#a2611f16a0c0596d4564ce42149a8ba86">More...</a><br /></td></tr>
<tr class="separator:a2611f16a0c0596d4564ce42149a8ba86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa455234e8a70e7151526756e6ab4fdfe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#aa455234e8a70e7151526756e6ab4fdfe">replace_down</a></td></tr>
<tr class="memdesc:aa455234e8a70e7151526756e6ab4fdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as replace_up, but matching is done on the output side of <em>mapping</em>.  <a href="#aa455234e8a70e7151526756e6ab4fdfe">More...</a><br /></td></tr>
<tr class="separator:aa455234e8a70e7151526756e6ab4fdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa455234e8a70e7151526756e6ab4fdfe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#aa455234e8a70e7151526756e6ab4fdfe">replace_down</a></td></tr>
<tr class="memdesc:aa455234e8a70e7151526756e6ab4fdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as replace_down(context, mapping, optional, alphabet) but <em>mapping</em> is performed in every context.  <a href="#aa455234e8a70e7151526756e6ab4fdfe">More...</a><br /></td></tr>
<tr class="separator:aa455234e8a70e7151526756e6ab4fdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad1dae4c2ecb900fe9bb02fd8591f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a08ad1dae4c2ecb900fe9bb02fd8591f9">replace_down_karttunen</a></td></tr>
<tr class="memdesc:a08ad1dae4c2ecb900fe9bb02fd8591f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: document.  <a href="#a08ad1dae4c2ecb900fe9bb02fd8591f9">More...</a><br /></td></tr>
<tr class="separator:a08ad1dae4c2ecb900fe9bb02fd8591f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f76f5e1f0dfb45d9ef6d7b772b2cb14"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a9f76f5e1f0dfb45d9ef6d7b772b2cb14">replace_left</a></td></tr>
<tr class="memdesc:a9f76f5e1f0dfb45d9ef6d7b772b2cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as replace_up, but left context matching is done on the output side of <em>mapping</em> and right context on the input side of <em>mapping</em>.  <a href="#a9f76f5e1f0dfb45d9ef6d7b772b2cb14">More...</a><br /></td></tr>
<tr class="separator:a9f76f5e1f0dfb45d9ef6d7b772b2cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b40fcff89000fb8fc62164d6a1a7e5d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a2b40fcff89000fb8fc62164d6a1a7e5d">replace_right</a></td></tr>
<tr class="memdesc:a2b40fcff89000fb8fc62164d6a1a7e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as replace_up, but left context matching is done on the input side of <em>mapping</em> and right context on the output side of <em>mapping</em>.  <a href="#a2b40fcff89000fb8fc62164d6a1a7e5d">More...</a><br /></td></tr>
<tr class="separator:a2b40fcff89000fb8fc62164d6a1a7e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b018b846e6f0b69096bb5f535c793"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793">replace_up</a></td></tr>
<tr class="memdesc:a9c9b018b846e6f0b69096bb5f535c793"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that performs an upward mapping <em>mapping</em> in the context <em>context</em> when the alphabet is <em>alphabet</em>.  <a href="#a9c9b018b846e6f0b69096bb5f535c793">More...</a><br /></td></tr>
<tr class="separator:a9c9b018b846e6f0b69096bb5f535c793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b018b846e6f0b69096bb5f535c793"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793">replace_up</a></td></tr>
<tr class="memdesc:a9c9b018b846e6f0b69096bb5f535c793"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as replace_up but <em>mapping</em> is performed in every context.  <a href="#a9c9b018b846e6f0b69096bb5f535c793">More...</a><br /></td></tr>
<tr class="separator:a9c9b018b846e6f0b69096bb5f535c793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751d3a94f77a122c9f31a6eabfc400fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a751d3a94f77a122c9f31a6eabfc400fe">restriction</a></td></tr>
<tr class="memdesc:a751d3a94f77a122c9f31a6eabfc400fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that allows any (substring) mapping defined by <em>mapping</em> only if it occurs in any of the contexts in <em>contexts</em>.  <a href="#a751d3a94f77a122c9f31a6eabfc400fe">More...</a><br /></td></tr>
<tr class="separator:a751d3a94f77a122c9f31a6eabfc400fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9717cd081ddb74e50cfae8bc7c0672"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#acb9717cd081ddb74e50cfae8bc7c0672">restriction_and_coercion</a></td></tr>
<tr class="memdesc:acb9717cd081ddb74e50cfae8bc7c0672"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that is equivalent to the intersection of restriction and coercion and requires that the mappings defined by <em>mapping</em> occur always and only in the given contexts in <em>contexts</em>.  <a href="#acb9717cd081ddb74e50cfae8bc7c0672">More...</a><br /></td></tr>
<tr class="separator:acb9717cd081ddb74e50cfae8bc7c0672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04738a25a7f365c52e3f0d5fc349540"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ab04738a25a7f365c52e3f0d5fc349540">set_default_fst_type</a></td></tr>
<tr class="memdesc:ab04738a25a7f365c52e3f0d5fc349540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default implementation type.  <a href="#ab04738a25a7f365c52e3f0d5fc349540">More...</a><br /></td></tr>
<tr class="separator:ab04738a25a7f365c52e3f0d5fc349540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94239c39b494741335e67e87a6a26d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#aa94239c39b494741335e67e87a6a26d5">start_xfst</a></td></tr>
<tr class="memdesc:aa94239c39b494741335e67e87a6a26d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start interactive xfst compiler.  <a href="#aa94239c39b494741335e67e87a6a26d5">More...</a><br /></td></tr>
<tr class="separator:aa94239c39b494741335e67e87a6a26d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea87edf0efe033127951a90ad80d5f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a1ea87edf0efe033127951a90ad80d5f7">surface_coercion</a></td></tr>
<tr class="memdesc:a1ea87edf0efe033127951a90ad80d5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that specifies that a string from the input language of the transducer <em>mapping</em> always has to the mapped to one of its output strings according to transducer <em>mapping</em> if it appears in any of the contexts in <em>contexts</em>.  <a href="#a1ea87edf0efe033127951a90ad80d5f7">More...</a><br /></td></tr>
<tr class="separator:a1ea87edf0efe033127951a90ad80d5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70eac5732a65f64cadefecd270297245"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a70eac5732a65f64cadefecd270297245">surface_restriction</a></td></tr>
<tr class="memdesc:a70eac5732a65f64cadefecd270297245"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that specifies that a string from the input language of the transducer <em>mapping</em> may only be mapped to one of its output strings (according to transducer <em>mapping</em>) if it appears in any of the contexts in <em>contexts</em>.  <a href="#a70eac5732a65f64cadefecd270297245">More...</a><br /></td></tr>
<tr class="separator:a70eac5732a65f64cadefecd270297245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d38641034afae198bc874582faf0f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a0d6d38641034afae198bc874582faf0f">surface_restriction_and_coercion</a></td></tr>
<tr class="memdesc:a0d6d38641034afae198bc874582faf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that is equivalent to the intersection of surface_restriction and surface_coercion.  <a href="#a0d6d38641034afae198bc874582faf0f">More...</a><br /></td></tr>
<tr class="separator:a0d6d38641034afae198bc874582faf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6740017cb0d7dad55d88369962a12f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ad6740017cb0d7dad55d88369962a12f4">tokenized_fst</a></td></tr>
<tr class="memdesc:ad6740017cb0d7dad55d88369962a12f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer that recognizes the concatenation of symbols or symbol pairs in <em>arg</em>.  <a href="#ad6740017cb0d7dad55d88369962a12f4">More...</a><br /></td></tr>
<tr class="separator:ad6740017cb0d7dad55d88369962a12f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4047a800751231b74cd3e0152821a82a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a4047a800751231b74cd3e0152821a82a">two_level_if</a></td></tr>
<tr class="memdesc:a4047a800751231b74cd3e0152821a82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that obligatorily performs the mappings defined by <em>mappings</em> in the context <em>context</em> when the alphabet is <em>alphabet</em>.  <a href="#a4047a800751231b74cd3e0152821a82a">More...</a><br /></td></tr>
<tr class="separator:a4047a800751231b74cd3e0152821a82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1016b8e736f52d689ff1c45caf4b884e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a1016b8e736f52d689ff1c45caf4b884e">two_level_if_and_only_if</a></td></tr>
<tr class="memdesc:a1016b8e736f52d689ff1c45caf4b884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that always performs the mappings defined by <em>mappings</em> in the context <em>context</em> and only in that context, when the alphabet is <em>alphabet</em>.  <a href="#a1016b8e736f52d689ff1c45caf4b884e">More...</a><br /></td></tr>
<tr class="separator:a1016b8e736f52d689ff1c45caf4b884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185c753cfd56c6cbff737be417c02c74"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a185c753cfd56c6cbff737be417c02c74">two_level_only_if</a></td></tr>
<tr class="memdesc:a185c753cfd56c6cbff737be417c02c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transducer that allows the mappings defined by <em>mappings</em> only in the context <em>context</em>, when the alphabet is <em>alphabet</em>.  <a href="#a185c753cfd56c6cbff737be417c02c74">More...</a><br /></td></tr>
<tr class="separator:a185c753cfd56c6cbff737be417c02c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2">EPSILON</a> = '@_EPSILON_SYMBOL_@'</td></tr>
<tr class="memdesc:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for epsilon symbol.  <a href="#a9c72aae3ca2a5e4c25a95cefe40704a2">More...</a><br /></td></tr>
<tr class="separator:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08bb67be4b97cae8b7d5bf3b66fb688"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ac08bb67be4b97cae8b7d5bf3b66fb688">ERROR_TYPE</a> = _libhfst.ERROR_TYPE</td></tr>
<tr class="memdesc:ac08bb67be4b97cae8b7d5bf3b66fb688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type not recognised.  <a href="#ac08bb67be4b97cae8b7d5bf3b66fb688">More...</a><br /></td></tr>
<tr class="separator:ac08bb67be4b97cae8b7d5bf3b66fb688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d227efc26ac837490b58ef9693b1c8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a6d227efc26ac837490b58ef9693b1c8d">FOMA_TYPE</a> = _libhfst.FOMA_TYPE</td></tr>
<tr class="memdesc:a6d227efc26ac837490b58ef9693b1c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A foma transducer, unweighted.  <a href="#a6d227efc26ac837490b58ef9693b1c8d">More...</a><br /></td></tr>
<tr class="separator:a6d227efc26ac837490b58ef9693b1c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279af64d112476e38ebf1498d6d6f057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a279af64d112476e38ebf1498d6d6f057">HFST2_TYPE</a> = _libhfst.HFST2_TYPE</td></tr>
<tr class="memdesc:a279af64d112476e38ebf1498d6d6f057"><td class="mdescLeft">&#160;</td><td class="mdescRight">HFST2 header present, conversion required.  <a href="#a279af64d112476e38ebf1498d6d6f057">More...</a><br /></td></tr>
<tr class="separator:a279af64d112476e38ebf1498d6d6f057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44467f3dabfb1b5a6cf6011ad63dcadb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a44467f3dabfb1b5a6cf6011ad63dcadb">HFST_OL_TYPE</a> = _libhfst.HFST_OL_TYPE</td></tr>
<tr class="memdesc:a44467f3dabfb1b5a6cf6011ad63dcadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">An HFST optimized lookup transducer, unweighted.  <a href="#a44467f3dabfb1b5a6cf6011ad63dcadb">More...</a><br /></td></tr>
<tr class="separator:a44467f3dabfb1b5a6cf6011ad63dcadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac483b6adfb12973c57d1ba8df1cb9e78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ac483b6adfb12973c57d1ba8df1cb9e78">HFST_OLW_TYPE</a> = _libhfst.HFST_OLW_TYPE</td></tr>
<tr class="memdesc:ac483b6adfb12973c57d1ba8df1cb9e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">An HFST optimized lookup transducer with weights.  <a href="#ac483b6adfb12973c57d1ba8df1cb9e78">More...</a><br /></td></tr>
<tr class="separator:ac483b6adfb12973c57d1ba8df1cb9e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b257e90982f934e0237c0bf2671a54b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a3b257e90982f934e0237c0bf2671a54b">IDENTITY</a> = '@_IDENTITY_SYMBOL_@'</td></tr>
<tr class="memdesc:a3b257e90982f934e0237c0bf2671a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for identity symbol.  <a href="#a3b257e90982f934e0237c0bf2671a54b">More...</a><br /></td></tr>
<tr class="separator:a3b257e90982f934e0237c0bf2671a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b38b4422b600ee9b8b6a6e27870102"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#ac6b38b4422b600ee9b8b6a6e27870102">LOG_OPENFST_TYPE</a> = _libhfst.LOG_OPENFST_TYPE</td></tr>
<tr class="memdesc:ac6b38b4422b600ee9b8b6a6e27870102"><td class="mdescLeft">&#160;</td><td class="mdescRight">An OpenFst transducer with logarithmic weights (limited support).  <a href="#ac6b38b4422b600ee9b8b6a6e27870102">More...</a><br /></td></tr>
<tr class="separator:ac6b38b4422b600ee9b8b6a6e27870102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aecd8e6f69ad8017031d652a34854f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#af8aecd8e6f69ad8017031d652a34854f">SFST_TYPE</a> = _libhfst.SFST_TYPE</td></tr>
<tr class="memdesc:af8aecd8e6f69ad8017031d652a34854f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An SFST transducer, unweighted.  <a href="#af8aecd8e6f69ad8017031d652a34854f">More...</a><br /></td></tr>
<tr class="separator:af8aecd8e6f69ad8017031d652a34854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eede2dfd24b0ba24e5373dacbb209d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a44eede2dfd24b0ba24e5373dacbb209d">TO_FINAL_STATE</a> = _libhfst.TO_FINAL_STATE</td></tr>
<tr class="memdesc:a44eede2dfd24b0ba24e5373dacbb209d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push weights toward final state(s).  <a href="#a44eede2dfd24b0ba24e5373dacbb209d">More...</a><br /></td></tr>
<tr class="separator:a44eede2dfd24b0ba24e5373dacbb209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373a5ad282702de1dea17a2c8add2f08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a373a5ad282702de1dea17a2c8add2f08">TO_INITIAL_STATE</a> = _libhfst.TO_INITIAL_STATE</td></tr>
<tr class="memdesc:a373a5ad282702de1dea17a2c8add2f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push weights toward initial state.  <a href="#a373a5ad282702de1dea17a2c8add2f08">More...</a><br /></td></tr>
<tr class="separator:a373a5ad282702de1dea17a2c8add2f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0d4616ee4e5a966d6e336035721b20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a7d0d4616ee4e5a966d6e336035721b20">TROPICAL_OPENFST_TYPE</a> = _libhfst.TROPICAL_OPENFST_TYPE</td></tr>
<tr class="memdesc:a7d0d4616ee4e5a966d6e336035721b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">An OpenFst transducer with tropical weights.  <a href="#a7d0d4616ee4e5a966d6e336035721b20">More...</a><br /></td></tr>
<tr class="separator:a7d0d4616ee4e5a966d6e336035721b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bd2ecc765c9934d3f6396d30ace19f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a51bd2ecc765c9934d3f6396d30ace19f">UNKNOWN</a> = '@_UNKNOWN_SYMBOL_@'</td></tr>
<tr class="memdesc:a51bd2ecc765c9934d3f6396d30ace19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for unknown symbol.  <a href="#a51bd2ecc765c9934d3f6396d30ace19f">More...</a><br /></td></tr>
<tr class="separator:a51bd2ecc765c9934d3f6396d30ace19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2585ee316086d7a58aee00492055a24a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibhfst.html#a2585ee316086d7a58aee00492055a24a">UNSPECIFIED_TYPE</a> = _libhfst.UNSPECIFIED_TYPE</td></tr>
<tr class="memdesc:a2585ee316086d7a58aee00492055a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format left open by e.g.  <a href="#a2585ee316086d7a58aee00492055a24a">More...</a><br /></td></tr>
<tr class="separator:a2585ee316086d7a58aee00492055a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>HFST API for Python3. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a853cf5f12d54ef93ac3b7e271e29fdb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.coercion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that requires that one of the mappings defined by <em>mapping</em> must occur in each context in <em>contexts</em>. </p>
<p>Symbols outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58c209bc11d17149a612827815a05044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.compile_lexc_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kvargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile lexc file <em>filename</em> into a transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the lexc file. </td></tr>
    <tr><td class="paramname">kvargs</td><td>Arguments recognized are: verbosity, with_flags, output. </td></tr>
    <tr><td class="paramname">verbosity</td><td>The verbosity of the compiler, defaults to 0 (silent). Possible values are: 0, 1, 2. </td></tr>
    <tr><td class="paramname">with_flags</td><td>Whether lexc flags are used when compiling, defaults to False. </td></tr>
    <tr><td class="paramname">output</td><td>Where output is printed. Possible values are sys.stdout, sys.stderr, a StringIO, sys.stderr being the default? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c46c61a5ed6ee5fa5fa942e620fcb81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.compile_xfst_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kvargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile (is 'run' a better term?) xfst file <em>filename</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the xfst file. </td></tr>
    <tr><td class="paramname">kvargs</td><td>Arguments recognized are: verbosity, quit_on_fail, output, type. </td></tr>
    <tr><td class="paramname">verbosity</td><td>The verbosity of the compiler, defaults to 0 (silent). Possible values are: 0, 1, 2. </td></tr>
    <tr><td class="paramname">quit_on_fail</td><td>Whether the script is exited on any error, defaults to True. </td></tr>
    <tr><td class="paramname">output</td><td>Where output is printed. Possible values are sys.stdout, sys.stderr, a StringIO, sys.stderr being the default? </td></tr>
    <tr><td class="paramname">type</td><td>Implementation type of the compiler, defaults to <a class="el" href="namespacelibhfst.html#adcafeb1242676bb61f894ede83b114bb" title="Get default transducer implementation type. ">libhfst.get_default_fst_type()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8caa30528ec0fd102f20fc5ead3410c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.deep_coercion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that specifies that a string from the output language of the transducer <em>mapping</em> always has to be mapped to one of its input strings (according to transducer <em>mappings</em>) if it appears in any of the contexts in <em>contexts</em>. </p>
<p>Symbols outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88157941b6b13ddcc5abee514758af63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.deep_restriction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that specifies that a string from the output language of the transducer <em>mapping</em> may only be mapped to one of its input strings (according to transducer <em>mappings</em>) if it appears in any of the contexts in <em>contexts.Symbols</em> outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e16512ef5f3fdcd95cb124b27a74443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.deep_restriction_and_coercion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that is equivalent to the intersection of deep_restriction and deep_coercion. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a88157941b6b13ddcc5abee514758af63" title="A transducer that specifies that a string from the output language of the transducer mapping may only...">deep_restriction</a> <a class="el" href="namespacelibhfst.html#a8caa30528ec0fd102f20fc5ead3410c3" title="A transducer that specifies that a string from the output language of the transducer mapping always h...">deep_coercion</a> <a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4380dd1a61159dba3762591d8c9c728d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.empty_fst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an empty transducer. </p>
<p>Empty transducer has one state that is not final, i.e. it does not recognize any string. </p>

</div>
</div>
<a class="anchor" id="a2f87c140df8c1d868f1c185ca12bc5fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.epsilon_fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an epsilon transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>The weight of the final state. Epsilon transducer has one state that is final (with final weight <em>weight</em>), i.e. it recognizes the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78302bf5a1722d116ce224b72c94ecea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer that recognizes one or more paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>See example below</td></tr>
  </table>
  </dd>
</dl>
<p>Possible inputs: </p><pre class="fragment"> One unweighted identity path:
 'foo'  -&gt;  [f o o]
 Weighted path: a tuple of string and number, e.g. 
 ('foo',1.4)
 ('bar',-3)
 ('baz',0)
 Several paths: a list or a tuple of paths and/or weighted paths, e.g.
 ['foo', 'bar']
 ('foo', ('bar',5.0))
 ('foo', ('bar',5.0), 'baz', 'Foo', ('Bar',2.4))
 [('foo',-1), ('bar',0), ('baz',3.5)]
 A dictionary mapping strings to any of the above cases:
 {'foo':'foo', 'bar':('foo',1.4), 'baz':(('foo',-1),'BAZ')}</pre> 
</div>
</div>
<a class="anchor" id="aab0244a81282da35362407f228ca3f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.fst_type_to_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string representation of transducer implementation type <em>type</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>An libhfst.ImplementationType. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcafeb1242676bb61f894ede83b114bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.get_default_fst_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default transducer implementation type. </p>
<p>If the default type is not set, it defaults to <a class="el" href="namespacelibhfst.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">libhfst.TROPICAL_OPENFST_TYPE</a> </p>

</div>
</div>
<a class="anchor" id="ab3eef5db4554deffab701c7bec5909e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.hfst_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open file named <em>filename</em> in mode <em>mode</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file. </td></tr>
    <tr><td class="paramname">mode</td><td>Mode in which the file is opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a1c1a95d5a828cb964614d14a1a8603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.hfst_stderr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file that points to standard error stream. </p>

</div>
</div>
<a class="anchor" id="a4076988f003540ead42f52a0deac6cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.hfst_stdin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file that points to standard input. </p>

</div>
</div>
<a class="anchor" id="ae6009c66c9a8cdf41e87c02b4aea9c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.hfst_stdout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file that points to standard output. </p>

</div>
</div>
<a class="anchor" id="a90fa4194421aa722564c561bd36e513d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.is_diacritic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether symbol <em>symbol</em> is a flag diacritic. </p>
<p>Flag diacritics are of the form </p><pre class="fragment"> @[PNDRCU][.][A-Z]+([.][A-Z]+)?@</pre> 
</div>
</div>
<a class="anchor" id="aab4f2f59d529db2c2e5adff5848c1aaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.left_replace_down </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion of the replace_up and the result needs to be composed on the upper side of the input language. </p>
<p>However, matching is done on the output side of <em>mapping</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad0464fed91b87b0e676f522647234d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.left_replace_down_karttunen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion of the replace_up and the result needs to be composed on the upper side of the input language. </p>
<p>However, matching is done on the output side of <em>mapping</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99c3368e85242df3041c070d2c9d64ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.left_replace_left </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion of the replace_up and the result needs to be composed on the upper side of the input language. </p>
<p>However, left context matching is done on the input side of <em>mapping</em> and right context on the output side of <em>mapping</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> */ </dd></dl>

</div>
</div>
<a class="anchor" id="a7c0c563db323783e731a48ce26e5bc5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.left_replace_right </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion of the replace_up and the result needs to be composed on the upper side of the input language. </p>
<p>However, left context matching is done on the output side of <em>mapping</em> and right context on the input side of <em>mapping</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5663ae95349bcc58f9b0bf45c6697a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.left_replace_up </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion of the replace_up and the result needs to be composed on the upper side of the input language. </p>
<p>B &lt;- A is the inversion of A -&gt; B. <em>mapping</em> is performed in every context. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5663ae95349bcc58f9b0bf45c6697a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.left_replace_up </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversion of the replace_up and the result needs to be composed on the upper side of the input language. </p>
<p>B &lt;- A is the inversion of A -&gt; B. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae995d84f919df6a6036c33a00a592aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.read_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>epsilonstr</em> = <code><a class="el" href="namespacelibhfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2">libhfst.EPSILON</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next transducer from AT&amp;T file pointed by <em>f</em>. </p>
<p><em>epsilonstr</em> defines the symbol used for epsilon in the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A file pointer (<a class="el" href="classlibhfst_1_1HfstFile.html" title="A wrapper class for file operations. ">libhfst.HfstFile</a>) to the file. </td></tr>
    <tr><td class="paramname">epsilonstr</td><td>How epsilon is represented in the file. By default, "@_EPSILON_SYMBOL_@" and "@0@" are both recognized.</td></tr>
  </table>
  </dd>
</dl>
<p>If the file contains several transducers, they must be separated by "--" lines. In AT&amp;T format, the transition lines are of the form:</p>
<pre class="fragment"> [0-9]+[\w]+[0-9]+[\w]+[^\w]+[\w]+[^\w]([\w]+(-)[0-9]+(\.[0-9]+)) </pre><p>and final state lines:</p>
<pre class="fragment"> [0-9]+[\w]+([\w]+(-)[0-9]+(\.[0-9]+))</pre><p>If several transducers are listed in the same file, they are separated by lines of two consecutive hyphens "--". If the weight </p><pre class="fragment"> ([\w]+(-)[0-9]+(\.[0-9]+))</pre><p> is missing, the transition or final state is given a zero weight.</p>
<p>NOTE: If transition symbols contains spaces, they must be escaped as '@_SPACE_@' because spaces are used as field separators. Both '@0@' and '@_EPSILON_SYMBOL_@' are always interpreted as epsilons.</p>
<p>An example: </p><pre class="fragment"> 0      1      foo      bar      0.3
 1      0.5
 --
 0      0.0
 --
 --
 0      0.0
 0      0      a        &lt;eps&gt;    0.2</pre><p>The example lists four transducers in AT&amp;T format: one transducer accepting the string pair &lt;'foo','bar'&gt;, one epsilon transducer, one empty transducer and one transducer that accepts any number of 'a's and produces an empty string in all cases. The transducers can be read with the following commands (from a file named 'testfile.att'): </p><pre class="fragment"> transducers = []
 ifile = libhfst.hfst_open('testfile2.att', 'r')
 try:
     while (not ifile.is_eof()):
         t = libhfst.read_att(ifile, '&lt;eps&gt;')
         transducers.append(t)
         print("read one transducer")
 except libhfst.NotValidAttFormatException:
     print("Error reading transducer: not valid AT&amp;T format.")
 ifile.close()
 print("Read %i transducers in total" % len(transducers))</pre><p>Epsilon will be represented as <a class="el" href="namespacelibhfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2" title="The string for epsilon symbol. ">libhfst.EPSILON</a> in the resulting transducer. The argument <em>epsilon_symbol</em> only denotes how epsilons are represented in <em>ifile</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibhfst_1_1NotValidAttFormatException.html" title="The stream is not in valid AT&T format. ">NotValidAttFormatException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classlibhfst_1_1StreamNotReadableException.html" title="Stream cannot be read. ">StreamNotReadableException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classlibhfst_1_1StreamIsClosedException.html" title="Stream is closed. ">StreamIsClosedException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classlibhfst_1_1EndOfStreamException.html" title="The stream is at end. ">EndOfStreamException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>#write_att </dd></dl>

</div>
</div>
<a class="anchor" id="a5bc3944e5de202789cfe39d5e2470978"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.read_att_input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read AT&amp;T input from the user and return a transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> whose type is <a class="el" href="namespacelibhfst.html#adcafeb1242676bb61f894ede83b114bb" title="Get default transducer implementation type. ">libhfst.get_default_fst_type()</a>. Read one AT&amp;T line at a time from standard input and create an equivalent transducer. An empty line signals the end of input. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb9de1d6d117758cc4c4d21d6f9e5b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.read_att_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>att</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a multiline string <em>att</em> and return a transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">att</td><td>A string in AT&amp;&amp; format that defines the transducer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> whose type is <a class="el" href="namespacelibhfst.html#adcafeb1242676bb61f894ede83b114bb" title="Get default transducer implementation type. ">libhfst.get_default_fst_type()</a>. Read <em>att</em> and create a transducer as defined in it. </dd></dl>

</div>
</div>
<a class="anchor" id="abe9194004fd5bf766fad03bff5d514c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.read_prolog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next transducer from prolog file pointed by <em>f</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A file pointer (<a class="el" href="classlibhfst_1_1HfstFile.html" title="A wrapper class for file operations. ">libhfst.HfstFile</a>) to the file.</td></tr>
  </table>
  </dd>
</dl>
<p>If the file contains several transducers, they must be separated by empty lines. </p>

</div>
</div>
<a class="anchor" id="a2611f16a0c0596d4564ce42149a8ba86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.regex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kvargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer as defined by regular expression <em>regexp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regexp</td><td>The regular expression defined with <a href="http://www.fsmbook.com/">Xerox transducer notation</a>. </td></tr>
    <tr><td class="paramname">kvargs</td><td>Argumnets recognized are: error. </td></tr>
    <tr><td class="paramname">error</td><td>Where warnings and errors are printed. Possible values are sys.stdout, sys.stderr (the default), a StringIO or None, indicating a quiet mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa455234e8a70e7151526756e6ab4fdfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.replace_down </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as replace_up, but matching is done on the output side of <em>mapping</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> <a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa455234e8a70e7151526756e6ab4fdfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.replace_down </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as replace_down(context, mapping, optional, alphabet) but <em>mapping</em> is performed in every context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a08ad1dae4c2ecb900fe9bb02fd8591f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.replace_down_karttunen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: document. </p>

</div>
</div>
<a class="anchor" id="a9f76f5e1f0dfb45d9ef6d7b772b2cb14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.replace_left </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as replace_up, but left context matching is done on the output side of <em>mapping</em> and right context on the input side of <em>mapping</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b40fcff89000fb8fc62164d6a1a7e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.replace_right </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as replace_up, but left context matching is done on the input side of <em>mapping</em> and right context on the output side of <em>mapping</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> <a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c9b018b846e6f0b69096bb5f535c793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.replace_up </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that performs an upward mapping <em>mapping</em> in the context <em>context</em> when the alphabet is <em>alphabet</em>. </p>
<p><em>optional</em> defines whether the mapping is optional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>A pair of transducers where the first transducer defines the left context and the second transducer the right context. Both transducers must be automata, i.e. map strings onto themselves. </td></tr>
    <tr><td class="paramname">mapping</td><td>The mapping (transducer) that the resulting transducer will perform in the context given in <em>context</em>. </td></tr>
    <tr><td class="paramname">optional</td><td>Whether the mapping is optional. </td></tr>
    <tr><td class="paramname">alphabet</td><td>The set of symbol pairs that defines the alphabet (a tuple of string pairs).</td></tr>
  </table>
  </dd>
</dl>
<p>Each substring s of the input string which is in the input language of the transducer <em>mapping</em> and whose left context is matched by the expression [.* l] (where l is the first element of <em>context</em>) and whose right context is matched by [r .*] (where r is the second element in the context) is mapped to the respective surface strings defined by transducer <em>mapping</em>. Any other character is mapped to the characters specified in <em>alphabet</em>. The left and right contexts must be automata (i.e. transducers which map strings onto themselves).</p>
<p>For example, a transducer yielded by the following arguments (in pseudocode) </p><pre class="fragment"> context = pair( [c], [c] )
 mappings = [ a:b a:b ]
 alphabet = set(a, b, c)</pre><p> would map the string "caacac" to "cbbcac".</p>
<p>Note that the alphabet must contain the characters a and b, but not the pair a:b (unless this replacement is to be allowed everywhere in the context).</p>
<p>Note that replace operations (unlike the two-level rules) have to be combined by composition rather than intersection.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibhfst_1_1ContextTransducersAreNotAutomataException.html" title="Transducers given as rule context are not automata. ">ContextTransducersAreNotAutomataException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c9b018b846e6f0b69096bb5f535c793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.replace_up </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as replace_up but <em>mapping</em> is performed in every context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a9c9b018b846e6f0b69096bb5f535c793" title="A transducer that performs an upward mapping mapping in the context context when the alphabet is alph...">replace_up</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a751d3a94f77a122c9f31a6eabfc400fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.restriction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that allows any (substring) mapping defined by <em>mapping</em> only if it occurs in any of the contexts in <em>contexts</em>. </p>
<p>Symbols outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibhfst_1_1EmptySetOfContextsException.html" title="The set of transducer pairs is empty. ">EmptySetOfContextsException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb9717cd081ddb74e50cfae8bc7c0672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.restriction_and_coercion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that is equivalent to the intersection of restriction and coercion and requires that the mappings defined by <em>mapping</em> occur always and only in the given contexts in <em>contexts</em>. </p>
<p>Symbols outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a751d3a94f77a122c9f31a6eabfc400fe" title="A transducer that allows any (substring) mapping defined by mapping only if it occurs in any of the c...">restriction</a> <a class="el" href="namespacelibhfst.html#a853cf5f12d54ef93ac3b7e271e29fdb1" title="A transducer that requires that one of the mappings defined by mapping must occur in each context in ...">coercion</a> <a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab04738a25a7f365c52e3f0d5fc349540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.set_default_fst_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default implementation type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>An libhfst.ImplementationType.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the implementation type (SFST_TYPE, TROPICAL_OPENFST_TYPE, FOMA_TYPE) that is used by default by all operations that create transducers. The default value is TROPICAL_OPENFST_TYPE </p>

</div>
</div>
<a class="anchor" id="aa94239c39b494741335e67e87a6a26d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.start_xfst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kvargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start interactive xfst compiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kvargs</td><td>Arguments recognized are: type, quit_on_fail. </td></tr>
    <tr><td class="paramname">quit_on_fail</td><td>Whether the compiler exits on any error, defaults to False. </td></tr>
    <tr><td class="paramname">type</td><td>Implementation type of the compiler, defaults to <a class="el" href="namespacelibhfst.html#adcafeb1242676bb61f894ede83b114bb" title="Get default transducer implementation type. ">libhfst.get_default_fst_type()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ea87edf0efe033127951a90ad80d5f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.surface_coercion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that specifies that a string from the input language of the transducer <em>mapping</em> always has to the mapped to one of its output strings according to transducer <em>mapping</em> if it appears in any of the contexts in <em>contexts</em>. </p>
<p>Symbols outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70eac5732a65f64cadefecd270297245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.surface_restriction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that specifies that a string from the input language of the transducer <em>mapping</em> may only be mapped to one of its output strings (according to transducer <em>mapping</em>) if it appears in any of the contexts in <em>contexts</em>. </p>
<p>Symbols outside of the matching substrings are mapped to any symbol allowed by <em>alphabet</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d6d38641034afae198bc874582faf0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.surface_restriction_and_coercion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that is equivalent to the intersection of surface_restriction and surface_coercion. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a70eac5732a65f64cadefecd270297245" title="A transducer that specifies that a string from the input language of the transducer mapping may only ...">surface_restriction</a> <a class="el" href="namespacelibhfst.html#a1ea87edf0efe033127951a90ad80d5f7" title="A transducer that specifies that a string from the input language of the transducer mapping always ha...">surface_coercion</a> <a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>A tuple of <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> pairs. </td></tr>
    <tr><td class="paramname">mapping</td><td>An <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>A tuple of string pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6740017cb0d7dad55d88369962a12f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.tokenized_fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer that recognizes the concatenation of symbols or symbol pairs in <em>arg</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The symbols or symbol pairs that form the path to be recognized.</td></tr>
  </table>
  </dd>
</dl>
<p>Example </p><pre class="fragment"> import libhfst
 tok = libhfst.HfstTokenizer()
 tok.add_multichar_symbol('foo')
 tok.add_multichar_symbol('bar')
 tr = libhfst.tokenized_fst(tok.tokenize('foobar', 'foobaz'))</pre><p> will create the transducer [foo:foo bar:b 0:a 0:z] </p>

</div>
</div>
<a class="anchor" id="a4047a800751231b74cd3e0152821a82a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.two_level_if </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that obligatorily performs the mappings defined by <em>mappings</em> in the context <em>context</em> when the alphabet is <em>alphabet</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>A pair of transducers where the first transducer defines the left context and the second transducer the right context. </td></tr>
    <tr><td class="paramname">mappings</td><td>A set of mappings (a tuple of string pairs) that the resulting transducer will perform in the context given in <em>context</em>. </td></tr>
    <tr><td class="paramname">alphabet</td><td>The set of symbol pairs (a tuple of string pairs) that defines the alphabet (see the example).</td></tr>
  </table>
  </dd>
</dl>
<p>For example, a transducer yielded by the following arguments (in pseudcode) </p><pre class="fragment"> context = pair( [c|d], [e] )
 mappings = set(a:b)
 alphabet = set(a, a:b, b, c, d, e, ...)</pre><p> obligatorily maps the symbol a to b if c or d precedes and e follows. (Elsewhere, the mapping of a to b is optional). This expression is identical to ![.* [c|d] [a:. &amp; !a:b] [e] .*] Note that the alphabet must contain the pair a:b here. </p><dl class="section see"><dt>See also</dt><dd><a href="ftp://ftp.ims.uni-stuttgart.de/pub/corpora/SFST/SFST-Manual.pdf">SFST manual</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1016b8e736f52d689ff1c45caf4b884e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.two_level_if_and_only_if </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that always performs the mappings defined by <em>mappings</em> in the context <em>context</em> and only in that context, when the alphabet is <em>alphabet</em>. </p>
<p>If called with the same arguments as in the example of <a class="el" href="namespacelibhfst.html#a4047a800751231b74cd3e0152821a82a" title="A transducer that obligatorily performs the mappings defined by mappings in the context context when ...">two_level_if</a>, the transducer maps symbol a to b only and only if c or d precedes and e follows. The mapping of a to b is obligatory in this context and cannot occur in any other context.</p>
<p>The expression is equivalent to ![.* [c|d] [a:. &amp; !a:b] [e] .*] &amp; ![ [ ![.* [c|d]] a:b .* ] | [ .* a:b ![[e] .*] ] ]</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a4047a800751231b74cd3e0152821a82a" title="A transducer that obligatorily performs the mappings defined by mappings in the context context when ...">two_level_if</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a185c753cfd56c6cbff737be417c02c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def libhfst.two_level_only_if </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A transducer that allows the mappings defined by <em>mappings</em> only in the context <em>context</em>, when the alphabet is <em>alphabet</em>. </p>
<p>If called with the same arguments as in the example of <a class="el" href="namespacelibhfst.html#a4047a800751231b74cd3e0152821a82a" title="A transducer that obligatorily performs the mappings defined by mappings in the context context when ...">two_level_if</a>, the transducer allows the mapping of symbol a to b only if c or d precedes and e follows. The mapping of a to b is optional in this context but cannot occur in any other context.</p>
<p>The expression is equivalent to ![ [ ![.* [c|d]] a:b .* ] | [ .* a:b ![[e] .*] ] ]</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelibhfst.html#a4047a800751231b74cd3e0152821a82a" title="A transducer that obligatorily performs the mappings defined by mappings in the context context when ...">two_level_if</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a9c72aae3ca2a5e4c25a95cefe40704a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string EPSILON = '@_EPSILON_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for epsilon symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = libhfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, 2.0)
 fsm.add_transition(0, 1, "foo", libhfst.EPSILON)
 if not libhfst.HfstTransducer(fsm).compare(libhfst.regex('foo:0::2.0')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, "0" is used for the epsilon. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac08bb67be4b97cae8b7d5bf3b66fb688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ERROR_TYPE = _libhfst.ERROR_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type not recognised. </p>
<p>This type might be returned by a function if an error occurs. </p>

</div>
</div>
<a class="anchor" id="a6d227efc26ac837490b58ef9693b1c8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FOMA_TYPE = _libhfst.FOMA_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A foma transducer, unweighted. </p>

</div>
</div>
<a class="anchor" id="a279af64d112476e38ebf1498d6d6f057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HFST2_TYPE = _libhfst.HFST2_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HFST2 header present, conversion required. </p>

</div>
</div>
<a class="anchor" id="a44467f3dabfb1b5a6cf6011ad63dcadb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HFST_OL_TYPE = _libhfst.HFST_OL_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An HFST optimized lookup transducer, unweighted. </p>

</div>
</div>
<a class="anchor" id="ac483b6adfb12973c57d1ba8df1cb9e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HFST_OLW_TYPE = _libhfst.HFST_OLW_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An HFST optimized lookup transducer with weights. </p>

</div>
</div>
<a class="anchor" id="a3b257e90982f934e0237c0bf2671a54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string IDENTITY = '@_IDENTITY_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for identity symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = libhfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, 1.5)
 fsm.add_transition(0, 1, libhfst.IDENTITY, libhfst.IDENTITY)
 if not libhfst.HfstTransducer(fsm).compare(libhfst.regex('?::1.5')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, a single "?" is used for the identity symbol. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6b38b4422b600ee9b8b6a6e27870102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LOG_OPENFST_TYPE = _libhfst.LOG_OPENFST_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An OpenFst transducer with logarithmic weights (limited support). </p>

</div>
</div>
<a class="anchor" id="af8aecd8e6f69ad8017031d652a34854f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SFST_TYPE = _libhfst.SFST_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An SFST transducer, unweighted. </p>

</div>
</div>
<a class="anchor" id="a44eede2dfd24b0ba24e5373dacbb209d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TO_FINAL_STATE = _libhfst.TO_FINAL_STATE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push weights toward final state(s). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibhfst_1_1HfstTransducer.html#aa30aa14d554e521ef2de288cfa236903" title="Push weights towards initial or final state(s) as defined by type. ">libhfst.HfstTransducer.push_weights</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a373a5ad282702de1dea17a2c8add2f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TO_INITIAL_STATE = _libhfst.TO_INITIAL_STATE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push weights toward initial state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibhfst_1_1HfstTransducer.html#aa30aa14d554e521ef2de288cfa236903" title="Push weights towards initial or final state(s) as defined by type. ">libhfst.HfstTransducer.push_weights</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d0d4616ee4e5a966d6e336035721b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TROPICAL_OPENFST_TYPE = _libhfst.TROPICAL_OPENFST_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An OpenFst transducer with tropical weights. </p>

</div>
</div>
<a class="anchor" id="a51bd2ecc765c9934d3f6396d30ace19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string UNKNOWN = '@_UNKNOWN_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for unknown symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = libhfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, -0.5)
 fsm.add_transition(0, 1, "foo", libhfst.UNKNOWN)
 fsm.add_transition(0, 1, "foo", "foo")
 if not libhfst.HfstTransducer(fsm).compare(libhfst.regex('foo:?::-0.5')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, "?" on either or both sides of a transition is used for the unknown symbol. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2585ee316086d7a58aee00492055a24a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNSPECIFIED_TYPE = _libhfst.UNSPECIFIED_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format left open by e.g. </p>
<p>default constructor. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 19 2016 16:45:01 for HFST - Helsinki Finite-State Transducer Technology - Python API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
