<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>HFST - Helsinki Finite-State Transducer Technology - Python API: hfst Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - Python API
   &#160;<span id="projectnumber">version 3.12.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hfst Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>HFST API for Python.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehfst_1_1exceptions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1exceptions.html">exceptions</a></td></tr>
<tr class="memdesc:namespacehfst_1_1exceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">exceptions... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehfst_1_1sfst__rules"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1sfst__rules.html">sfst_rules</a></td></tr>
<tr class="memdesc:namespacehfst_1_1sfst__rules"><td class="mdescLeft">&#160;</td><td class="mdescRight">rules... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehfst_1_1xerox__rules"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1xerox__rules.html">xerox_rules</a></td></tr>
<tr class="memdesc:namespacehfst_1_1xerox__rules"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xerox-type replace rules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1AttReader.html">AttReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for reading input in AT&amp;T text format and converting it into transducer(s).  <a href="classhfst_1_1AttReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstBasicTransducer.html">HfstBasicTransducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple transducer class with tropical weights.  <a href="classhfst_1_1HfstBasicTransducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstBasicTransition.html">HfstBasicTransition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transition class that consists of a target state, input and output symbols and a a tropical weight.  <a href="classhfst_1_1HfstBasicTransition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstInputStream.html">HfstInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for reading HFST binary transducers.  <a href="classhfst_1_1HfstInputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstOutputStream.html">HfstOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for writing binary transducers.  <a href="classhfst_1_1HfstOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tokenizer for creating transducers from UTF-8 strings.  <a href="classhfst_1_1HfstTokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synchronous finite-state transducer.  <a href="classhfst_1_1HfstTransducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1ImplementationType.html">ImplementationType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-end implementations.  <a href="classhfst_1_1ImplementationType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1MultiCharSymbolTrie.html">MultiCharSymbolTrie</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: documentation ???  <a href="classhfst_1_1MultiCharSymbolTrie.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1PmatchContainer.html">PmatchContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for performing pattern matching.  <a href="classhfst_1_1PmatchContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1PrologReader.html">PrologReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for reading input in prolog text format and converting it into transducer(s).  <a href="classhfst_1_1PrologReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1XreCompiler.html">XreCompiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A regular expression compiler.  <a href="classhfst_1_1XreCompiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af186a42371a9c214f73c0130ec2946ec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#af186a42371a9c214f73c0130ec2946ec">compile_lexc_file</a></td></tr>
<tr class="memdesc:af186a42371a9c214f73c0130ec2946ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile lexc file <em>filename</em> into a transducer.  <a href="#af186a42371a9c214f73c0130ec2946ec">More...</a><br /></td></tr>
<tr class="separator:af186a42371a9c214f73c0130ec2946ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a0202ca86861a814f57d53bec5ac37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a66a0202ca86861a814f57d53bec5ac37">compile_pmatch_expression</a></td></tr>
<tr class="memdesc:a66a0202ca86861a814f57d53bec5ac37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a pmatch expression into a tuple of transducers.  <a href="#a66a0202ca86861a814f57d53bec5ac37">More...</a><br /></td></tr>
<tr class="separator:a66a0202ca86861a814f57d53bec5ac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8911ff0c8be9fe6842b8a555d6f45466"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a8911ff0c8be9fe6842b8a555d6f45466">compile_pmatch_file</a></td></tr>
<tr class="memdesc:a8911ff0c8be9fe6842b8a555d6f45466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile pmatch expressions as defined in <em>filename</em> and return a tuple of transducers.  <a href="#a8911ff0c8be9fe6842b8a555d6f45466">More...</a><br /></td></tr>
<tr class="separator:a8911ff0c8be9fe6842b8a555d6f45466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a1c404ef876ed104c7fb484f16a298"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a92a1c404ef876ed104c7fb484f16a298">compile_xfst_file</a></td></tr>
<tr class="memdesc:a92a1c404ef876ed104c7fb484f16a298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile (is 'run' a better term?) xfst file <em>filename</em>.  <a href="#a92a1c404ef876ed104c7fb484f16a298">More...</a><br /></td></tr>
<tr class="separator:a92a1c404ef876ed104c7fb484f16a298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ece7b55ccda18be684ac57cc11a842a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a3ece7b55ccda18be684ac57cc11a842a">empty_fst</a></td></tr>
<tr class="memdesc:a3ece7b55ccda18be684ac57cc11a842a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an empty transducer.  <a href="#a3ece7b55ccda18be684ac57cc11a842a">More...</a><br /></td></tr>
<tr class="separator:a3ece7b55ccda18be684ac57cc11a842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef23195fa816702e5c392eb6fd93ba9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#aaef23195fa816702e5c392eb6fd93ba9">epsilon_fst</a></td></tr>
<tr class="memdesc:aaef23195fa816702e5c392eb6fd93ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an epsilon transducer.  <a href="#aaef23195fa816702e5c392eb6fd93ba9">More...</a><br /></td></tr>
<tr class="separator:aaef23195fa816702e5c392eb6fd93ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa10116bab8b184a0359b9114ac048f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a7fa10116bab8b184a0359b9114ac048f">fst</a></td></tr>
<tr class="memdesc:a7fa10116bab8b184a0359b9114ac048f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer that recognizes one or more paths.  <a href="#a7fa10116bab8b184a0359b9114ac048f">More...</a><br /></td></tr>
<tr class="separator:a7fa10116bab8b184a0359b9114ac048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eca65797b47ec47de7fda415ee33c90"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a2eca65797b47ec47de7fda415ee33c90">fst_type_to_string</a></td></tr>
<tr class="memdesc:a2eca65797b47ec47de7fda415ee33c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of transducer implementation type <em>type</em>.  <a href="#a2eca65797b47ec47de7fda415ee33c90">More...</a><br /></td></tr>
<tr class="separator:a2eca65797b47ec47de7fda415ee33c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab902ea8eeddff20f1d2ad084da25f60f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ab902ea8eeddff20f1d2ad084da25f60f">get_default_fst_type</a></td></tr>
<tr class="memdesc:ab902ea8eeddff20f1d2ad084da25f60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default transducer implementation type.  <a href="#ab902ea8eeddff20f1d2ad084da25f60f">More...</a><br /></td></tr>
<tr class="separator:ab902ea8eeddff20f1d2ad084da25f60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082fc70196655a703c9c71b70a6ffd76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a082fc70196655a703c9c71b70a6ffd76">is_diacritic</a></td></tr>
<tr class="memdesc:a082fc70196655a703c9c71b70a6ffd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether symbol <em>symbol</em> is a flag diacritic.  <a href="#a082fc70196655a703c9c71b70a6ffd76">More...</a><br /></td></tr>
<tr class="separator:a082fc70196655a703c9c71b70a6ffd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5e8ddf70aade9c122bd90894f465c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#abc5e8ddf70aade9c122bd90894f465c0">read_att_input</a></td></tr>
<tr class="memdesc:abc5e8ddf70aade9c122bd90894f465c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read AT&amp;T input from the user and return a transducer.  <a href="#abc5e8ddf70aade9c122bd90894f465c0">More...</a><br /></td></tr>
<tr class="separator:abc5e8ddf70aade9c122bd90894f465c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea3ee8860eefad4757de7b0737f5f01"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a3ea3ee8860eefad4757de7b0737f5f01">read_att_string</a></td></tr>
<tr class="memdesc:a3ea3ee8860eefad4757de7b0737f5f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a multiline string <em>att</em> and return a transducer.  <a href="#a3ea3ee8860eefad4757de7b0737f5f01">More...</a><br /></td></tr>
<tr class="separator:a3ea3ee8860eefad4757de7b0737f5f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc210c2d03b01fca00c142e97b324e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a7fdc210c2d03b01fca00c142e97b324e">read_att_transducer</a></td></tr>
<tr class="memdesc:a7fdc210c2d03b01fca00c142e97b324e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next transducer from AT&amp;T file pointed by <em>f</em>.  <a href="#a7fdc210c2d03b01fca00c142e97b324e">More...</a><br /></td></tr>
<tr class="separator:a7fdc210c2d03b01fca00c142e97b324e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc63fe7f8a85225173d6e27ba7d563bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#acc63fe7f8a85225173d6e27ba7d563bc">read_prolog_transducer</a></td></tr>
<tr class="separator:acc63fe7f8a85225173d6e27ba7d563bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95bd6caf63f3a437c2435f3c2ba6faf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ad95bd6caf63f3a437c2435f3c2ba6faf">regex</a></td></tr>
<tr class="memdesc:ad95bd6caf63f3a437c2435f3c2ba6faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer as defined by regular expression <em>regexp</em>.  <a href="#ad95bd6caf63f3a437c2435f3c2ba6faf">More...</a><br /></td></tr>
<tr class="separator:ad95bd6caf63f3a437c2435f3c2ba6faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122f9ba98dd2434d0ecdf69adc0f3089"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a122f9ba98dd2434d0ecdf69adc0f3089">set_default_fst_type</a></td></tr>
<tr class="memdesc:a122f9ba98dd2434d0ecdf69adc0f3089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default implementation type.  <a href="#a122f9ba98dd2434d0ecdf69adc0f3089">More...</a><br /></td></tr>
<tr class="separator:a122f9ba98dd2434d0ecdf69adc0f3089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80f352a5e2ea641cc5c3d98ebf1dc5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a9a80f352a5e2ea641cc5c3d98ebf1dc5">start_xfst</a></td></tr>
<tr class="memdesc:a9a80f352a5e2ea641cc5c3d98ebf1dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start interactive xfst compiler.  <a href="#a9a80f352a5e2ea641cc5c3d98ebf1dc5">More...</a><br /></td></tr>
<tr class="separator:a9a80f352a5e2ea641cc5c3d98ebf1dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5f30e96f818954128ed74bb49062de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a1a5f30e96f818954128ed74bb49062de">tokenized_fst</a></td></tr>
<tr class="memdesc:a1a5f30e96f818954128ed74bb49062de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer that recognizes the concatenation of symbols or symbol pairs in <em>arg</em>.  <a href="#a1a5f30e96f818954128ed74bb49062de">More...</a><br /></td></tr>
<tr class="separator:a1a5f30e96f818954128ed74bb49062de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2">EPSILON</a> = '@_EPSILON_SYMBOL_@'</td></tr>
<tr class="memdesc:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for epsilon symbol.  <a href="#a9c72aae3ca2a5e4c25a95cefe40704a2">More...</a><br /></td></tr>
<tr class="separator:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b257e90982f934e0237c0bf2671a54b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a3b257e90982f934e0237c0bf2671a54b">IDENTITY</a> = '@_IDENTITY_SYMBOL_@'</td></tr>
<tr class="memdesc:a3b257e90982f934e0237c0bf2671a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for identity symbol.  <a href="#a3b257e90982f934e0237c0bf2671a54b">More...</a><br /></td></tr>
<tr class="separator:a3b257e90982f934e0237c0bf2671a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bd2ecc765c9934d3f6396d30ace19f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a51bd2ecc765c9934d3f6396d30ace19f">UNKNOWN</a> = '@_UNKNOWN_SYMBOL_@'</td></tr>
<tr class="memdesc:a51bd2ecc765c9934d3f6396d30ace19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for unknown symbol.  <a href="#a51bd2ecc765c9934d3f6396d30ace19f">More...</a><br /></td></tr>
<tr class="separator:a51bd2ecc765c9934d3f6396d30ace19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>HFST API for Python. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af186a42371a9c214f73c0130ec2946ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_lexc_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile lexc file <em>filename</em> into a transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the lexc file. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: verbosity, with_flags, output. </td></tr>
    <tr><td class="paramname">verbosity</td><td>The verbosity of the compiler, defaults to 0 (silent). Possible values are: 0, 1, 2. </td></tr>
    <tr><td class="paramname">with_flags</td><td>Whether lexc flags are used when compiling, defaults to False. </td></tr>
    <tr><td class="paramname">output</td><td>Where output is printed. Possible values are sys.stdout, sys.stderr, a StringIO, sys.stderr being the default? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66a0202ca86861a814f57d53bec5ac37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_pmatch_expression </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a pmatch expression into a tuple of transducers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>A string defining how pmatch is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#a8911ff0c8be9fe6842b8a555d6f45466" title="Compile pmatch expressions as defined in filename and return a tuple of transducers. ">hfst.compile_pmatch_file</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8911ff0c8be9fe6842b8a555d6f45466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_pmatch_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile pmatch expressions as defined in <em>filename</em> and return a tuple of transducers. </p>
<p>An example:</p>
<p>If we have a file named streets.txt that contains:</p>
<p>define CapWord UppercaseAlpha Alpha* ; define StreetWordFr [{avenue} | {boulevard} | {rue}] ; define DeFr [ [{de} | {du} | {des} | {de la}] Whitespace ] | [{d'} | {l'}] ; define StreetFr StreetWordFr (Whitespace DeFr) CapWord+ ; regex StreetFr EndTag(FrenchStreetName) ;</p>
<p>we can run:</p>
<p>defs = <a class="el" href="namespacehfst.html#a8911ff0c8be9fe6842b8a555d6f45466" title="Compile pmatch expressions as defined in filename and return a tuple of transducers. ">hfst.compile_pmatch_file</a>('streets.txt') const = <a class="el" href="classhfst_1_1PmatchContainer.html" title="A class for performing pattern matching. ">hfst.PmatchContainer(defs)</a> assert cont.match("Je marche seul dans l'avenue des Ternes.") == "Je marche seul dans l'&lt;FrenchStreetName&gt;avenue des Ternes&lt;/FrenchStreetName&gt;." </p>

</div>
</div>
<a class="anchor" id="a92a1c404ef876ed104c7fb484f16a298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_xfst_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile (is 'run' a better term?) xfst file <em>filename</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the xfst file. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: verbosity, quit_on_fail, output, type. </td></tr>
    <tr><td class="paramname">verbosity</td><td>The verbosity of the compiler, defaults to 0 (silent). Possible values are: 0, 1, 2. </td></tr>
    <tr><td class="paramname">quit_on_fail</td><td>Whether the script is exited on any error, defaults to True. </td></tr>
    <tr><td class="paramname">output</td><td>Where output is printed. Possible values are sys.stdout, sys.stderr, a StringIO, sys.stderr being the default? </td></tr>
    <tr><td class="paramname">type</td><td>Implementation type of the compiler, defaults to <a class="el" href="namespacehfst.html#ab902ea8eeddff20f1d2ad084da25f60f" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ece7b55ccda18be684ac57cc11a842a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.empty_fst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an empty transducer. </p>
<p>Empty transducer has one state that is not final, i.e. it does not recognize any string. </p>

</div>
</div>
<a class="anchor" id="aaef23195fa816702e5c392eb6fd93ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.epsilon_fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an epsilon transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>The weight of the final state. Epsilon transducer has one state that is final (with final weight <em>weight</em>), i.e. it recognizes the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fa10116bab8b184a0359b9114ac048f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer that recognizes one or more paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>See example below</td></tr>
  </table>
  </dd>
</dl>
<p>Possible inputs: </p><pre class="fragment"> One unweighted identity path:
 'foo'  -&gt;  [f o o]
 Weighted path: a tuple of string and number, e.g.
 ('foo',1.4)
 ('bar',-3)
 ('baz',0)
 Several paths: a list or a tuple of paths and/or weighted paths, e.g.
 ['foo', 'bar']
 ('foo', ('bar',5.0))
 ('foo', ('bar',5.0), 'baz', 'Foo', ('Bar',2.4))
 [('foo',-1), ('bar',0), ('baz',3.5)]
 A dictionary mapping strings to any of the above cases:
 {'foo':'foo', 'bar':('foo',1.4), 'baz':(('foo',-1),'BAZ')}</pre> 
</div>
</div>
<a class="anchor" id="a2eca65797b47ec47de7fda415ee33c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.fst_type_to_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string representation of transducer implementation type <em>type</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>An <a class="el" href="classhfst_1_1ImplementationType.html" title="Back-end implementations. ">hfst.ImplementationType</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab902ea8eeddff20f1d2ad084da25f60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.get_default_fst_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default transducer implementation type. </p>
<p>If the default type is not set, it defaults to <a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a> </p>

</div>
</div>
<a class="anchor" id="a082fc70196655a703c9c71b70a6ffd76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.is_diacritic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether symbol <em>symbol</em> is a flag diacritic. </p>
<p>Flag diacritics are of the form </p><pre class="fragment"> @[PNDRCU][.][A-Z]+([.][A-Z]+)?@</pre> 
</div>
</div>
<a class="anchor" id="abc5e8ddf70aade9c122bd90894f465c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_att_input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read AT&amp;T input from the user and return a transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> whose type is <a class="el" href="namespacehfst.html#ab902ea8eeddff20f1d2ad084da25f60f" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. Read one AT&amp;T line at a time from standard input and finally return an equivalent transducer. An empty line signals the end of input. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea3ee8860eefad4757de7b0737f5f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_att_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>att</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a multiline string <em>att</em> and return a transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">att</td><td>A string in AT&amp;&amp; format that defines the transducer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> whose type is <a class="el" href="namespacehfst.html#ab902ea8eeddff20f1d2ad084da25f60f" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. Read <em>att</em> and create a transducer as defined in it. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fdc210c2d03b01fca00c142e97b324e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_att_transducer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>epsilonstr</em> = <code><a class="el" href="namespacehfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2">hfst.EPSILON</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next transducer from AT&amp;T file pointed by <em>f</em>. </p>
<p><em>epsilonstr</em> defines the symbol used for epsilon in the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A python file </td></tr>
    <tr><td class="paramname">epsilonstr</td><td>How epsilon is represented in the file. By default, "@_EPSILON_SYMBOL_@" and "@0@" are both recognized.</td></tr>
  </table>
  </dd>
</dl>
<p>If the file contains several transducers, they must be separated by "--" lines. In AT&amp;T format, the transition lines are of the form:</p>
<pre class="fragment"> [0-9]+[\w]+[0-9]+[\w]+[^\w]+[\w]+[^\w]([\w]+(-)[0-9]+(\.[0-9]+))</pre><p>and final state lines:</p>
<pre class="fragment"> [0-9]+[\w]+([\w]+(-)[0-9]+(\.[0-9]+))</pre><p>If several transducers are listed in the same file, they are separated by lines of two consecutive hyphens "--". If the weight </p><pre class="fragment"> ([\w]+(-)[0-9]+(\.[0-9]+))</pre><p> is missing, the transition or final state is given a zero weight.</p>
<p>NOTE: If transition symbols contains spaces, they must be escaped as '@_SPACE_@' because spaces are used as field separators. Both '@0@' and '@_EPSILON_SYMBOL_@' are always interpreted as epsilons.</p>
<p>An example: </p><pre class="fragment"> 0      1      foo      bar      0.3
 1      0.5
 --
 0      0.0
 --
 --
 0      0.0
 0      0      a        &lt;eps&gt;    0.2</pre><p>The example lists four transducers in AT&amp;T format: one transducer accepting the string pair &lt;'foo','bar'&gt;, one epsilon transducer, one empty transducer and one transducer that accepts any number of 'a's and produces an empty string in all cases. The transducers can be read with the following commands (from a file named 'testfile.att'): </p><pre class="fragment"> transducers = []
 ifile = open('testfile.att', 'r')
 try:
     while (True):
         t = hfst.read_att_transducer(ifile, '&lt;eps&gt;')
         transducers.append(t)
         print("read one transducer")
 except hfst.exceptions.NotValidAttFormatException as e:
     print("Error reading transducer: not valid AT&amp;T format.")
 except hfst.exceptions.EndOfStreamException as e:
     pass
 ifile.close()
 print("Read %i transducers in total" % len(transducers))</pre><p>Epsilon will be represented as <a class="el" href="namespacehfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2" title="The string for epsilon symbol. ">hfst.EPSILON</a> in the resulting transducer. The argument <em>epsilon_symbol</em> only denotes how epsilons are represented in <em>ifile</em>.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Empty transducers are in theory represented as empty strings in AT&amp;T format. However, this sometimes results in them getting interpreted as end-of-file. To avoid this, use an empty line instead, i.e. a single newline character.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NotValidAttFormatException</td><td></td></tr>
    <tr><td class="paramname">StreamNotReadableException</td><td></td></tr>
    <tr><td class="paramname">StreamIsClosedException</td><td></td></tr>
    <tr><td class="paramname">EndOfStreamException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>#write_att </dd></dl>

</div>
</div>
<a class="anchor" id="acc63fe7f8a85225173d6e27ba7d563bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_prolog_transducer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad95bd6caf63f3a437c2435f3c2ba6faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.regex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer as defined by regular expression <em>regexp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regexp</td><td>The regular expression defined with <a href="http://www.fsmbook.com/">Xerox transducer notation</a>. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Argumnets recognized are: error. </td></tr>
    <tr><td class="paramname">error</td><td>Where warnings and errors are printed. Possible values are sys.stdout, sys.stderr (the default), a StringIO or None, indicating a quiet mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a122f9ba98dd2434d0ecdf69adc0f3089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.set_default_fst_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default implementation type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>An <a class="el" href="classhfst_1_1ImplementationType.html" title="Back-end implementations. ">hfst.ImplementationType</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the implementation type (SFST_TYPE, TROPICAL_OPENFST_TYPE, FOMA_TYPE) that is used by default by all operations that create transducers. The default value is TROPICAL_OPENFST_TYPE </p>

</div>
</div>
<a class="anchor" id="a9a80f352a5e2ea641cc5c3d98ebf1dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.start_xfst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start interactive xfst compiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: type, quit_on_fail. </td></tr>
    <tr><td class="paramname">quit_on_fail</td><td>Whether the compiler exits on any error, defaults to False. </td></tr>
    <tr><td class="paramname">type</td><td>Implementation type of the compiler, defaults to <a class="el" href="namespacehfst.html#ab902ea8eeddff20f1d2ad084da25f60f" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a5f30e96f818954128ed74bb49062de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.tokenized_fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer that recognizes the concatenation of symbols or symbol pairs in <em>arg</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The symbols or symbol pairs that form the path to be recognized.</td></tr>
  </table>
  </dd>
</dl>
<p>Example </p><pre class="fragment"> import hfst
 tok = hfst.HfstTokenizer()
 tok.add_multichar_symbol('foo')
 tok.add_multichar_symbol('bar')
 tr = hfst.tokenized_fst(tok.tokenize('foobar', 'foobaz'))</pre><p> will create the transducer [foo:foo bar:b 0:a 0:z] </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a9c72aae3ca2a5e4c25a95cefe40704a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string EPSILON = '@_EPSILON_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for epsilon symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = hfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, 2.0)
 fsm.add_transition(0, 1, "foo", hfst.EPSILON)
 if not hfst.HfstTransducer(fsm).compare(hfst.regex('foo:0::2.0')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, "0" is used for the epsilon. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b257e90982f934e0237c0bf2671a54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string IDENTITY = '@_IDENTITY_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for identity symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = hfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, 1.5)
 fsm.add_transition(0, 1, hfst.IDENTITY, hfst.IDENTITY)
 if not hfst.HfstTransducer(fsm).compare(hfst.regex('?::1.5')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, a single "?" is used for the identity symbol. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51bd2ecc765c9934d3f6396d30ace19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string UNKNOWN = '@_UNKNOWN_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for unknown symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = hfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, -0.5)
 fsm.add_transition(0, 1, "foo", hfst.UNKNOWN)
 fsm.add_transition(0, 1, "foo", "foo")
 if not hfst.HfstTransducer(fsm).compare(hfst.regex('foo:?::-0.5')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, "?" on either or both sides of a transition is used for the unknown symbol. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2016 11:02:55 for HFST - Helsinki Finite-State Transducer Technology - Python API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
