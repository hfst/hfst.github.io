<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>HFST - Helsinki Finite-State Transducer Technology - Python API: HfstTransducer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - Python API
   &#160;<span id="projectnumber">version 3.12.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehfst.html">hfst</a></li><li class="navelem"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhfst_1_1HfstTransducer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HfstTransducer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A synchronous finite-state transducer.  
 <a href="classhfst_1_1HfstTransducer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac775ee34451fdfa742b318538164070e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr class="memdesc:ac775ee34451fdfa742b318538164070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty transducer.  <a href="#ac775ee34451fdfa742b318538164070e">More...</a><br /></td></tr>
<tr class="separator:ac775ee34451fdfa742b318538164070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775ee34451fdfa742b318538164070e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr class="memdesc:ac775ee34451fdfa742b318538164070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> <em>another</em> or a transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>another</em>.  <a href="#ac775ee34451fdfa742b318538164070e">More...</a><br /></td></tr>
<tr class="separator:ac775ee34451fdfa742b318538164070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775ee34451fdfa742b318538164070e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr class="memdesc:ac775ee34451fdfa742b318538164070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an HFST transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>t</em>.  <a href="#ac775ee34451fdfa742b318538164070e">More...</a><br /></td></tr>
<tr class="separator:ac775ee34451fdfa742b318538164070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a4b9bc0941308e362738503137460e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa7a4b9bc0941308e362738503137460e">__str__</a></td></tr>
<tr class="memdesc:aa7a4b9bc0941308e362738503137460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AT&amp;T representation of the transducer.  <a href="#aa7a4b9bc0941308e362738503137460e">More...</a><br /></td></tr>
<tr class="separator:aa7a4b9bc0941308e362738503137460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb29cf6999377200bf19736b0e296ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#abcb29cf6999377200bf19736b0e296ac">compare</a></td></tr>
<tr class="memdesc:abcb29cf6999377200bf19736b0e296ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this transducer and <em>another</em> are equivalent.  <a href="#abcb29cf6999377200bf19736b0e296ac">More...</a><br /></td></tr>
<tr class="separator:abcb29cf6999377200bf19736b0e296ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cfee3258e73d2ddccb3901acd587dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a55cfee3258e73d2ddccb3901acd587dc">compose</a></td></tr>
<tr class="memdesc:a55cfee3258e73d2ddccb3901acd587dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this transducer with <em>another</em>.  <a href="#a55cfee3258e73d2ddccb3901acd587dc">More...</a><br /></td></tr>
<tr class="separator:a55cfee3258e73d2ddccb3901acd587dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ff54fd799851453851e2058537fc98"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a34ff54fd799851453851e2058537fc98">compose_intersect</a></td></tr>
<tr class="memdesc:a34ff54fd799851453851e2058537fc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this transducer with the intersection of transducers in <em>v</em>.  <a href="#a34ff54fd799851453851e2058537fc98">More...</a><br /></td></tr>
<tr class="separator:a34ff54fd799851453851e2058537fc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5709c296a86a1a9c9344dacc4363795"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac5709c296a86a1a9c9344dacc4363795">concatenate</a></td></tr>
<tr class="memdesc:ac5709c296a86a1a9c9344dacc4363795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate this transducer with <em>another</em>.  <a href="#ac5709c296a86a1a9c9344dacc4363795">More...</a><br /></td></tr>
<tr class="separator:ac5709c296a86a1a9c9344dacc4363795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8535116b67d8bbacc28ccf338a01b0ca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8535116b67d8bbacc28ccf338a01b0ca">conjunct</a></td></tr>
<tr class="memdesc:a8535116b67d8bbacc28ccf338a01b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for intersect.  <a href="#a8535116b67d8bbacc28ccf338a01b0ca">More...</a><br /></td></tr>
<tr class="separator:a8535116b67d8bbacc28ccf338a01b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe69e9190aa0b3889a9a5f63a42799f5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#afe69e9190aa0b3889a9a5f63a42799f5">convert</a></td></tr>
<tr class="memdesc:afe69e9190aa0b3889a9a5f63a42799f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the transducer into an equivalent transducer in format <em>type</em>.  <a href="#afe69e9190aa0b3889a9a5f63a42799f5">More...</a><br /></td></tr>
<tr class="separator:afe69e9190aa0b3889a9a5f63a42799f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa43c22b5f7af93ba8b4a56871f006a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2fa43c22b5f7af93ba8b4a56871f006a">copy</a></td></tr>
<tr class="memdesc:a2fa43c22b5f7af93ba8b4a56871f006a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of the transducer.  <a href="#a2fa43c22b5f7af93ba8b4a56871f006a">More...</a><br /></td></tr>
<tr class="separator:a2fa43c22b5f7af93ba8b4a56871f006a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3771e47365316c240b605bd32f1ca6e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3771e47365316c240b605bd32f1ca6e3">cross_product</a></td></tr>
<tr class="memdesc:a3771e47365316c240b605bd32f1ca6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make cross product of this transducer with <em>another</em>.  <a href="#a3771e47365316c240b605bd32f1ca6e3">More...</a><br /></td></tr>
<tr class="separator:a3771e47365316c240b605bd32f1ca6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d993812672582affc6c5bf694cb97d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a4d993812672582affc6c5bf694cb97d2">determinize</a></td></tr>
<tr class="memdesc:a4d993812672582affc6c5bf694cb97d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinize the transducer.  <a href="#a4d993812672582affc6c5bf694cb97d2">More...</a><br /></td></tr>
<tr class="separator:a4d993812672582affc6c5bf694cb97d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9dd92a3576eff0fc9f65a5c203a14a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a6f9dd92a3576eff0fc9f65a5c203a14a">disjunct</a></td></tr>
<tr class="memdesc:a6f9dd92a3576eff0fc9f65a5c203a14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunct this transducer with <em>another</em>.  <a href="#a6f9dd92a3576eff0fc9f65a5c203a14a">More...</a><br /></td></tr>
<tr class="separator:a6f9dd92a3576eff0fc9f65a5c203a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2952ad579a13724e4bbf810d0f32b176"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2952ad579a13724e4bbf810d0f32b176">eliminate_flag</a></td></tr>
<tr class="memdesc:a2952ad579a13724e4bbf810d0f32b176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate flag diacritic <em>symbol</em> from the transducer.  <a href="#a2952ad579a13724e4bbf810d0f32b176">More...</a><br /></td></tr>
<tr class="separator:a2952ad579a13724e4bbf810d0f32b176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52096c13063131ad1f3f17e98799555c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a52096c13063131ad1f3f17e98799555c">eliminate_flags</a></td></tr>
<tr class="memdesc:a52096c13063131ad1f3f17e98799555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate flag diacritics listed in <em>symbols</em> from the transducer.  <a href="#a52096c13063131ad1f3f17e98799555c">More...</a><br /></td></tr>
<tr class="separator:a52096c13063131ad1f3f17e98799555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376c16070c75297d2217957a3906dcb2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a376c16070c75297d2217957a3906dcb2">extract_longest_paths</a></td></tr>
<tr class="memdesc:a376c16070c75297d2217957a3906dcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract longest paths of the transducer.  <a href="#a376c16070c75297d2217957a3906dcb2">More...</a><br /></td></tr>
<tr class="separator:a376c16070c75297d2217957a3906dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6151029d6e4457b6a8daf67731bc06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#adf6151029d6e4457b6a8daf67731bc06">extract_paths</a></td></tr>
<tr class="memdesc:adf6151029d6e4457b6a8daf67731bc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract paths that are recognized by the transducer.  <a href="#adf6151029d6e4457b6a8daf67731bc06">More...</a><br /></td></tr>
<tr class="separator:adf6151029d6e4457b6a8daf67731bc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9278f53436e9adf48cd8afbf6ec884"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a4f9278f53436e9adf48cd8afbf6ec884">extract_shortest_paths</a></td></tr>
<tr class="memdesc:a4f9278f53436e9adf48cd8afbf6ec884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract shortest paths of the transducer.  <a href="#a4f9278f53436e9adf48cd8afbf6ec884">More...</a><br /></td></tr>
<tr class="separator:a4f9278f53436e9adf48cd8afbf6ec884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b2da59494d2e4ee4c40bf7cfc27759"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a57b2da59494d2e4ee4c40bf7cfc27759">get_alphabet</a></td></tr>
<tr class="memdesc:a57b2da59494d2e4ee4c40bf7cfc27759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the alphabet of the transducer.  <a href="#a57b2da59494d2e4ee4c40bf7cfc27759">More...</a><br /></td></tr>
<tr class="separator:a57b2da59494d2e4ee4c40bf7cfc27759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3160d6b4e517398ca3f9e51b260bb7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2f3160d6b4e517398ca3f9e51b260bb7">get_name</a></td></tr>
<tr class="memdesc:a2f3160d6b4e517398ca3f9e51b260bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the transducer.  <a href="#a2f3160d6b4e517398ca3f9e51b260bb7">More...</a><br /></td></tr>
<tr class="separator:a2f3160d6b4e517398ca3f9e51b260bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96325faffde2dc0cf43f1c2046d92bc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a96325faffde2dc0cf43f1c2046d92bc4">get_properties</a></td></tr>
<tr class="memdesc:a96325faffde2dc0cf43f1c2046d92bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all properties from the transducer.  <a href="#a96325faffde2dc0cf43f1c2046d92bc4">More...</a><br /></td></tr>
<tr class="separator:a96325faffde2dc0cf43f1c2046d92bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8e5df587b8fd333c50077821e68875"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a7f8e5df587b8fd333c50077821e68875">get_property</a></td></tr>
<tr class="memdesc:a7f8e5df587b8fd333c50077821e68875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get arbitrary string propert <em>property</em>.  <a href="#a7f8e5df587b8fd333c50077821e68875">More...</a><br /></td></tr>
<tr class="separator:a7f8e5df587b8fd333c50077821e68875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef321a485de87e39ea78ebd3ba31b23"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a0ef321a485de87e39ea78ebd3ba31b23">get_type</a></td></tr>
<tr class="memdesc:a0ef321a485de87e39ea78ebd3ba31b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation type of the transducer.  <a href="#a0ef321a485de87e39ea78ebd3ba31b23">More...</a><br /></td></tr>
<tr class="separator:a0ef321a485de87e39ea78ebd3ba31b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2f565f6d8c07e61d2a3d602cdc746d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a7e2f565f6d8c07e61d2a3d602cdc746d">has_flag_diacritics</a></td></tr>
<tr class="memdesc:a7e2f565f6d8c07e61d2a3d602cdc746d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer has flag diacritics in its transitions.  <a href="#a7e2f565f6d8c07e61d2a3d602cdc746d">More...</a><br /></td></tr>
<tr class="separator:a7e2f565f6d8c07e61d2a3d602cdc746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f13c4bbb9c6031552a5af0a00281261"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a1f13c4bbb9c6031552a5af0a00281261">input_project</a></td></tr>
<tr class="memdesc:a1f13c4bbb9c6031552a5af0a00281261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the input language of the transducer.  <a href="#a1f13c4bbb9c6031552a5af0a00281261">More...</a><br /></td></tr>
<tr class="separator:a1f13c4bbb9c6031552a5af0a00281261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2b3a8aec371a00e1ee73f66768136a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aec2b3a8aec371a00e1ee73f66768136a">insert_freely</a></td></tr>
<tr class="memdesc:aec2b3a8aec371a00e1ee73f66768136a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freely insert a transition or a transducer into the transducer.  <a href="#aec2b3a8aec371a00e1ee73f66768136a">More...</a><br /></td></tr>
<tr class="separator:aec2b3a8aec371a00e1ee73f66768136a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4feafa7b9cfba0d22d67aa4d428101"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8d4feafa7b9cfba0d22d67aa4d428101">insert_to_alphabet</a></td></tr>
<tr class="memdesc:a8d4feafa7b9cfba0d22d67aa4d428101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly insert <em>symbol</em> to the alphabet of the transducer.  <a href="#a8d4feafa7b9cfba0d22d67aa4d428101">More...</a><br /></td></tr>
<tr class="separator:a8d4feafa7b9cfba0d22d67aa4d428101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa093d24790fac4fdd9bd09080da6c276"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa093d24790fac4fdd9bd09080da6c276">intersect</a></td></tr>
<tr class="memdesc:aa093d24790fac4fdd9bd09080da6c276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect this transducer with <em>another</em>.  <a href="#aa093d24790fac4fdd9bd09080da6c276">More...</a><br /></td></tr>
<tr class="separator:aa093d24790fac4fdd9bd09080da6c276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d89a8b0795ef2f51cc60cc2e92452"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a989d89a8b0795ef2f51cc60cc2e92452">invert</a></td></tr>
<tr class="memdesc:a989d89a8b0795ef2f51cc60cc2e92452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the input and output symbols of each transition in the transducer.  <a href="#a989d89a8b0795ef2f51cc60cc2e92452">More...</a><br /></td></tr>
<tr class="separator:a989d89a8b0795ef2f51cc60cc2e92452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587ee3a5e0f182b520e69ec1979bb3e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a6587ee3a5e0f182b520e69ec1979bb3e">is_automaton</a></td></tr>
<tr class="memdesc:a6587ee3a5e0f182b520e69ec1979bb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether each transition in the transducer has equivalent input and output symbols.  <a href="#a6587ee3a5e0f182b520e69ec1979bb3e">More...</a><br /></td></tr>
<tr class="separator:a6587ee3a5e0f182b520e69ec1979bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dd9d8ce80da912f64c611a67e31ea0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a52dd9d8ce80da912f64c611a67e31ea0">is_cyclic</a></td></tr>
<tr class="memdesc:a52dd9d8ce80da912f64c611a67e31ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is cyclic.  <a href="#a52dd9d8ce80da912f64c611a67e31ea0">More...</a><br /></td></tr>
<tr class="separator:a52dd9d8ce80da912f64c611a67e31ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f4c1ef66238b93a2425ae8d0f50f15"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a76f4c1ef66238b93a2425ae8d0f50f15">is_implementation_type_available</a></td></tr>
<tr class="memdesc:a76f4c1ef66238b93a2425ae8d0f50f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether HFST is linked to the transducer library needed by implementation type <em>type</em>.  <a href="#a76f4c1ef66238b93a2425ae8d0f50f15">More...</a><br /></td></tr>
<tr class="separator:a76f4c1ef66238b93a2425ae8d0f50f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bc036a5cf88dcf6ce2426dbafbea98"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a98bc036a5cf88dcf6ce2426dbafbea98">is_infinitely_ambiguous</a></td></tr>
<tr class="memdesc:a98bc036a5cf88dcf6ce2426dbafbea98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is infinitely ambiguous.  <a href="#a98bc036a5cf88dcf6ce2426dbafbea98">More...</a><br /></td></tr>
<tr class="separator:a98bc036a5cf88dcf6ce2426dbafbea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58592f09e76b6823c6e049cfe87e695"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae58592f09e76b6823c6e049cfe87e695">is_lookup_infinitely_ambiguous</a></td></tr>
<tr class="memdesc:ae58592f09e76b6823c6e049cfe87e695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether lookup of path <em>input</em> will have infinite results.  <a href="#ae58592f09e76b6823c6e049cfe87e695">More...</a><br /></td></tr>
<tr class="separator:ae58592f09e76b6823c6e049cfe87e695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2699aa331e04e49dce536ffd07e84c78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2699aa331e04e49dce536ffd07e84c78">lenient_composition</a></td></tr>
<tr class="memdesc:a2699aa331e04e49dce536ffd07e84c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a lenient composition on this transducer and <em>another</em>.  <a href="#a2699aa331e04e49dce536ffd07e84c78">More...</a><br /></td></tr>
<tr class="separator:a2699aa331e04e49dce536ffd07e84c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6ca4d51f8f2ae978a89bf3bbb16172"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3b6ca4d51f8f2ae978a89bf3bbb16172">longest_path_size</a></td></tr>
<tr class="memdesc:a3b6ca4d51f8f2ae978a89bf3bbb16172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length of longest path of the transducer.  <a href="#a3b6ca4d51f8f2ae978a89bf3bbb16172">More...</a><br /></td></tr>
<tr class="separator:a3b6ca4d51f8f2ae978a89bf3bbb16172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3828090628380d5a5a2a96dbdfda241d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3828090628380d5a5a2a96dbdfda241d">lookup_optimize</a></td></tr>
<tr class="memdesc:a3828090628380d5a5a2a96dbdfda241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup string <em>input</em>.  <a href="#a3828090628380d5a5a2a96dbdfda241d">More...</a><br /></td></tr>
<tr class="separator:a3828090628380d5a5a2a96dbdfda241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf370cad739d3c4e39386e6f310e2870"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#acf370cad739d3c4e39386e6f310e2870">minimize</a></td></tr>
<tr class="memdesc:acf370cad739d3c4e39386e6f310e2870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the transducer.  <a href="#acf370cad739d3c4e39386e6f310e2870">More...</a><br /></td></tr>
<tr class="separator:acf370cad739d3c4e39386e6f310e2870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7ce4254d80f2e23b686a9ad6b087f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a5b7ce4254d80f2e23b686a9ad6b087f6">minus</a></td></tr>
<tr class="memdesc:a5b7ce4254d80f2e23b686a9ad6b087f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for subtract.  <a href="#a5b7ce4254d80f2e23b686a9ad6b087f6">More...</a><br /></td></tr>
<tr class="separator:a5b7ce4254d80f2e23b686a9ad6b087f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc45bbd4382a0ef9621814797a5997b8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#abc45bbd4382a0ef9621814797a5997b8">n_best</a></td></tr>
<tr class="memdesc:abc45bbd4382a0ef9621814797a5997b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract <em>n</em> best paths of the transducer.  <a href="#abc45bbd4382a0ef9621814797a5997b8">More...</a><br /></td></tr>
<tr class="separator:abc45bbd4382a0ef9621814797a5997b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e94151e07558a25b0da86b11df243c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab4e94151e07558a25b0da86b11df243c">number_of_arcs</a></td></tr>
<tr class="memdesc:ab4e94151e07558a25b0da86b11df243c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of transitions in the transducer.  <a href="#ab4e94151e07558a25b0da86b11df243c">More...</a><br /></td></tr>
<tr class="separator:ab4e94151e07558a25b0da86b11df243c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663e08a7fe0535fecc6b61adc65e7ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae663e08a7fe0535fecc6b61adc65e7ab">number_of_states</a></td></tr>
<tr class="memdesc:ae663e08a7fe0535fecc6b61adc65e7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of states in the transducer.  <a href="#ae663e08a7fe0535fecc6b61adc65e7ab">More...</a><br /></td></tr>
<tr class="separator:ae663e08a7fe0535fecc6b61adc65e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefeee276655e28fe8fae885f3ffc27b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#afefeee276655e28fe8fae885f3ffc27b">optionalize</a></td></tr>
<tr class="memdesc:afefeee276655e28fe8fae885f3ffc27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunct the transducer with an epsilon transducer.  <a href="#afefeee276655e28fe8fae885f3ffc27b">More...</a><br /></td></tr>
<tr class="separator:afefeee276655e28fe8fae885f3ffc27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0fcd17f7f47b4b6cdd1975914ddca3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#abe0fcd17f7f47b4b6cdd1975914ddca3">output_project</a></td></tr>
<tr class="memdesc:abe0fcd17f7f47b4b6cdd1975914ddca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the output language of the transducer.  <a href="#abe0fcd17f7f47b4b6cdd1975914ddca3">More...</a><br /></td></tr>
<tr class="separator:abe0fcd17f7f47b4b6cdd1975914ddca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e943bbc9f51af562f77807b22701cc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a89e943bbc9f51af562f77807b22701cc">priority_union</a></td></tr>
<tr class="memdesc:a89e943bbc9f51af562f77807b22701cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make priority union of this transducer with <em>another</em>.  <a href="#a89e943bbc9f51af562f77807b22701cc">More...</a><br /></td></tr>
<tr class="separator:a89e943bbc9f51af562f77807b22701cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28961be55d46c8327bee7ab02cf4158"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae28961be55d46c8327bee7ab02cf4158">prune</a></td></tr>
<tr class="memdesc:ae28961be55d46c8327bee7ab02cf4158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make transducer coaccessible.  <a href="#ae28961be55d46c8327bee7ab02cf4158">More...</a><br /></td></tr>
<tr class="separator:ae28961be55d46c8327bee7ab02cf4158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11de61d4274a048077ce049d6c5a3736"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a11de61d4274a048077ce049d6c5a3736">push_weights_to_end</a></td></tr>
<tr class="memdesc:a11de61d4274a048077ce049d6c5a3736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push weights towards final state(s).  <a href="#a11de61d4274a048077ce049d6c5a3736">More...</a><br /></td></tr>
<tr class="separator:a11de61d4274a048077ce049d6c5a3736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553c6731bf43b5bfa272f57d65437602"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a553c6731bf43b5bfa272f57d65437602">push_weights_to_start</a></td></tr>
<tr class="memdesc:a553c6731bf43b5bfa272f57d65437602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push weights towards initial state.  <a href="#a553c6731bf43b5bfa272f57d65437602">More...</a><br /></td></tr>
<tr class="separator:a553c6731bf43b5bfa272f57d65437602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1837efe45151f552e0aa0e3d6e46554"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab1837efe45151f552e0aa0e3d6e46554">remove_epsilons</a></td></tr>
<tr class="memdesc:ab1837efe45151f552e0aa0e3d6e46554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all <em>epsilon:epsilon</em> transitions from the transducer so that the resulting transducer is equivalent to the original one.  <a href="#ab1837efe45151f552e0aa0e3d6e46554">More...</a><br /></td></tr>
<tr class="separator:ab1837efe45151f552e0aa0e3d6e46554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715317a365f559eab70ef68786d5266f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a715317a365f559eab70ef68786d5266f">remove_from_alphabet</a></td></tr>
<tr class="memdesc:a715317a365f559eab70ef68786d5266f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>symbol</em> from the alphabet of the transducer.  <a href="#a715317a365f559eab70ef68786d5266f">More...</a><br /></td></tr>
<tr class="separator:a715317a365f559eab70ef68786d5266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598ac78d4f8ef34b1710da581175212"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#af598ac78d4f8ef34b1710da581175212">remove_optimization</a></td></tr>
<tr class="memdesc:af598ac78d4f8ef34b1710da581175212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove lookup optimization.  <a href="#af598ac78d4f8ef34b1710da581175212">More...</a><br /></td></tr>
<tr class="separator:af598ac78d4f8ef34b1710da581175212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012b5621cd47dac0e68bc807fd04f6ad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a012b5621cd47dac0e68bc807fd04f6ad">repeat_n</a></td></tr>
<tr class="memdesc:a012b5621cd47dac0e68bc807fd04f6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of <em>n</em> transducers.  <a href="#a012b5621cd47dac0e68bc807fd04f6ad">More...</a><br /></td></tr>
<tr class="separator:a012b5621cd47dac0e68bc807fd04f6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a9ee567dec2c22a9b32a4b31b50ddf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a01a9ee567dec2c22a9b32a4b31b50ddf">repeat_n_minus</a></td></tr>
<tr class="memdesc:a01a9ee567dec2c22a9b32a4b31b50ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from zero to <em>n</em>, inclusive.  <a href="#a01a9ee567dec2c22a9b32a4b31b50ddf">More...</a><br /></td></tr>
<tr class="separator:a01a9ee567dec2c22a9b32a4b31b50ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9105bf7ca455d35bccdd51d9eea961a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae9105bf7ca455d35bccdd51d9eea961a">repeat_n_plus</a></td></tr>
<tr class="memdesc:ae9105bf7ca455d35bccdd51d9eea961a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from <em>n</em> to infinity, inclusive.  <a href="#ae9105bf7ca455d35bccdd51d9eea961a">More...</a><br /></td></tr>
<tr class="separator:ae9105bf7ca455d35bccdd51d9eea961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd638f30eecebe295e9881fe8af931b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#acd638f30eecebe295e9881fe8af931b7">repeat_n_to_k</a></td></tr>
<tr class="memdesc:acd638f30eecebe295e9881fe8af931b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from <em>n</em> to <em>k</em>, inclusive.  <a href="#acd638f30eecebe295e9881fe8af931b7">More...</a><br /></td></tr>
<tr class="separator:acd638f30eecebe295e9881fe8af931b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e1154ed9173f6640e91f9b2619bf5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a1d9e1154ed9173f6640e91f9b2619bf5">repeat_plus</a></td></tr>
<tr class="memdesc:a1d9e1154ed9173f6640e91f9b2619bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from one to infinity.  <a href="#a1d9e1154ed9173f6640e91f9b2619bf5">More...</a><br /></td></tr>
<tr class="separator:a1d9e1154ed9173f6640e91f9b2619bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee158dd712907f51c3273c5fe501f7a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aee158dd712907f51c3273c5fe501f7a7">repeat_star</a></td></tr>
<tr class="memdesc:aee158dd712907f51c3273c5fe501f7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from zero to infinity.  <a href="#aee158dd712907f51c3273c5fe501f7a7">More...</a><br /></td></tr>
<tr class="separator:aee158dd712907f51c3273c5fe501f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac42f97131b1879f8d86d64e63883747"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aac42f97131b1879f8d86d64e63883747">reverse</a></td></tr>
<tr class="memdesc:aac42f97131b1879f8d86d64e63883747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the transducer.  <a href="#aac42f97131b1879f8d86d64e63883747">More...</a><br /></td></tr>
<tr class="separator:aac42f97131b1879f8d86d64e63883747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ecc6769c6ae17dec47f3136140b6b6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac6ecc6769c6ae17dec47f3136140b6b6">set_final_weights</a></td></tr>
<tr class="memdesc:ac6ecc6769c6ae17dec47f3136140b6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weights of all final states to <em>weight</em>.  <a href="#ac6ecc6769c6ae17dec47f3136140b6b6">More...</a><br /></td></tr>
<tr class="separator:ac6ecc6769c6ae17dec47f3136140b6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d636b72446d9cf6e6539c4e80ff52c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a26d636b72446d9cf6e6539c4e80ff52c">set_name</a></td></tr>
<tr class="memdesc:a26d636b72446d9cf6e6539c4e80ff52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the transducer <em>name</em>.  <a href="#a26d636b72446d9cf6e6539c4e80ff52c">More...</a><br /></td></tr>
<tr class="separator:a26d636b72446d9cf6e6539c4e80ff52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d09e61bf132486cb52dda0458c1f18"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a30d09e61bf132486cb52dda0458c1f18">set_property</a></td></tr>
<tr class="memdesc:a30d09e61bf132486cb52dda0458c1f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set arbitrary string property <em>property</em> to <em>value</em>.  <a href="#a30d09e61bf132486cb52dda0458c1f18">More...</a><br /></td></tr>
<tr class="separator:a30d09e61bf132486cb52dda0458c1f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d0e1994261b801a256f86850ff6744"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a44d0e1994261b801a256f86850ff6744">shuffle</a></td></tr>
<tr class="memdesc:a44d0e1994261b801a256f86850ff6744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle this transducer with transducer <em>another</em>.  <a href="#a44d0e1994261b801a256f86850ff6744">More...</a><br /></td></tr>
<tr class="separator:a44d0e1994261b801a256f86850ff6744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a90ef9779e70904842ce4a6a53ae79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#af2a90ef9779e70904842ce4a6a53ae79">substitute</a></td></tr>
<tr class="memdesc:af2a90ef9779e70904842ce4a6a53ae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute symbols or transitions in the transducer.  <a href="#af2a90ef9779e70904842ce4a6a53ae79">More...</a><br /></td></tr>
<tr class="separator:af2a90ef9779e70904842ce4a6a53ae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d6d611c60c732a8f3ff59544cb422f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a34d6d611c60c732a8f3ff59544cb422f">subtract</a></td></tr>
<tr class="memdesc:a34d6d611c60c732a8f3ff59544cb422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract transducer <em>another</em> from this transducer.  <a href="#a34d6d611c60c732a8f3ff59544cb422f">More...</a><br /></td></tr>
<tr class="separator:a34d6d611c60c732a8f3ff59544cb422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7fc40f1124fcf3f5ee7116cd62f413"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8c7fc40f1124fcf3f5ee7116cd62f413">write</a></td></tr>
<tr class="memdesc:a8c7fc40f1124fcf3f5ee7116cd62f413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in binary format to <em>ostr</em>.  <a href="#a8c7fc40f1124fcf3f5ee7116cd62f413">More...</a><br /></td></tr>
<tr class="separator:a8c7fc40f1124fcf3f5ee7116cd62f413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab6e7e21d50489a9bf805328f1eb06a37">write_att</a></td></tr>
<tr class="memdesc:ab6e7e21d50489a9bf805328f1eb06a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to file <em>f</em>, <em>write_weights</em> defined whether weights are written.  <a href="#ab6e7e21d50489a9bf805328f1eb06a37">More...</a><br /></td></tr>
<tr class="separator:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab6e7e21d50489a9bf805328f1eb06a37">write_att</a></td></tr>
<tr class="memdesc:ab6e7e21d50489a9bf805328f1eb06a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to file <em>ofile</em>, <em>write_weights</em> defines whether weights are written.  <a href="#ab6e7e21d50489a9bf805328f1eb06a37">More...</a><br /></td></tr>
<tr class="separator:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab6e7e21d50489a9bf805328f1eb06a37">write_att</a></td></tr>
<tr class="memdesc:ab6e7e21d50489a9bf805328f1eb06a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to file named <em>filename</em>.  <a href="#ab6e7e21d50489a9bf805328f1eb06a37">More...</a><br /></td></tr>
<tr class="separator:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d04f8a2cdc00a7b738994ef0c0db1de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a1d04f8a2cdc00a7b738994ef0c0db1de">write_prolog</a></td></tr>
<tr class="memdesc:a1d04f8a2cdc00a7b738994ef0c0db1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in prolog format with name <em>name</em> to file <em>f</em>, <em>write_weights</em> defined whether weights are written.  <a href="#a1d04f8a2cdc00a7b738994ef0c0db1de">More...</a><br /></td></tr>
<tr class="separator:a1d04f8a2cdc00a7b738994ef0c0db1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A synchronous finite-state transducer. </p>
<h1><a class="anchor" id="argument_handling"></a>
Argument handling</h1>
<p>Transducer functions modify their calling object and return a reference to the calling object after modification, unless otherwise mentioned. Transducer arguments are usually not modified. </p><pre class="fragment"> # transducer is reversed
 transducer.reverse()
 # transducer2 is not modified, but a copy of it is disjuncted with
 # transducer1
 transducer1.disjunct(transducer2)
 # a chain of functions is possible
 transducer.reverse().determinize().reverse().determinize()</pre><h1><a class="anchor" id="implementation_types"></a>
Implementation types</h1>
<p>Currently, an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> has three implementation types that are well supported. When an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is created, its type is defined with an argument. For functions that take a transducer as an argument, the type of the calling transducer must be the same as the type of the argument transducer: </p><pre class="fragment"> # this will cause a TransducerTypeMismatchException:
 tropical_transducer.disjunct(foma_transducer)
 # this works, but weights are lost in the conversion
 tropical_transducer.convert(hfst.ImplementationType.SFST_TYPE).disjunct(sfst_transducer)
 # this works, information is not lost
 tropical_transducer.disjunct(sfst_transducer.convert(hfst.ImplementationType.TROPICAL_OPENFST_TYPE))</pre><h1><a class="anchor" id="creating_transducers"></a>
Creating transducers</h1>
<p>With <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> constructors it is possible to create empty, epsilon, one-transition and single-path transducers. Transducers can also be created from scratch with <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">hfst.HfstBasicTransducer</a> and converted to an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. More complex transducers can be combined from simple ones with various functions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty transducer. </p>
<pre class="fragment"> tr = hfst.HfstTransducer()
 assert(tr.compare(hfst.empty_fst()))</pre> 
</div>
</div>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a deep copy of <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> <em>another</em> or a transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>another</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">another</td><td>An <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> or <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>An example:</p>
<pre class="fragment"> tr1 = hfst.regex('foo bar foo')
 tr2 = hfst.HfstTransducer(tr1)
 tr2.substitute('foo','FOO')
 tr1.concatenate(tr2)</pre> 
</div>
</div>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an HFST transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>t</em>. </p>
<p>The type of the created transducer is defined by <em>type</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the resulting transducer. If you want to use the default type, you can just call <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer(fsm)</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa7a4b9bc0941308e362738503137460e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An AT&amp;T representation of the transducer. </p>
<p>Defined for print command. An example: </p><pre class="fragment"> &gt;&gt;&gt; print(hfst.regex('[foo:bar::2]+'))
 0       1       foo     bar     2.000000
 1       1       foo     bar     2.000000
 1       0.000000</pre> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Works only for small transducers. </dd></dl>

</div>
</div>
<a class="anchor" id="abcb29cf6999377200bf19736b0e296ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compare </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this transducer and <em>another</em> are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">another</td><td>The compared transducer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>self</em> and <em>another</em> must have the same implementation type.</dd></dl>
<p>Two transducers are equivalent iff they accept the same input/output string pairs with the same weights and the same alignments. </p><dl class="section note"><dt>Note</dt><dd>For weighted transducers, the function often returns false negatives due to weight precision issues. </dd></dl>

</div>
</div>
<a class="anchor" id="a55cfee3258e73d2ddccb3901acd587dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this transducer with <em>another</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">another</td><td>The second argument in the composition. Not modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34ff54fd799851453851e2058537fc98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compose_intersect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invert</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this transducer with the intersection of transducers in <em>v</em>. </p>
<p>If <em>invert</em> is true, then compose the intersection of the transducers in <em>v</em> with this transducer.</p>
<p>The algorithm used by this function is faster than intersecting all transducers one by one and then composing this transducer with the intersection.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The transducers in <em>v</em> are deterministic and epsilon-free. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A tuple of transducers. </td></tr>
    <tr><td class="paramname">invert</td><td>Whether the intersection of the transducers in <em>v</em> is composed with this transducer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5709c296a86a1a9c9344dacc4363795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def concatenate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="a8535116b67d8bbacc28ccf338a01b0ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def conjunct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for intersect. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#aa093d24790fac4fdd9bd09080da6c276" title="Intersect this transducer with another. ">hfst.HfstTransducer.intersect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afe69e9190aa0b3889a9a5f63a42799f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def convert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the transducer into an equivalent transducer in format <em>type</em>. </p>
<p>If a weighted transducer is converted into an unweighted one, all weights are lost. In the reverse case, all weights are initialized to the semiring's one.</p>
<p>A transducer of type <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>, <a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a>, <a class="el" href="classhfst_1_1ImplementationType.html#ac6b38b4422b600ee9b8b6a6e27870102" title="An OpenFst transducer with logarithmic weights (limited support). ">hfst.ImplementationType.LOG_OPENFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> can be converted into an <a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac483b6adfb12973c57d1ba8df1cb9e78" title="An HFST optimized lookup transducer with weights. ">hfst.ImplementationType.HFST_OLW_TYPE</a> transducer, but an <a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac483b6adfb12973c57d1ba8df1cb9e78" title="An HFST optimized lookup transducer with weights. ">hfst.ImplementationType.HFST_OLW_TYPE</a> transducer cannot be converted to any other type.</p>
<dl class="section note"><dt>Note</dt><dd>For conversion between <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> and <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>, see <a class="el" href="classhfst_1_1HfstTransducer.html#ac775ee34451fdfa742b318538164070e" title="Create an empty transducer. ">hfst.HfstTransducer.__init__</a> and <a class="el" href="classhfst_1_1HfstBasicTransducer.html#ac775ee34451fdfa742b318538164070e" title="Create a transducer with one initial state that has state number zero and is not a final state...">hfst.HfstBasicTransducer.__init__</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2fa43c22b5f7af93ba8b4a56871f006a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of the transducer. </p>
<pre class="fragment"> tr = hfst.regex('[foo:bar::0.3]*')
 TR = tr.copy()
 assert(tr.compare(TR))</pre> 
</div>
</div>
<a class="anchor" id="a3771e47365316c240b605bd32f1ca6e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def cross_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make cross product of this transducer with <em>another</em>. </p>
<p>It pairs every string of this with every string of <em>another</em>. If strings are not the same length, epsilon padding will be added in the end of the shorter string. </p><dl class="section pre"><dt>Precondition</dt><dd>Both transducers must be automata, i.e. map strings onto themselves. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d993812672582affc6c5bf694cb97d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def determinize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determinize the transducer. </p>
<p>Determinizing a transducer yields an equivalent transducer that has no state with two or more transitions whose input:output symbol pairs are the same. </p>

</div>
</div>
<a class="anchor" id="a6f9dd92a3576eff0fc9f65a5c203a14a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def disjunct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunct this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="a2952ad579a13724e4bbf810d0f32b176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def eliminate_flag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminate flag diacritic <em>symbol</em> from the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The flag to be eliminated. TODO: explain more.</td></tr>
  </table>
  </dd>
</dl>
<p>An equivalent transducer with no flags <em>symbol</em>. </p>

</div>
</div>
<a class="anchor" id="a52096c13063131ad1f3f17e98799555c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def eliminate_flags </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminate flag diacritics listed in <em>symbols</em> from the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbols</td><td>The flags to be eliminated. TODO: explain more.</td></tr>
  </table>
  </dd>
</dl>
<p>An equivalent transducer with no flags listed in <em>symbols</em>. </p>

</div>
</div>
<a class="anchor" id="a376c16070c75297d2217957a3906dcb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extract_longest_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract longest paths of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A dictionary. </dd></dl>

</div>
</div>
<a class="anchor" id="adf6151029d6e4457b6a8daf67731bc06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extract_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract paths that are recognized by the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are filter_flags, max_cycles, max_number, obey_flags, output, random. </td></tr>
    <tr><td class="paramname">filter_flags</td><td>Whether flags diacritics are filtered out from the result (default True). </td></tr>
    <tr><td class="paramname">max_cycles</td><td>Indicates how many times a cycle will be followed, with negative numbers indicating unlimited (default -1 i.e. unlimited). </td></tr>
    <tr><td class="paramname">max_number</td><td>The total number of resulting strings is capped at this value, with 0 or negative indicating unlimited (default -1 i.e. unlimited). </td></tr>
    <tr><td class="paramname">obey_flags</td><td>Whether flag diacritics are validated (default True). </td></tr>
    <tr><td class="paramname">output</td><td>Output format. Values recognized: 'text', 'raw', 'dict' (the default). 'text' returns a string where paths are separated by newlines and each path is represented as input_string + ":" + output_string + "\t" t weight. 'raw' yields a tuple of all paths where each path is a 2-tuple consisting of a weight and a tuple of all transition symbol pairs, each symbol pair being a 2-tuple of an input and an output symbol. 'dict' gives a dictionary that maps each input string into a list of possible outputs, each output being a 2-tuple of an output string and a weight. </td></tr>
    <tr><td class="paramname">random</td><td>Whether result strings are fetched randomly (default False). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted strings. <em>output</em> controls how they are represented.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The transducer must be acyclic, if both <em>max_number</em> and <em>max_cycles</em> have unlimited values. Else a <a class="el" href="classhfst_1_1exceptions_1_1TransducerIsCyclicException.html" title="Transducer is cyclic. ">hfst.exceptions.TransducerIsCyclicException</a> will be thrown.</dd></dl>
<p>An example:</p>
<pre class="fragment"> &gt;&gt;&gt; tr = hfst.regex('a:b+ (a:c+)')
 &gt;&gt;&gt; print(tr)
 0       1       a       b       0.000000
 1       1       a       b       0.000000
 1       2       a       c       0.000000
 1       0.000000
 2       2       a       c       0.000000
 2       0.000000

 &gt;&gt;&gt; print(tr.extract_paths(max_cycles=1, output='text'))
 a:b     0
 aa:bb   0
 aaa:bbc 0
 aaaa:bbcc       0
 aa:bc   0
 aaa:bcc 0

 &gt;&gt;&gt; print(tr.extract_paths(max_number=4, output='text'))
 a:b     0
 aa:bc   0
 aaa:bcc 0
 aaaa:bccc       0

 &gt;&gt;&gt; print(tr.extract_paths(max_cycles=1, max_number=4, output='text'))
 a:b     0
 aa:bb   0
 aa:bc   0
 aaa:bcc 0</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">TransducerIsCyclicException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#abc45bbd4382a0ef9621814797a5997b8" title="Extract n best paths of the transducer. ">hfst.HfstTransducer.n_best</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a href="Symbols.html">Special symbols</a> are printed as such. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>a link to flag diacritics </dd></dl>

</div>
</div>
<a class="anchor" id="a4f9278f53436e9adf48cd8afbf6ec884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extract_shortest_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract shortest paths of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A dictionary. </dd></dl>

</div>
</div>
<a class="anchor" id="a57b2da59494d2e4ee4c40bf7cfc27759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the alphabet of the transducer. </p>
<p>The alphabet is defined as the set of symbols known to the transducer. </p><dl class="section return"><dt>Returns</dt><dd>A tuple of strings. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f3160d6b4e517398ca3f9e51b260bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the transducer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a26d636b72446d9cf6e6539c4e80ff52c" title="Rename the transducer name. ">set_name</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a96325faffde2dc0cf43f1c2046d92bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_properties </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all properties from the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A dictionary whose keys are properties and whose values are the values of those properties. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f8e5df587b8fd333c50077821e68875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_property </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get arbitrary string propert <em>property</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property whose value is returned. get_property('name') works like <a class="el" href="classhfst_1_1HfstTransducer.html#a2f3160d6b4e517398ca3f9e51b260bb7" title="Get the name of the transducer. ">get_name()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ef321a485de87e39ea78ebd3ba31b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The implementation type of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhfst_1_1ImplementationType.html" title="Back-end implementations. ">hfst.ImplementationType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e2f565f6d8c07e61d2a3d602cdc746d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def has_flag_diacritics </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer has flag diacritics in its transitions. </p>

</div>
</div>
<a class="anchor" id="a1f13c4bbb9c6031552a5af0a00281261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def input_project </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the input language of the transducer. </p>
<p>All transition symbol pairs <em>isymbol:osymbol</em> are changed to <em>isymbol:isymbol</em>. </p>

</div>
</div>
<a class="anchor" id="aec2b3a8aec371a00e1ee73f66768136a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def insert_freely </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freely insert a transition or a transducer into the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>The transition or transducer to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>ins</em> is a transition, i.e. a 2-tuple of strings: A transition is added to each state in this transducer. The transition leads from that state to itself with input and output symbols defined by <em>ins</em>. The weight of the transition is zero.</p>
<p>If <em>ins</em> is an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer</a>: A copy of <em>ins</em> is attached with epsilon transitions to each state of this transducer. After the operation, for each state S in this transducer, there is an epsilon transition that leads from state S to the initial state of <em>ins</em>, and for each final state of <em>ins</em>, there is an epsilon transition that leads from that final state to state S in this transducer. The weights of the final states in <em>ins</em> are copied to the epsilon transitions leading to state S. </p>

</div>
</div>
<a class="anchor" id="a8d4feafa7b9cfba0d22d67aa4d428101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def insert_to_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly insert <em>symbol</em> to the alphabet of the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol (string) to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Usually this function is not needed since new symbols are added to the alphabet by default. </dd></dl>

</div>
</div>
<a class="anchor" id="aa093d24790fac4fdd9bd09080da6c276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intersect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersect this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="a989d89a8b0795ef2f51cc60cc2e92452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def invert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the input and output symbols of each transition in the transducer. </p>

</div>
</div>
<a class="anchor" id="a6587ee3a5e0f182b520e69ec1979bb3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_automaton </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether each transition in the transducer has equivalent input and output symbols. </p>
<dl class="section note"><dt>Note</dt><dd>Transition with <a class="el" href="namespacehfst.html#a51bd2ecc765c9934d3f6396d30ace19f" title="The string for unknown symbol. ">hfst.UNKNOWN</a> on both sides IS NOT a transition with equivalent input and output symbols. </dd>
<dd>
Transition with <a class="el" href="namespacehfst.html#a3b257e90982f934e0237c0bf2671a54b" title="The string for identity symbol. ">hfst.IDENTITY</a> on both sides IS a transition with equivalent input and output symbols. </dd></dl>

</div>
</div>
<a class="anchor" id="a52dd9d8ce80da912f64c611a67e31ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_cyclic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is cyclic. </p>

</div>
</div>
<a class="anchor" id="a76f4c1ef66238b93a2425ae8d0f50f15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_implementation_type_available </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether HFST is linked to the transducer library needed by implementation type <em>type</em>. </p>

</div>
</div>
<a class="anchor" id="a98bc036a5cf88dcf6ce2426dbafbea98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is infinitely ambiguous. </p>
<p>A transducer is infinitely ambiguous if there exists an input that will yield infinitely many results, i.e. there are input epsilon loops that are traversed with that input. </p>

</div>
</div>
<a class="anchor" id="ae58592f09e76b6823c6e049cfe87e695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_lookup_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tok_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether lookup of path <em>input</em> will have infinite results. </p>
<p>Currently, this function will return whether the transducer is infinitely ambiguous on any lookup path found in the transducer, i.e. the argument <em>input</em> is ignored.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Do not ignore the argument <em>input</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a2699aa331e04e49dce536ffd07e84c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lenient_composition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a lenient composition on this transducer and <em>another</em>. </p>
<p>TODO: explain more. </p>

</div>
</div>
<a class="anchor" id="a3b6ca4d51f8f2ae978a89bf3bbb16172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def longest_path_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length of longest path of the transducer. </p>

</div>
</div>
<a class="anchor" id="a3828090628380d5a5a2a96dbdfda241d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lookup_optimize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup string <em>input</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input. A string or a pre-tokenized tuple of symbols (i.e. a tuple of strings). </td></tr>
    <tr><td class="paramname">kwargs</td><td>Possible parameters and their default values are: obey_flags=True, max_number=-1, time_cutoff=0.0, output='tuple' </td></tr>
    <tr><td class="paramname">obey_flags</td><td>Whether flag diacritics are obeyed. Always True for HFST_OL(W)_TYPE transducers. </td></tr>
    <tr><td class="paramname">max_number</td><td>Maximum number of results returned, defaults to -1, i.e. infinity. </td></tr>
    <tr><td class="paramname">time_cutoff</td><td>How long the function can search for results before returning, expressed in seconds. Defaults to 0.0, i.e. infinitely. Always 0.0 for transducers that are not of HFST_OL(W)_TYPE. </td></tr>
    <tr><td class="paramname">output</td><td>Possible values are 'tuple', 'text' and 'raw', 'tuple' being the default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has an efficient implementation only for optimized lookup format (<a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac483b6adfb12973c57d1ba8df1cb9e78" title="An HFST optimized lookup transducer with weights. ">hfst.ImplementationType.HFST_OLW_TYPE</a>). Other formats perform the lookup via composition. Consider converting the transducer to optimized lookup format or to a <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a>. Conversion to HFST_OL(W)_TYPE might take a while but the lookup is fast. Conversion to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> is quick but lookup is slower. Optimize the transducer for lookup. This effectively converts the transducer into <a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acf370cad739d3c4e39386e6f310e2870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def minimize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the transducer. </p>
<p>Minimizing a transducer yields an equivalent transducer with the smallest number of states.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>OpenFst's minimization algorithm seems to add epsilon transitions to weighted transducers? </dd></dl>

</div>
</div>
<a class="anchor" id="a5b7ce4254d80f2e23b686a9ad6b087f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def minus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for subtract. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a34d6d611c60c732a8f3ff59544cb422f" title="Subtract transducer another from this transducer. ">hfst.HfstTransducer.subtract</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc45bbd4382a0ef9621814797a5997b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def n_best </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract <em>n</em> best paths of the transducer. </p>
<p>In the case of a weighted transducer (<a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac6b38b4422b600ee9b8b6a6e27870102" title="An OpenFst transducer with logarithmic weights (limited support). ">hfst.ImplementationType.LOG_OPENFST_TYPE</a>), best paths are defined as paths with the lowest weight. In the case of an unweighted transducer (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), the function returns random paths.</p>
<p>This function is not implemented for <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>. If this function is called by an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> of type <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>, it is converted to <a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a>, paths are extracted and it is converted back to <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>. If HFST is not linked to OpenFst library, an <a class="el" href="classhfst_1_1exceptions_1_1ImplementationTypeNotAvailableException.html" title="The library required by the implementation type requested is not linked to HFST. ">hfst.exceptions.ImplementationTypeNotAvailableException</a> is thrown. </p>

</div>
</div>
<a class="anchor" id="ab4e94151e07558a25b0da86b11df243c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def number_of_arcs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of transitions in the transducer. </p>

</div>
</div>
<a class="anchor" id="ae663e08a7fe0535fecc6b61adc65e7ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def number_of_states </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of states in the transducer. </p>

</div>
</div>
<a class="anchor" id="afefeee276655e28fe8fae885f3ffc27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def optionalize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunct the transducer with an epsilon transducer. </p>

</div>
</div>
<a class="anchor" id="abe0fcd17f7f47b4b6cdd1975914ddca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def output_project </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the output language of the transducer. </p>
<p>All transition symbol pairs <em>isymbol:osymbol</em> are changed to <em>osymbol:osymbol</em>. </p>

</div>
</div>
<a class="anchor" id="a89e943bbc9f51af562f77807b22701cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def priority_union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make priority union of this transducer with <em>another</em>. </p>
<p>For the operation t1.priority_union(t2), the result is a union of t1 and t2, except that whenever t1 and t2 have the same string on left side, the path in t2 overrides the path in t1.</p>
<p>Example </p><pre class="fragment"> Transducer 1 (t1):
 a : a
 b : b

 Transducer 2 (t2):
 b : B
 c : C

 Result ( t1.priority_union(t2) ):
 a : a
 b : B
 c : C</pre><p> For more information, read <a href="http://www.fsmbook.com/">fsmbook</a>. </p>

</div>
</div>
<a class="anchor" id="ae28961be55d46c8327bee7ab02cf4158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def prune </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make transducer coaccessible. </p>
<p>A transducer is coaccessible iff there is a path from every state to a final state. </p>

</div>
</div>
<a class="anchor" id="a11de61d4274a048077ce049d6c5a3736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def push_weights_to_end </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push weights towards final state(s). </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), nothing is done.</p>
<p>An example: </p><pre class="fragment"> &gt;&gt;&gt; import hfst
 &gt;&gt;&gt; tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
 &gt;&gt;&gt; tr.push_weights_to_end()
 &gt;&gt;&gt; print(tr)
 0       1       a       a       0.000000
 1       2       a       b       0.000000
 2       3       b       b       0.000000
 2       2.000000
 3       2.000000</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a553c6731bf43b5bfa272f57d65437602" title="Push weights towards initial state. ">hfst.HfstTransducer.push_weights_to_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a553c6731bf43b5bfa272f57d65437602"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def push_weights_to_start </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push weights towards initial state. </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), nothing is done.</p>
<p>An example: </p><pre class="fragment"> &gt;&gt;&gt; import hfst
 &gt;&gt;&gt; tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
 &gt;&gt;&gt; tr.push_weights_to_start()
 &gt;&gt;&gt; print(tr)
 0       1       a       a       2.000000
 1       2       a       b       0.000000
 2       3       b       b       0.000000
 2       0.000000
 3       0.000000</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a11de61d4274a048077ce049d6c5a3736" title="Push weights towards final state(s). ">hfst.HfstTransducer.push_weights_to_end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1837efe45151f552e0aa0e3d6e46554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_epsilons </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all <em>epsilon:epsilon</em> transitions from the transducer so that the resulting transducer is equivalent to the original one. </p>

</div>
</div>
<a class="anchor" id="a715317a365f559eab70ef68786d5266f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_from_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <em>symbol</em> from the alphabet of the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol (string) to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>symbol</em> does not occur in any transition of the transducer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use with care, removing a symbol that occurs in a transition of the transducer can have unexpected results. </dd></dl>

</div>
</div>
<a class="anchor" id="af598ac78d4f8ef34b1710da581175212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_optimization </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove lookup optimization. </p>
<p>This effectively converts transducer (back) into default fst type. </p>

</div>
</div>
<a class="anchor" id="a012b5621cd47dac0e68bc807fd04f6ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of <em>n</em> transducers. </p>

</div>
</div>
<a class="anchor" id="a01a9ee567dec2c22a9b32a4b31b50ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n_minus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from zero to <em>n</em>, inclusive. </p>

</div>
</div>
<a class="anchor" id="ae9105bf7ca455d35bccdd51d9eea961a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n_plus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from <em>n</em> to infinity, inclusive. </p>

</div>
</div>
<a class="anchor" id="acd638f30eecebe295e9881fe8af931b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n_to_k </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from <em>n</em> to <em>k</em>, inclusive. </p>

</div>
</div>
<a class="anchor" id="a1d9e1154ed9173f6640e91f9b2619bf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_plus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from one to infinity. </p>

</div>
</div>
<a class="anchor" id="aee158dd712907f51c3273c5fe501f7a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_star </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from zero to infinity. </p>

</div>
</div>
<a class="anchor" id="aac42f97131b1879f8d86d64e63883747"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def reverse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the transducer. </p>
<p>A reverted transducer accepts the string 'n(0) n(1) ... n(N)' iff the original transducer accepts the string 'n(N) n(N-1) ... n(0)' </p>

</div>
</div>
<a class="anchor" id="ac6ecc6769c6ae17dec47f3136140b6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def set_final_weights </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the weights of all final states to <em>weight</em>. </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), nothing is done. </p>

</div>
</div>
<a class="anchor" id="a26d636b72446d9cf6e6539c4e80ff52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def set_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename the transducer <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the transducer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a2f3160d6b4e517398ca3f9e51b260bb7" title="Get the name of the transducer. ">get_name</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a30d09e61bf132486cb52dda0458c1f18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def set_property </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set arbitrary string property <em>property</em> to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>A string naming the property. </td></tr>
    <tr><td class="paramname">value</td><td>A string expressing the value of <em>property</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>set_property('name', 'name of the transducer') equals set_name('name of the transducer').</p>
<dl class="section note"><dt>Note</dt><dd>While this function is capable of creating endless amounts of arbitrary metadata, it is suggested that property names are drawn from central repository, or prefixed with "x-". A property that does not follow this convention may affect the behavior of transducer in future releases. </dd></dl>

</div>
</div>
<a class="anchor" id="a44d0e1994261b801a256f86850ff6744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def shuffle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle this transducer with transducer <em>another</em>. </p>
<p>If transducer A accepts string 'foo' and transducer B string 'bar', the transducer that results from shuffling A and B accepts all strings [(f|b)(o|a)(o|r)].</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both transducers must be automata, i.e. map strings onto themselves. </dd></dl>

</div>
</div>
<a class="anchor" id="af2a90ef9779e70904842ce4a6a53ae79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def substitute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute symbols or transitions in the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The symbol or transition to be substituted. Can also be a dictionary of substitutions, if S == None. </td></tr>
    <tr><td class="paramname">S</td><td>The symbol, transition, a tuple of transitions or a transducer (<a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer</a>) that substitutes <em>s</em>. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are 'input' and 'output', their values can be False or True, True being the default. These arguments are valid only if <em>s</em> and <em>S</em> are strings, else they are ignored. </td></tr>
    <tr><td class="paramname">input</td><td>Whether substitution is performed on input side, defaults to True. Valid only if <em>s</em> and <em>S</em> are strings. </td></tr>
    <tr><td class="paramname">output</td><td>Whether substitution is performed on output side, defaults to True. Valid only if <em>s</em> and \ S are strings.</td></tr>
  </table>
  </dd>
</dl>
<p>For more information, see <a class="el" href="classhfst_1_1HfstBasicTransducer.html#af2a90ef9779e70904842ce4a6a53ae79" title="Substitute symbols or transitions in the transducer. ">hfst.HfstBasicTransducer.substitute</a>. The function works similarly, with the exception of argument <em>S</em>, which must be <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer</a> instead of <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">hfst.HfstBasicTransducer</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstBasicTransducer.html#af2a90ef9779e70904842ce4a6a53ae79" title="Substitute symbols or transitions in the transducer. ">hfst.HfstBasicTransducer.substitute</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a34d6d611c60c732a8f3ff59544cb422f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def subtract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract transducer <em>another</em> from this transducer. </p>

</div>
</div>
<a class="anchor" id="a8c7fc40f1124fcf3f5ee7116cd62f413"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ostr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in binary format to <em>ostr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>A <a class="el" href="classhfst_1_1HfstOutputStream.html" title="A stream for writing binary transducers. ">hfst.HfstOutputStream</a> where the transducer is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6e7e21d50489a9bf805328f1eb06a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to file <em>f</em>, <em>write_weights</em> defined whether weights are written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A python file where transducer is written. </td></tr>
    <tr><td class="paramname">write_weights</td><td>Whether weights are written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6e7e21d50489a9bf805328f1eb06a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ofile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to file <em>ofile</em>, <em>write_weights</em> defines whether weights are written. </p>
<p>The fields in the resulting AT&amp;T format are separated by tabulator characters.</p>
<p>NOTE: If the transition symbols contain space characters,the spaces are printed as '@_SPACE_@' because whitespace characters are used as field separators in AT&amp;T format. Epsilon symbols are printed as '@0@'.</p>
<p>If several transducers are written in the same file, they must be separated by a line of two consecutive hyphens "--", so that they will be read correctly by hfst.read_att.</p>
<p>An example: </p><pre class="fragment"> tr1 = hfst.regex('[foo:bar baz:0 " "]::0.3')
 tr2 = hfst.empty_fst()
 tr3 = hfst.epsilon_fst(0.5)
 tr4 = hfst.regex('[foo]')
 tr5 = hfst.empty_fst()

 f = hfst.hfst_open('testfile.att', 'w')
 for tr in [tr1, tr2, tr3, tr4]:
     tr.write_att(f)
     f.write('--\n')
 tr5.write_att(f)
 f.close()</pre><p>This will yield a file 'testfile.att' that looks as follows: </p><pre class="fragment"> 0       1       foo     bar     0.299805
 1       2       baz     @0@     0.000000
 2       3       @_SPACE_@       @_SPACE_@       0.000000
 3       0.000000
 --
 --
 0       0.500000
 --
 0       1       foo     foo     0.000000
 1       0.000000
 --</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">StreamCannotBeWrittenException</td><td></td></tr>
    <tr><td class="paramname">StreamIsClosedException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstOutputStream.html#a8c7fc40f1124fcf3f5ee7116cd62f413" title="Write the transducer transducer in binary format to the stream. ">hfst.HfstOutputStream.write</a> </dd>
<dd>
<a class="el" href="classhfst_1_1HfstTransducer.html#ac775ee34451fdfa742b318538164070e" title="Create an empty transducer. ">hfst.HfstTransducer.__init__</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6e7e21d50489a9bf805328f1eb06a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to file named <em>filename</em>. </p>
<p><em>write_weights</em> defines whether weights are written.</p>
<p>If the file exists, it is overwritten. If the file does not exist, it is created. </p>

</div>
</div>
<a class="anchor" id="a1d04f8a2cdc00a7b738994ef0c0db1de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_prolog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in prolog format with name <em>name</em> to file <em>f</em>, <em>write_weights</em> defined whether weights are written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A python file where the transducer is written. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the transducer that must be given in a prolog file. </td></tr>
    <tr><td class="paramname">write_weights</td><td>Whether weights are written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hfst/<a class="el" href="____init_____8py.html">__init__.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2016 11:02:55 for HFST - Helsinki Finite-State Transducer Technology - Python API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
