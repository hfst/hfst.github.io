<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>HFST - Helsinki Finite-State Transducer Technology - Python API: HfstBasicTransducer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="HFST - Helsinki Finite-State Transducer Technology - Python API"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - Python API
   &#160;<span id="projectnumber">version 3.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibhfst.html">libhfst</a></li><li class="navelem"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html">HfstBasicTransducer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlibhfst_1_1HfstBasicTransducer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HfstBasicTransducer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple transducer class with tropical weights.  
 <a href="classlibhfst_1_1HfstBasicTransducer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26046a1c3dcefa7c500975d3a7409d13"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a26046a1c3dcefa7c500975d3a7409d13">__enumerate__</a></td></tr>
<tr class="memdesc:a26046a1c3dcefa7c500975d3a7409d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an enumeration of the states and transitions of the transducer.  <a href="#a26046a1c3dcefa7c500975d3a7409d13">More...</a><br /></td></tr>
<tr class="separator:a26046a1c3dcefa7c500975d3a7409d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775ee34451fdfa742b318538164070e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr class="memdesc:ac775ee34451fdfa742b318538164070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transducer with one initial state that has state number zero and is not a final state, i.e.  <a href="#ac775ee34451fdfa742b318538164070e">More...</a><br /></td></tr>
<tr class="separator:ac775ee34451fdfa742b318538164070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775ee34451fdfa742b318538164070e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr class="memdesc:ac775ee34451fdfa742b318538164070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transducer equivalent to <em>transducer</em>.  <a href="#ac775ee34451fdfa742b318538164070e">More...</a><br /></td></tr>
<tr class="separator:ac775ee34451fdfa742b318538164070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a4b9bc0941308e362738503137460e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#aa7a4b9bc0941308e362738503137460e">__str__</a></td></tr>
<tr class="memdesc:aa7a4b9bc0941308e362738503137460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representation of the transducer.  <a href="#aa7a4b9bc0941308e362738503137460e">More...</a><br /></td></tr>
<tr class="separator:aa7a4b9bc0941308e362738503137460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc1ecc2a0c1fd83a1475b5fe02409d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#adcc1ecc2a0c1fd83a1475b5fe02409d7">add_state</a></td></tr>
<tr class="memdesc:adcc1ecc2a0c1fd83a1475b5fe02409d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new state to this transducer and return its number.  <a href="#adcc1ecc2a0c1fd83a1475b5fe02409d7">More...</a><br /></td></tr>
<tr class="separator:adcc1ecc2a0c1fd83a1475b5fe02409d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc1ecc2a0c1fd83a1475b5fe02409d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#adcc1ecc2a0c1fd83a1475b5fe02409d7">add_state</a></td></tr>
<tr class="memdesc:adcc1ecc2a0c1fd83a1475b5fe02409d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a state <em>s</em> to this graph.  <a href="#adcc1ecc2a0c1fd83a1475b5fe02409d7">More...</a><br /></td></tr>
<tr class="separator:adcc1ecc2a0c1fd83a1475b5fe02409d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9093720a83c5146a43c55b46810d621d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a9093720a83c5146a43c55b46810d621d">add_symbol_to_alphabet</a></td></tr>
<tr class="memdesc:a9093720a83c5146a43c55b46810d621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly add <em>symbol</em> to the alphabet of the graph.  <a href="#a9093720a83c5146a43c55b46810d621d">More...</a><br /></td></tr>
<tr class="separator:a9093720a83c5146a43c55b46810d621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698bc6bb7bad256c5c3e88bb16c4d9bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a698bc6bb7bad256c5c3e88bb16c4d9bf">add_symbols_to_alphabet</a></td></tr>
<tr class="memdesc:a698bc6bb7bad256c5c3e88bb16c4d9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly add <em>symbols</em> to the alphabet of the graph.  <a href="#a698bc6bb7bad256c5c3e88bb16c4d9bf">More...</a><br /></td></tr>
<tr class="separator:a698bc6bb7bad256c5c3e88bb16c4d9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a88e125b9201382c975a4019363809b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a7a88e125b9201382c975a4019363809b">add_transition</a></td></tr>
<tr class="memdesc:a7a88e125b9201382c975a4019363809b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a transition <em>transition</em> to state <em>state</em>, <em>add_symbols_to_alphabet</em> defines whether the transition symbols are added to the alphabet.  <a href="#a7a88e125b9201382c975a4019363809b">More...</a><br /></td></tr>
<tr class="separator:a7a88e125b9201382c975a4019363809b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a88e125b9201382c975a4019363809b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a7a88e125b9201382c975a4019363809b">add_transition</a></td></tr>
<tr class="memdesc:a7a88e125b9201382c975a4019363809b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a transition from state <em>source</em> to state <em>target</em> with input symbol <em>input</em>, output symbol <em>output</em> and weight <em>weight</em>.  <a href="#a7a88e125b9201382c975a4019363809b">More...</a><br /></td></tr>
<tr class="separator:a7a88e125b9201382c975a4019363809b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9dd92a3576eff0fc9f65a5c203a14a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a6f9dd92a3576eff0fc9f65a5c203a14a">disjunct</a></td></tr>
<tr class="memdesc:a6f9dd92a3576eff0fc9f65a5c203a14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunct this transducer with a one-path transducer defined by consecutive string pairs in <em>spv</em> that has weight <em>weight</em>.  <a href="#a6f9dd92a3576eff0fc9f65a5c203a14a">More...</a><br /></td></tr>
<tr class="separator:a6f9dd92a3576eff0fc9f65a5c203a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b2da59494d2e4ee4c40bf7cfc27759"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a57b2da59494d2e4ee4c40bf7cfc27759">get_alphabet</a></td></tr>
<tr class="memdesc:a57b2da59494d2e4ee4c40bf7cfc27759"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symbols in the alphabet of the transducer.  <a href="#a57b2da59494d2e4ee4c40bf7cfc27759">More...</a><br /></td></tr>
<tr class="separator:a57b2da59494d2e4ee4c40bf7cfc27759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27343a773bd895e8291d0b9160aafb05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a27343a773bd895e8291d0b9160aafb05">get_final_weight</a></td></tr>
<tr class="memdesc:a27343a773bd895e8291d0b9160aafb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final weight of state <em>state</em> in this transducer.  <a href="#a27343a773bd895e8291d0b9160aafb05">More...</a><br /></td></tr>
<tr class="separator:a27343a773bd895e8291d0b9160aafb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d5de88c5c43829eefcfa3349f9e73a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a52d5de88c5c43829eefcfa3349f9e73a">get_max_state</a></td></tr>
<tr class="memdesc:a52d5de88c5c43829eefcfa3349f9e73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the biggest state number in use.  <a href="#a52d5de88c5c43829eefcfa3349f9e73a">More...</a><br /></td></tr>
<tr class="separator:a52d5de88c5c43829eefcfa3349f9e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e04e52540f2bfdc8e4add4db37dac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a362e04e52540f2bfdc8e4add4db37dac">get_transition_pairs</a></td></tr>
<tr class="memdesc:a362e04e52540f2bfdc8e4add4db37dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all input/output symbol pairs used in the transitions of this transducer.  <a href="#a362e04e52540f2bfdc8e4add4db37dac">More...</a><br /></td></tr>
<tr class="separator:a362e04e52540f2bfdc8e4add4db37dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91ca58da0682db5faa3b107d5407cc3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#aa91ca58da0682db5faa3b107d5407cc3">harmonize</a></td></tr>
<tr class="memdesc:aa91ca58da0682db5faa3b107d5407cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonize this transducer and <em>another</em>.  <a href="#aa91ca58da0682db5faa3b107d5407cc3">More...</a><br /></td></tr>
<tr class="separator:aa91ca58da0682db5faa3b107d5407cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2b3a8aec371a00e1ee73f66768136a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#aec2b3a8aec371a00e1ee73f66768136a">insert_freely</a></td></tr>
<tr class="memdesc:aec2b3a8aec371a00e1ee73f66768136a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert freely any number of <em>symbol_pair</em> in the transducer with weight <em>weight</em>.  <a href="#aec2b3a8aec371a00e1ee73f66768136a">More...</a><br /></td></tr>
<tr class="separator:aec2b3a8aec371a00e1ee73f66768136a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2b3a8aec371a00e1ee73f66768136a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#aec2b3a8aec371a00e1ee73f66768136a">insert_freely</a></td></tr>
<tr class="memdesc:aec2b3a8aec371a00e1ee73f66768136a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert freely any number of <em>transducer</em> in this transducer.  <a href="#aec2b3a8aec371a00e1ee73f66768136a">More...</a><br /></td></tr>
<tr class="separator:aec2b3a8aec371a00e1ee73f66768136a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad736e1fb0a523f0e3864e1fe5d3cce9a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ad736e1fb0a523f0e3864e1fe5d3cce9a">is_final_state</a></td></tr>
<tr class="memdesc:ad736e1fb0a523f0e3864e1fe5d3cce9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether state <em>state</em> is final.  <a href="#ad736e1fb0a523f0e3864e1fe5d3cce9a">More...</a><br /></td></tr>
<tr class="separator:ad736e1fb0a523f0e3864e1fe5d3cce9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bc036a5cf88dcf6ce2426dbafbea98"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a98bc036a5cf88dcf6ce2426dbafbea98">is_infinitely_ambiguous</a></td></tr>
<tr class="memdesc:a98bc036a5cf88dcf6ce2426dbafbea98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is infinitely ambiguous.  <a href="#a98bc036a5cf88dcf6ce2426dbafbea98">More...</a><br /></td></tr>
<tr class="separator:a98bc036a5cf88dcf6ce2426dbafbea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58592f09e76b6823c6e049cfe87e695"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ae58592f09e76b6823c6e049cfe87e695">is_lookup_infinitely_ambiguous</a></td></tr>
<tr class="memdesc:ae58592f09e76b6823c6e049cfe87e695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is infinitely ambiguous with input <em>str</em>.  <a href="#ae58592f09e76b6823c6e049cfe87e695">More...</a><br /></td></tr>
<tr class="separator:ae58592f09e76b6823c6e049cfe87e695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6ca4d51f8f2ae978a89bf3bbb16172"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a3b6ca4d51f8f2ae978a89bf3bbb16172">longest_path_size</a></td></tr>
<tr class="memdesc:a3b6ca4d51f8f2ae978a89bf3bbb16172"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of the longest path in transducer.  <a href="#a3b6ca4d51f8f2ae978a89bf3bbb16172">More...</a><br /></td></tr>
<tr class="separator:a3b6ca4d51f8f2ae978a89bf3bbb16172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b6cef9852ebbd72cd3aa0150d65fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ae92b6cef9852ebbd72cd3aa0150d65fe">lookup_fd</a></td></tr>
<tr class="memdesc:ae92b6cef9852ebbd72cd3aa0150d65fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup tokenized input <em>input</em> in the transducer minding flag diacritics.  <a href="#ae92b6cef9852ebbd72cd3aa0150d65fe">More...</a><br /></td></tr>
<tr class="separator:ae92b6cef9852ebbd72cd3aa0150d65fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865e5a522b27b8bc43346997a322d70d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a865e5a522b27b8bc43346997a322d70d">prune_alphabet</a></td></tr>
<tr class="memdesc:a865e5a522b27b8bc43346997a322d70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all symbols that do not occur in transitions of the transducer from its alphabet.  <a href="#a865e5a522b27b8bc43346997a322d70d">More...</a><br /></td></tr>
<tr class="separator:a865e5a522b27b8bc43346997a322d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dc102bdc973ae48cd54bb08247417c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ac4dc102bdc973ae48cd54bb08247417c">read_att</a></td></tr>
<tr class="memdesc:ac4dc102bdc973ae48cd54bb08247417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a transducer in AT&amp;T format from file <em>f</em>.  <a href="#ac4dc102bdc973ae48cd54bb08247417c">More...</a><br /></td></tr>
<tr class="separator:ac4dc102bdc973ae48cd54bb08247417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcfb5390d1ff54bbc4e71342142b17c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#aadcfb5390d1ff54bbc4e71342142b17c">read_prolog</a></td></tr>
<tr class="memdesc:aadcfb5390d1ff54bbc4e71342142b17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a transducer from prolog file <em>f</em>.  <a href="#aadcfb5390d1ff54bbc4e71342142b17c">More...</a><br /></td></tr>
<tr class="separator:aadcfb5390d1ff54bbc4e71342142b17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a30068f13d4205be2d4410aa9a8c5b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a76a30068f13d4205be2d4410aa9a8c5b">remove_symbol_from_alphabet</a></td></tr>
<tr class="memdesc:a76a30068f13d4205be2d4410aa9a8c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove symbol <em>symbol</em> from the alphabet of the graph.  <a href="#a76a30068f13d4205be2d4410aa9a8c5b">More...</a><br /></td></tr>
<tr class="separator:a76a30068f13d4205be2d4410aa9a8c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e7d57ecd74ba43948b7eee8427305b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a81e7d57ecd74ba43948b7eee8427305b">remove_symbols_from_alphabet</a></td></tr>
<tr class="memdesc:a81e7d57ecd74ba43948b7eee8427305b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove symbols <em>symbols</em> from the alphabet of the graph.  <a href="#a81e7d57ecd74ba43948b7eee8427305b">More...</a><br /></td></tr>
<tr class="separator:a81e7d57ecd74ba43948b7eee8427305b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef86a470bfe2954e26e860b8be81e32"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a5ef86a470bfe2954e26e860b8be81e32">remove_transition</a></td></tr>
<tr class="memdesc:a5ef86a470bfe2954e26e860b8be81e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove transition <em>transition</em> from state <em>s</em>.  <a href="#a5ef86a470bfe2954e26e860b8be81e32">More...</a><br /></td></tr>
<tr class="separator:a5ef86a470bfe2954e26e860b8be81e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848fdd87cbd0ad78db781393eb798165"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a848fdd87cbd0ad78db781393eb798165">set_final_weight</a></td></tr>
<tr class="memdesc:a848fdd87cbd0ad78db781393eb798165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the final weight of state <em>state</em> in this transducer to <em>weight</em>.  <a href="#a848fdd87cbd0ad78db781393eb798165">More...</a><br /></td></tr>
<tr class="separator:a848fdd87cbd0ad78db781393eb798165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5b9753b6be7bcf31c085b27fc1d081"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a0c5b9753b6be7bcf31c085b27fc1d081">sort_arcs</a></td></tr>
<tr class="memdesc:a0c5b9753b6be7bcf31c085b27fc1d081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the arcs of this transducer according to input and output symbols.  <a href="#a0c5b9753b6be7bcf31c085b27fc1d081">More...</a><br /></td></tr>
<tr class="separator:a0c5b9753b6be7bcf31c085b27fc1d081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef79adff5ef1573e4781f0ad34b3b79f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#aef79adff5ef1573e4781f0ad34b3b79f">states</a></td></tr>
<tr class="memdesc:aef79adff5ef1573e4781f0ad34b3b79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The states of the transducer.  <a href="#aef79adff5ef1573e4781f0ad34b3b79f">More...</a><br /></td></tr>
<tr class="separator:aef79adff5ef1573e4781f0ad34b3b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63109ea44fe308ee8f60c8cb3b284e82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a63109ea44fe308ee8f60c8cb3b284e82">states_and_transitions</a></td></tr>
<tr class="memdesc:a63109ea44fe308ee8f60c8cb3b284e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The states and transitions of the transducer.  <a href="#a63109ea44fe308ee8f60c8cb3b284e82">More...</a><br /></td></tr>
<tr class="separator:a63109ea44fe308ee8f60c8cb3b284e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a90ef9779e70904842ce4a6a53ae79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#af2a90ef9779e70904842ce4a6a53ae79">substitute</a></td></tr>
<tr class="memdesc:af2a90ef9779e70904842ce4a6a53ae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute symbols or transitions in the transducer.  <a href="#af2a90ef9779e70904842ce4a6a53ae79">More...</a><br /></td></tr>
<tr class="separator:af2a90ef9779e70904842ce4a6a53ae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4bff31b49da9de3b8979ac02faa943"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a7a4bff31b49da9de3b8979ac02faa943">symbols_used</a></td></tr>
<tr class="memdesc:a7a4bff31b49da9de3b8979ac02faa943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all symbols used in the transitions of this transducer.  <a href="#a7a4bff31b49da9de3b8979ac02faa943">More...</a><br /></td></tr>
<tr class="separator:a7a4bff31b49da9de3b8979ac02faa943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f069f8a2b5d801d71a5a818dc0905f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ad0f069f8a2b5d801d71a5a818dc0905f">transitions</a></td></tr>
<tr class="memdesc:ad0f069f8a2b5d801d71a5a818dc0905f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transitions of state <em>state</em> in this transducer.  <a href="#ad0f069f8a2b5d801d71a5a818dc0905f">More...</a><br /></td></tr>
<tr class="separator:ad0f069f8a2b5d801d71a5a818dc0905f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#ab6e7e21d50489a9bf805328f1eb06a37">write_att</a></td></tr>
<tr class="memdesc:ab6e7e21d50489a9bf805328f1eb06a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write this transducer in AT&amp;T format to file <em>f</em>, <em>write_weights</em> defines whether weights are written.  <a href="#ab6e7e21d50489a9bf805328f1eb06a37">More...</a><br /></td></tr>
<tr class="separator:ab6e7e21d50489a9bf805328f1eb06a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d04f8a2cdc00a7b738994ef0c0db1de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a1d04f8a2cdc00a7b738994ef0c0db1de">write_prolog</a></td></tr>
<tr class="memdesc:a1d04f8a2cdc00a7b738994ef0c0db1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in prolog format to file <em>f</em>.  <a href="#a1d04f8a2cdc00a7b738994ef0c0db1de">More...</a><br /></td></tr>
<tr class="separator:a1d04f8a2cdc00a7b738994ef0c0db1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbd76fe483bf6c5e544ba79d6769db2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#acbbd76fe483bf6c5e544ba79d6769db2">write_xfst</a></td></tr>
<tr class="memdesc:acbbd76fe483bf6c5e544ba79d6769db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in xfst format to file <em>f</em>.  <a href="#acbbd76fe483bf6c5e544ba79d6769db2">More...</a><br /></td></tr>
<tr class="separator:acbbd76fe483bf6c5e544ba79d6769db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A simple transducer class with tropical weights. </p>
<p>An example of creating an <a class="el" href="classlibhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> [foo:bar baz:baz] with weight 0.4 from scratch:</p>
<pre class="fragment">  # Create an empty transducer
  # The transducer has initially one start state (number zero) 
  # that is not final
  fsm = libhfst.HfstBasicTransducer()
  # Add two states to the transducer
  fsm.add_state(1)
  fsm.add_state(2)
  # Create a transition [foo:bar] leading to state 1 with weight 0.1
  tr = libhfst.HfstBasicTransition(1, 'foo', 'bar', 0.1)
  # and add it to state zero
  fsm.add_transition(0, tr)
  # Add a transition [baz:baz] with weight 0 from state 1 to state 2 
  fsm.add_transition(1, libhfst.HfstBasicTransition(2, 'baz', 'baz', 0.0))
  # Set state 2 as final with weight 0.3
  fsm.set_final_weight(2, 0.3)</pre><p>An example of iterating through the states and transitions of the above transducer when printing them in AT&amp;T format to standard output:</p>
<pre class="fragment">  # Go through all states
  for state, arcs in enumerate(fsm):
    for arc in arcs:
      print('%i ' % (state), end='')
      print(arc)
    if fsm.is_final_state(state):
      print('%i %f' % (state, fsm.get_final_weight(state)) )</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibhfst_1_1HfstBasicTransition.html" title="A transition class that consists of a target state, input and output symbols and a a tropical weight...">libhfst.HfstBasicTransition</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transducer with one initial state that has state number zero and is not a final state, i.e. </p>
<p>create an empty transducer. </p>

</div>
</div>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transducer equivalent to <em>transducer</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transducer</td><td>The transducer to be copied, <a class="el" href="classlibhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">libhfst.HfstBasicTransducer</a> or <a class="el" href="classlibhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">libhfst.HfstTransducer</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a26046a1c3dcefa7c500975d3a7409d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __enumerate__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an enumeration of the states and transitions of the transducer. </p>
<pre class="fragment"> for state, arcs in enumerate(fsm):
   for arc in arcs:
     print('%i ' % (state), end='')
     print(arc)
   if fsm.is_final_state(state):
     print('%i %f' % (state, fsm.get_final_weight(state)) )</pre> 
</div>
</div>
<a class="anchor" id="aa7a4b9bc0941308e362738503137460e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a string representation of the transducer. </p>
<pre class="fragment"> print(fsm)</pre> 
</div>
</div>
<a class="anchor" id="adcc1ecc2a0c1fd83a1475b5fe02409d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def add_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new state to this transducer and return its number. </p>
<dl class="section return"><dt>Returns</dt><dd>The next (smallest) free state number. </dd></dl>

</div>
</div>
<a class="anchor" id="adcc1ecc2a0c1fd83a1475b5fe02409d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def add_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a state <em>s</em> to this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The number of the state to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>state</em> </dd></dl>
<p>If the state already exists, it is not added again. All states with state number smaller than <em>s</em> are also added to the transducer if they did not exist before. </p>

</div>
</div>
<a class="anchor" id="a9093720a83c5146a43c55b46810d621d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def add_symbol_to_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly add <em>symbol</em> to the alphabet of the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Usually the user does not have to take care of the alphabet of a graph. This function can be useful in some special cases. @ param symbol The string to be added. </dd></dl>

</div>
</div>
<a class="anchor" id="a698bc6bb7bad256c5c3e88bb16c4d9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def add_symbols_to_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly add <em>symbols</em> to the alphabet of the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Usually the user does not have to take care of the alphabet of a graph. This function can be useful in some special cases. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbols</td><td>A tuple of strings to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a88e125b9201382c975a4019363809b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def add_transition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_symbols_to_alphabet</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a transition <em>transition</em> to state <em>state</em>, <em>add_symbols_to_alphabet</em> defines whether the transition symbols are added to the alphabet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The number of the state where the transition is added. If it does not exist, it is created. </td></tr>
    <tr><td class="paramname">transition</td><td>A <a class="el" href="classlibhfst_1_1HfstBasicTransition.html" title="A transition class that consists of a target state, input and output symbols and a a tropical weight...">libhfst.HfstBasicTransition</a> that is added to <em>state</em>. </td></tr>
    <tr><td class="paramname">add_symbols_to_alphabet</td><td>Whether the transition symbols are added to the alphabet of the transducer. (In special cases this is not wanted.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a88e125b9201382c975a4019363809b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def add_transition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a transition from state <em>source</em> to state <em>target</em> with input symbol <em>input</em>, output symbol <em>output</em> and weight <em>weight</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The number of the state where the transition is added. If it does not exist, it is created. </td></tr>
    <tr><td class="paramname">target</td><td>The number of the state where the transition leads. If it does not exist, it is created. (?) </td></tr>
    <tr><td class="paramname">input</td><td>The input symbol of the transition. </td></tr>
    <tr><td class="paramname">output</td><td>The output symbol of the transition. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight of the transition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f9dd92a3576eff0fc9f65a5c203a14a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def disjunct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stringpairpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunct this transducer with a one-path transducer defined by consecutive string pairs in <em>spv</em> that has weight <em>weight</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph must be a trie where all weights are in final states, i.e. all transitions have a zero weight.</dd></dl>
<p>There is no way to test whether a graph is a trie, so the use of this function is probably limited to fast construction of a lexicon. Here is an example:</p>
<pre class="fragment"> lexicon = libhfst.HfstBasicTransducer()
 tok = libhfst.HfstTokenizer()
 lexicon.disjunct(tok.tokenize('dog'), 0.3)
 lexicon.disjunct(tok.tokenize('cat'), 0.5)
 lexicon.disjunct(tok.tokenize('elephant'), 1.6)</pre> 
</div>
</div>
<a class="anchor" id="a57b2da59494d2e4ee4c40bf7cfc27759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The symbols in the alphabet of the transducer. </p>
<p>The symbols do not necessarily occur in any transitions of the transducer. Epsilon, unknown and identity symbols are always included in the alphabet. </p><dl class="section return"><dt>Returns</dt><dd>A tuple of strings. </dd></dl>

</div>
</div>
<a class="anchor" id="a27343a773bd895e8291d0b9160aafb05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_final_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the final weight of state <em>state</em> in this transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The number of the state. If it does not exist, a <a class="el" href="classlibhfst_1_1StateIsNotFinalException.html" title="State is not final (and cannot have a final weight). ">StateIsNotFinalException</a> is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">libhfst.StateIsNotFinalException.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52d5de88c5c43829eefcfa3349f9e73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_max_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the biggest state number in use. </p>
<dl class="section return"><dt>Returns</dt><dd>The biggest state number in use. </dd></dl>

</div>
</div>
<a class="anchor" id="a362e04e52540f2bfdc8e4add4db37dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_transition_pairs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of all input/output symbol pairs used in the transitions of this transducer. </p>

</div>
</div>
<a class="anchor" id="aa91ca58da0682db5faa3b107d5407cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def harmonize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonize this transducer and <em>another</em>. </p>
<p>In harmonization the unknown and identity symbols in transitions of both graphs are expanded according to the symbols that are previously unknown to the graph.</p>
<p>For example the graphs </p><pre class="fragment"> [a:b ?:?]
 [c:d ? ?:c]</pre><p> are expanded to </p><pre class="fragment"> [ a:b [?:? | ?:c | ?:d | c:d | d:c | c:? | d:?] ]
 [ c:d [? | a | b] [?:c| a:c | b:?] ]</pre><p> when harmonized.</p>
<p>The symbol '?' means <a class="el" href="namespacelibhfst.html#a51bd2ecc765c9934d3f6396d30ace19f" title="The string for unknown symbol. ">libhfst.UNKNOWN</a> in either or both sides of a transition (transitions of type [?:x], [x:?] and [?:?]). The transition [?] means <a class="el" href="namespacelibhfst.html#a3b257e90982f934e0237c0bf2671a54b" title="The string for identity symbol. ">libhfst.IDENTITY</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is always called for all transducer arguments of functions that take two or more graphs as their arguments, unless otherwise said. </dd></dl>

</div>
</div>
<a class="anchor" id="aec2b3a8aec371a00e1ee73f66768136a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def insert_freely </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert freely any number of <em>symbol_pair</em> in the transducer with weight <em>weight</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol_pair</td><td>A string pair to be inserted. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight of the inserted symbol pair. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec2b3a8aec371a00e1ee73f66768136a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def insert_freely </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert freely any number of <em>transducer</em> in this transducer. </p>
<p>param transducer An <a class="el" href="classlibhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> to be inserted. </p>

</div>
</div>
<a class="anchor" id="ad736e1fb0a523f0e3864e1fe5d3cce9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_final_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether state <em>state</em> is final. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state whose finality is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98bc036a5cf88dcf6ce2426dbafbea98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is infinitely ambiguous. </p>
<p>A transducer is infinitely ambiguous if there exists an input that will yield infinitely many results, i.e. there are input epsilon loops that are traversed with that input. </p>

</div>
</div>
<a class="anchor" id="ae58592f09e76b6823c6e049cfe87e695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_lookup_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is infinitely ambiguous with input <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input.</td></tr>
  </table>
  </dd>
</dl>
<p>A transducer is infinitely ambiguous with a given input if the input yields infinitely many results, i.e. there are input epsilon loops that are traversed with the input. </p>

</div>
</div>
<a class="anchor" id="a3b6ca4d51f8f2ae978a89bf3bbb16172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def longest_path_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The length of the longest path in transducer. </p>
<p>Length of a path means number of arcs on that path. </p>

</div>
</div>
<a class="anchor" id="ae92b6cef9852ebbd72cd3aa0150d65fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lookup_fd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kvargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup tokenized input <em>input</em> in the transducer minding flag diacritics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A list/tuple of strings to look up. </td></tr>
    <tr><td class="paramname">kvargs</td><td>infinite_cutoff=-1, max_weight=None </td></tr>
    <tr><td class="paramname">infinite_cutoff</td><td>Defaults to -1, i.e. infinite. </td></tr>
    <tr><td class="paramname">max_weight</td><td>Defaults to None, i.e. infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a865e5a522b27b8bc43346997a322d70d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def prune_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all symbols that do not occur in transitions of the transducer from its alphabet. </p>
<p>Epsilon, unknown and identity symbols are always included in the alphabet. </p>

</div>
</div>
<a class="anchor" id="ac4dc102bdc973ae48cd54bb08247417c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def read_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>epsilon_symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linecount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a transducer in AT&amp;T format from file <em>f</em>. </p>
<p><em>epsilon_symbol</em> defines the symbol used for epsilon, <em>linecount</em> is incremented as lines are read. </p><dl class="section return"><dt>Returns</dt><dd>A transducer constructed by reading from file <em>file</em>. This function is a static one. </dd></dl>

</div>
</div>
<a class="anchor" id="aadcfb5390d1ff54bbc4e71342142b17c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def read_prolog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linecount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a transducer from prolog file <em>f</em>. </p>
<p><em>linecount</em> is incremented as lines are read (is it in python?). </p><dl class="section return"><dt>Returns</dt><dd>A transducer constructed by reading from file <em>file</em>. This function is a static one. </dd></dl>

</div>
</div>
<a class="anchor" id="a76a30068f13d4205be2d4410aa9a8c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_symbol_from_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove symbol <em>symbol</em> from the alphabet of the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Use with care, removing symbols that occur in the transitions of the graph can have unexpected results. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The string to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81e7d57ecd74ba43948b7eee8427305b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_symbols_from_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove symbols <em>symbols</em> from the alphabet of the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Use with care, removing symbols that occur in the transitions of the graph can have unexpected results. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbols</td><td>A tuple of strings to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ef86a470bfe2954e26e860b8be81e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_transition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remove_symbols_from_alphabet</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove transition <em>transition</em> from state <em>s</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The state which <em>transition</em> belongs to. </td></tr>
    <tr><td class="paramname">transition</td><td>The transition to be removed. </td></tr>
    <tr><td class="paramname">remove_symbols_from_alphabet</td><td>(?) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a848fdd87cbd0ad78db781393eb798165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def set_final_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the final weight of state <em>state</em> in this transducer to <em>weight</em>. </p>
<p>If the state does not exist, it is created. </p>

</div>
</div>
<a class="anchor" id="a0c5b9753b6be7bcf31c085b27fc1d081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def sort_arcs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the arcs of this transducer according to input and output symbols. </p>
<dl class="section return"><dt>Returns</dt><dd>This transducer. </dd></dl>

</div>
</div>
<a class="anchor" id="aef79adff5ef1573e4781f0ad34b3b79f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def states </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The states of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A tuple of state numbers.</dd></dl>
<p>An example: /verbatim for state in fsm.states(): for arc in fsm.transitions(state): print('i ' % (state), end='') print(arc) if fsm.is_final_state(state): print('i f' % (state, fsm.get_final_weight(state)) ) /endverbatim </p>

</div>
</div>
<a class="anchor" id="a63109ea44fe308ee8f60c8cb3b284e82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def states_and_transitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The states and transitions of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A tuple of tuples of HfstBasicTransitions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibhfst_1_1HfstBasicTransducer.html#a26046a1c3dcefa7c500975d3a7409d13" title="Return an enumeration of the states and transitions of the transducer. ">libhfst.HfstBasicTransducer.__enumerate__</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af2a90ef9779e70904842ce4a6a53ae79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def substitute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kvargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute symbols or transitions in the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The symbol or transition to be substituted. Can also be a dictionary of substitutions, if S == None. </td></tr>
    <tr><td class="paramname">S</td><td>The symbol, transition, a tuple of transitions or a transducer (<a class="el" href="classlibhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">libhfst.HfstBasicTransducer</a>) that substitutes <em>s</em>. </td></tr>
    <tr><td class="paramname">kvargs</td><td>Arguments recognized are 'input' and 'output', their values can be False or True, True being the default. These arguments are valid only if <em>s</em> and <em>S</em> are strings, else they are ignored. </td></tr>
    <tr><td class="paramname">input</td><td>Whether substitution is performed on input side, defaults to True. Valid only if <em>s</em> and <em>S</em> are strings. </td></tr>
    <tr><td class="paramname">output</td><td>Whether substitution is performed on output side, defaults to True. Valid only if <em>s</em> and <em>S</em> are strings.</td></tr>
  </table>
  </dd>
</dl>
<p>Possible combinations of arguments and their types are:</p>
<p>(1) substitute(str, str, input=bool, output=bool): substitute symbol with symbol on input, output or both sides of each transition in the transducer. (2) substitute(strpair, strpair): substitute transition with transition (3) substitute(strpair, strpairtuple): substitute transition with several transitions (4) substitute(strpair, transducer): substitute transition with a transducer (5) substitute(dict): perform several symbol-to-symbol substitutions (6) substitute(dict): perform several transition-to-transition substitutions</p>
<p>Examples:</p>
<p>(1) tr.substitute('a', 'A', input=True, output=False): substitute lowercase a:s with uppercase ones (2) tr.substitute(('a','b'),('A','B')): substitute transitions that map lowercase a into lowercase b with transitions that map uppercase a into uppercase b (3) tr.substitute(('a','b'), (('A','B'),('a','B'),('A','b'))): change either or both sides of a transition [a:b] to uppercase (4) tr.substitute(('a','b'), <a class="el" href="namespacelibhfst.html#a2611f16a0c0596d4564ce42149a8ba86" title="Get a transducer as defined by regular expression regexp. ">libhfst.regex</a>('[a:b]+')) change [a:b] transition into one or more consecutive [a:b] transitions (5) tr.substitute({'a':'A', 'b':'B', 'c':'C'}) change lowercase a, b and c into their uppercase variants (6) tr.substitute( {('a','a'):('A','A'), ('b','b'):('B','B'), ('c','c'):('C','C')} ): change lowercase a, b and c into their uppercase variants</p>
<p>In case (4), epsilon transitions are used to attach copies of transducer <em>S</em> between the SOURCE and TARGET state of each transition that is substituted. The transition itself is deleted, but its weight is copied to the epsilon transition leading from SOURCE to the initial state of <em>S</em>. Each final state of <em>S</em> is made non-final and an epsilon transition leading to TARGET is attached to it. The final weight is copied to the epsilon transition. </p>

</div>
</div>
<a class="anchor" id="a7a4bff31b49da9de3b8979ac02faa943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def symbols_used </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of all symbols used in the transitions of this transducer. </p>

</div>
</div>
<a class="anchor" id="ad0f069f8a2b5d801d71a5a818dc0905f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def transitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transitions of state <em>state</em> in this transducer. </p>
<p>If the state does not exist, a <em><a class="el" href="classlibhfst_1_1StateIndexOutOfBoundsException.html" title="The state number argument is not valid. ">StateIndexOutOfBoundsException</a></em> is thrown. </p><dl class="section return"><dt>Returns</dt><dd>A tuple of HfstBasicTransitions.</dd></dl>
<pre class="fragment"> for state in fsm.states():
 for arc in fsm.transitions(state):
     print('%i ' % (state), end='')
     print(arc)
 if fsm.is_final_state(state):
    print('%i %f' % (state, fsm.get_final_weight(state)) )</pre> 
</div>
</div>
<a class="anchor" id="ab6e7e21d50489a9bf805328f1eb06a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write this transducer in AT&amp;T format to file <em>f</em>, <em>write_weights</em> defines whether weights are written. </p>

</div>
</div>
<a class="anchor" id="a1d04f8a2cdc00a7b738994ef0c0db1de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_prolog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in prolog format to file <em>f</em>. </p>
<p>Name the transducer <em>name</em>. </p>

</div>
</div>
<a class="anchor" id="acbbd76fe483bf6c5e544ba79d6769db2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_xfst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in xfst format to file <em>f</em>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="libhfst_8py.html">libhfst.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 19 2016 16:45:01 for HFST - Helsinki Finite-State Transducer Technology - Python API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
