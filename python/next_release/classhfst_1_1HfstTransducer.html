<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HFST - Helsinki Finite-State Transducer Technology - Python API: HfstTransducer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - Python API
   &#160;<span id="projectnumber">version 3.12.3 (under development)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehfst.html">hfst</a></li><li class="navelem"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhfst_1_1HfstTransducer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HfstTransducer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A synchronous finite-state transducer.  
 <a href="classhfst_1_1HfstTransducer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae64f0875afe3067b97ba370b354b9213"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae64f0875afe3067b97ba370b354b9213">__init__</a> (self)</td></tr>
<tr class="memdesc:ae64f0875afe3067b97ba370b354b9213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty transducer.  <a href="#ae64f0875afe3067b97ba370b354b9213">More...</a><br /></td></tr>
<tr class="separator:ae64f0875afe3067b97ba370b354b9213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5d0768e995f79324ada67326e24324"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ace5d0768e995f79324ada67326e24324">__init__</a> (self, another)</td></tr>
<tr class="memdesc:ace5d0768e995f79324ada67326e24324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> <em>another</em> or a transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>another</em>.  <a href="#ace5d0768e995f79324ada67326e24324">More...</a><br /></td></tr>
<tr class="separator:ace5d0768e995f79324ada67326e24324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fcc97ee04ca2992dcf510a311edb0d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a60fcc97ee04ca2992dcf510a311edb0d">__init__</a> (self, t, type)</td></tr>
<tr class="memdesc:a60fcc97ee04ca2992dcf510a311edb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an HFST transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>t</em>.  <a href="#a60fcc97ee04ca2992dcf510a311edb0d">More...</a><br /></td></tr>
<tr class="separator:a60fcc97ee04ca2992dcf510a311edb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e8041ce1015febe4fdace3225714f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a23e8041ce1015febe4fdace3225714f9">__str__</a> (self)</td></tr>
<tr class="memdesc:a23e8041ce1015febe4fdace3225714f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AT&amp;T representation of the transducer.  <a href="#a23e8041ce1015febe4fdace3225714f9">More...</a><br /></td></tr>
<tr class="separator:a23e8041ce1015febe4fdace3225714f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c401a4558a2119398d13f82d5ca720"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a38c401a4558a2119398d13f82d5ca720">compare</a> (self, another)</td></tr>
<tr class="memdesc:a38c401a4558a2119398d13f82d5ca720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this transducer and <em>another</em> are equivalent.  <a href="#a38c401a4558a2119398d13f82d5ca720">More...</a><br /></td></tr>
<tr class="separator:a38c401a4558a2119398d13f82d5ca720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b5c758eb99dc9e29c23c61f0fee9bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ad2b5c758eb99dc9e29c23c61f0fee9bf">compose</a> (self, another)</td></tr>
<tr class="memdesc:ad2b5c758eb99dc9e29c23c61f0fee9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this transducer with <em>another</em>.  <a href="#ad2b5c758eb99dc9e29c23c61f0fee9bf">More...</a><br /></td></tr>
<tr class="separator:ad2b5c758eb99dc9e29c23c61f0fee9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708343dbb05d960b7821b1e42a96d09d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a708343dbb05d960b7821b1e42a96d09d">compose_intersect</a> (self, v, <a class="el" href="classhfst_1_1HfstTransducer.html#a81367fa3878493d399477bdcd669f90a">invert</a>=False)</td></tr>
<tr class="memdesc:a708343dbb05d960b7821b1e42a96d09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose this transducer with the intersection of transducers in <em>v</em>.  <a href="#a708343dbb05d960b7821b1e42a96d09d">More...</a><br /></td></tr>
<tr class="separator:a708343dbb05d960b7821b1e42a96d09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76de872dbf5b970e8d299044ed20be9d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a76de872dbf5b970e8d299044ed20be9d">concatenate</a> (self, another)</td></tr>
<tr class="memdesc:a76de872dbf5b970e8d299044ed20be9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate this transducer with <em>another</em>.  <a href="#a76de872dbf5b970e8d299044ed20be9d">More...</a><br /></td></tr>
<tr class="separator:a76de872dbf5b970e8d299044ed20be9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b0d88e97832028c1f9b5744c4482b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ad98b0d88e97832028c1f9b5744c4482b">conjunct</a> (self, another)</td></tr>
<tr class="memdesc:ad98b0d88e97832028c1f9b5744c4482b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for intersect.  <a href="#ad98b0d88e97832028c1f9b5744c4482b">More...</a><br /></td></tr>
<tr class="separator:ad98b0d88e97832028c1f9b5744c4482b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23cbf79d7a7dd1604e29cec2a057878"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae23cbf79d7a7dd1604e29cec2a057878">convert</a> (self, type, options='')</td></tr>
<tr class="memdesc:ae23cbf79d7a7dd1604e29cec2a057878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the transducer into an equivalent transducer in format <em>type</em>.  <a href="#ae23cbf79d7a7dd1604e29cec2a057878">More...</a><br /></td></tr>
<tr class="separator:ae23cbf79d7a7dd1604e29cec2a057878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf6261b742ae694c16790726a8c77c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aebf6261b742ae694c16790726a8c77c5">copy</a> (self)</td></tr>
<tr class="memdesc:aebf6261b742ae694c16790726a8c77c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of the transducer.  <a href="#aebf6261b742ae694c16790726a8c77c5">More...</a><br /></td></tr>
<tr class="separator:aebf6261b742ae694c16790726a8c77c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae087cf82d6f773cc52b7e0cec911726a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae087cf82d6f773cc52b7e0cec911726a">cross_product</a> (self, another)</td></tr>
<tr class="memdesc:ae087cf82d6f773cc52b7e0cec911726a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make cross product of this transducer with <em>another</em>.  <a href="#ae087cf82d6f773cc52b7e0cec911726a">More...</a><br /></td></tr>
<tr class="separator:ae087cf82d6f773cc52b7e0cec911726a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad767ca32f0f0fa6940a513ecb8d1c725"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ad767ca32f0f0fa6940a513ecb8d1c725">determinize</a> (self)</td></tr>
<tr class="memdesc:ad767ca32f0f0fa6940a513ecb8d1c725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinize the transducer.  <a href="#ad767ca32f0f0fa6940a513ecb8d1c725">More...</a><br /></td></tr>
<tr class="separator:ad767ca32f0f0fa6940a513ecb8d1c725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88db6c55177ad7f29da4d27c51f645d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a88db6c55177ad7f29da4d27c51f645d6">disjunct</a> (self, another)</td></tr>
<tr class="memdesc:a88db6c55177ad7f29da4d27c51f645d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunct this transducer with <em>another</em>.  <a href="#a88db6c55177ad7f29da4d27c51f645d6">More...</a><br /></td></tr>
<tr class="separator:a88db6c55177ad7f29da4d27c51f645d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14b42f0c57e1e89d05353dfb6c9483a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#af14b42f0c57e1e89d05353dfb6c9483a">eliminate_flag</a> (self, symbol)</td></tr>
<tr class="memdesc:af14b42f0c57e1e89d05353dfb6c9483a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate flag diacritic <em>symbol</em> from the transducer.  <a href="#af14b42f0c57e1e89d05353dfb6c9483a">More...</a><br /></td></tr>
<tr class="separator:af14b42f0c57e1e89d05353dfb6c9483a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcef97a45bf3fd350cd19e79da917fe9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#afcef97a45bf3fd350cd19e79da917fe9">eliminate_flags</a> (self, symbols)</td></tr>
<tr class="memdesc:afcef97a45bf3fd350cd19e79da917fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate flag diacritics listed in <em>symbols</em> from the transducer.  <a href="#afcef97a45bf3fd350cd19e79da917fe9">More...</a><br /></td></tr>
<tr class="separator:afcef97a45bf3fd350cd19e79da917fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac7ffd38743271b525e85f26217398b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a9ac7ffd38743271b525e85f26217398b">extract_longest_paths</a> (self, kwargs)</td></tr>
<tr class="memdesc:a9ac7ffd38743271b525e85f26217398b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract longest paths of the transducer.  <a href="#a9ac7ffd38743271b525e85f26217398b">More...</a><br /></td></tr>
<tr class="separator:a9ac7ffd38743271b525e85f26217398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f12f946bcc935795d48960cf8850e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a864f12f946bcc935795d48960cf8850e">extract_paths</a> (self, kwargs)</td></tr>
<tr class="memdesc:a864f12f946bcc935795d48960cf8850e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract paths that are recognized by the transducer.  <a href="#a864f12f946bcc935795d48960cf8850e">More...</a><br /></td></tr>
<tr class="separator:a864f12f946bcc935795d48960cf8850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a44813804643b56525724273e4638e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a07a44813804643b56525724273e4638e">extract_shortest_paths</a> (self)</td></tr>
<tr class="memdesc:a07a44813804643b56525724273e4638e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract shortest paths of the transducer.  <a href="#a07a44813804643b56525724273e4638e">More...</a><br /></td></tr>
<tr class="separator:a07a44813804643b56525724273e4638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e18faca5cb09062bcef65e75ab2ba29"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8e18faca5cb09062bcef65e75ab2ba29">get_alphabet</a> (self)</td></tr>
<tr class="memdesc:a8e18faca5cb09062bcef65e75ab2ba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the alphabet of the transducer.  <a href="#a8e18faca5cb09062bcef65e75ab2ba29">More...</a><br /></td></tr>
<tr class="separator:a8e18faca5cb09062bcef65e75ab2ba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13ea075e8de9101d02c0316ccb2ce79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae13ea075e8de9101d02c0316ccb2ce79">get_name</a> (self)</td></tr>
<tr class="memdesc:ae13ea075e8de9101d02c0316ccb2ce79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the transducer.  <a href="#ae13ea075e8de9101d02c0316ccb2ce79">More...</a><br /></td></tr>
<tr class="separator:ae13ea075e8de9101d02c0316ccb2ce79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bac1b337deef561b8808accc82f1ad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#af0bac1b337deef561b8808accc82f1ad">get_properties</a> (self)</td></tr>
<tr class="memdesc:af0bac1b337deef561b8808accc82f1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all properties from the transducer.  <a href="#af0bac1b337deef561b8808accc82f1ad">More...</a><br /></td></tr>
<tr class="separator:af0bac1b337deef561b8808accc82f1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c8f127eca03e8fb34b44ffda5bca34"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae7c8f127eca03e8fb34b44ffda5bca34">get_property</a> (self, property)</td></tr>
<tr class="memdesc:ae7c8f127eca03e8fb34b44ffda5bca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get arbitrary string propert <em>property</em>.  <a href="#ae7c8f127eca03e8fb34b44ffda5bca34">More...</a><br /></td></tr>
<tr class="separator:ae7c8f127eca03e8fb34b44ffda5bca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1001d7b7b0e48724593b0a4334ca1b4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a1001d7b7b0e48724593b0a4334ca1b4e">get_type</a> (self)</td></tr>
<tr class="memdesc:a1001d7b7b0e48724593b0a4334ca1b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation type of the transducer.  <a href="#a1001d7b7b0e48724593b0a4334ca1b4e">More...</a><br /></td></tr>
<tr class="separator:a1001d7b7b0e48724593b0a4334ca1b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe034a1fee501b58ad82a40225bcc7b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a7fe034a1fee501b58ad82a40225bcc7b">has_flag_diacritics</a> (self)</td></tr>
<tr class="memdesc:a7fe034a1fee501b58ad82a40225bcc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer has flag diacritics in its transitions.  <a href="#a7fe034a1fee501b58ad82a40225bcc7b">More...</a><br /></td></tr>
<tr class="separator:a7fe034a1fee501b58ad82a40225bcc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599ccc41d74d4d138d1472c86f761151"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a599ccc41d74d4d138d1472c86f761151">input_project</a> (self)</td></tr>
<tr class="memdesc:a599ccc41d74d4d138d1472c86f761151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the input language of the transducer.  <a href="#a599ccc41d74d4d138d1472c86f761151">More...</a><br /></td></tr>
<tr class="separator:a599ccc41d74d4d138d1472c86f761151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcb3bb3892b2ecbbb7aa01169f194d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aafcb3bb3892b2ecbbb7aa01169f194d8">insert_freely</a> (self, ins)</td></tr>
<tr class="memdesc:aafcb3bb3892b2ecbbb7aa01169f194d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freely insert a transition or a transducer into the transducer.  <a href="#aafcb3bb3892b2ecbbb7aa01169f194d8">More...</a><br /></td></tr>
<tr class="separator:aafcb3bb3892b2ecbbb7aa01169f194d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201c47a00472ac3168fd0bf52fa5d53a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a201c47a00472ac3168fd0bf52fa5d53a">insert_to_alphabet</a> (self, symbol)</td></tr>
<tr class="memdesc:a201c47a00472ac3168fd0bf52fa5d53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly insert <em>symbol</em> to the alphabet of the transducer.  <a href="#a201c47a00472ac3168fd0bf52fa5d53a">More...</a><br /></td></tr>
<tr class="separator:a201c47a00472ac3168fd0bf52fa5d53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7b9b634adc0510fce694d413c6fee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8be7b9b634adc0510fce694d413c6fee">intersect</a> (self, another)</td></tr>
<tr class="memdesc:a8be7b9b634adc0510fce694d413c6fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect this transducer with <em>another</em>.  <a href="#a8be7b9b634adc0510fce694d413c6fee">More...</a><br /></td></tr>
<tr class="separator:a8be7b9b634adc0510fce694d413c6fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81367fa3878493d399477bdcd669f90a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a81367fa3878493d399477bdcd669f90a">invert</a> (self)</td></tr>
<tr class="memdesc:a81367fa3878493d399477bdcd669f90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the input and output symbols of each transition in the transducer.  <a href="#a81367fa3878493d399477bdcd669f90a">More...</a><br /></td></tr>
<tr class="separator:a81367fa3878493d399477bdcd669f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ea2a6e45493b9f1291ce0898865f4b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#af4ea2a6e45493b9f1291ce0898865f4b">is_automaton</a> (self)</td></tr>
<tr class="memdesc:af4ea2a6e45493b9f1291ce0898865f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether each transition in the transducer has equivalent input and output symbols.  <a href="#af4ea2a6e45493b9f1291ce0898865f4b">More...</a><br /></td></tr>
<tr class="separator:af4ea2a6e45493b9f1291ce0898865f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9452d8d02395b50649219dd0efe0b4c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab9452d8d02395b50649219dd0efe0b4c">is_cyclic</a> (self)</td></tr>
<tr class="memdesc:ab9452d8d02395b50649219dd0efe0b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is cyclic.  <a href="#ab9452d8d02395b50649219dd0efe0b4c">More...</a><br /></td></tr>
<tr class="separator:ab9452d8d02395b50649219dd0efe0b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd28323c37f2fe35a1b47e64757d55"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3cdd28323c37f2fe35a1b47e64757d55">is_implementation_type_available</a> (type)</td></tr>
<tr class="memdesc:a3cdd28323c37f2fe35a1b47e64757d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether HFST is linked to the transducer library needed by implementation type <em>type</em>.  <a href="#a3cdd28323c37f2fe35a1b47e64757d55">More...</a><br /></td></tr>
<tr class="separator:a3cdd28323c37f2fe35a1b47e64757d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb2414b94924b588e296f82aefed272"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#acfb2414b94924b588e296f82aefed272">is_infinitely_ambiguous</a> (self)</td></tr>
<tr class="memdesc:acfb2414b94924b588e296f82aefed272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transducer is infinitely ambiguous.  <a href="#acfb2414b94924b588e296f82aefed272">More...</a><br /></td></tr>
<tr class="separator:acfb2414b94924b588e296f82aefed272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edfebc58029006dbfaf68fadcac9bab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3edfebc58029006dbfaf68fadcac9bab">is_lookup_infinitely_ambiguous</a> (self, tok_input)</td></tr>
<tr class="memdesc:a3edfebc58029006dbfaf68fadcac9bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether lookup of path <em>input</em> will have infinite results.  <a href="#a3edfebc58029006dbfaf68fadcac9bab">More...</a><br /></td></tr>
<tr class="separator:a3edfebc58029006dbfaf68fadcac9bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a6c997abe4c521f646de4da70effb6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab4a6c997abe4c521f646de4da70effb6">lenient_composition</a> (self, another)</td></tr>
<tr class="memdesc:ab4a6c997abe4c521f646de4da70effb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a lenient composition on this transducer and <em>another</em>.  <a href="#ab4a6c997abe4c521f646de4da70effb6">More...</a><br /></td></tr>
<tr class="separator:ab4a6c997abe4c521f646de4da70effb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6bbc0bd4b23c28e0dcac4c7e300eb6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ade6bbc0bd4b23c28e0dcac4c7e300eb6">longest_path_size</a> (self, kwargs)</td></tr>
<tr class="memdesc:ade6bbc0bd4b23c28e0dcac4c7e300eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length of longest path of the transducer.  <a href="#ade6bbc0bd4b23c28e0dcac4c7e300eb6">More...</a><br /></td></tr>
<tr class="separator:ade6bbc0bd4b23c28e0dcac4c7e300eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b12c93eabc7fc6a47eecb62d6884a68"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2b12c93eabc7fc6a47eecb62d6884a68">lookup_optimize</a> (self)</td></tr>
<tr class="memdesc:a2b12c93eabc7fc6a47eecb62d6884a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup string <em>input</em>.  <a href="#a2b12c93eabc7fc6a47eecb62d6884a68">More...</a><br /></td></tr>
<tr class="separator:a2b12c93eabc7fc6a47eecb62d6884a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef71bbd44f8b37500ffa115b9231349"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a1ef71bbd44f8b37500ffa115b9231349">minimize</a> (self)</td></tr>
<tr class="memdesc:a1ef71bbd44f8b37500ffa115b9231349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the transducer.  <a href="#a1ef71bbd44f8b37500ffa115b9231349">More...</a><br /></td></tr>
<tr class="separator:a1ef71bbd44f8b37500ffa115b9231349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21be58472a1264bdf81446da6fac2ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa21be58472a1264bdf81446da6fac2ba">minus</a> (self, another)</td></tr>
<tr class="memdesc:aa21be58472a1264bdf81446da6fac2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for subtract.  <a href="#aa21be58472a1264bdf81446da6fac2ba">More...</a><br /></td></tr>
<tr class="separator:aa21be58472a1264bdf81446da6fac2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ca204d2689e04b4d834d73038e8488"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a56ca204d2689e04b4d834d73038e8488">n_best</a> (self, n)</td></tr>
<tr class="memdesc:a56ca204d2689e04b4d834d73038e8488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract <em>n</em> best paths of the transducer.  <a href="#a56ca204d2689e04b4d834d73038e8488">More...</a><br /></td></tr>
<tr class="separator:a56ca204d2689e04b4d834d73038e8488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcfb8b43a1445f2dc523e2ac73e1ef1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3dcfb8b43a1445f2dc523e2ac73e1ef1">number_of_arcs</a> (self)</td></tr>
<tr class="memdesc:a3dcfb8b43a1445f2dc523e2ac73e1ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of transitions in the transducer.  <a href="#a3dcfb8b43a1445f2dc523e2ac73e1ef1">More...</a><br /></td></tr>
<tr class="separator:a3dcfb8b43a1445f2dc523e2ac73e1ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ca2fa35e7bb080b5a35e8a645158b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ad7ca2fa35e7bb080b5a35e8a645158b5">number_of_states</a> (self)</td></tr>
<tr class="memdesc:ad7ca2fa35e7bb080b5a35e8a645158b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of states in the transducer.  <a href="#ad7ca2fa35e7bb080b5a35e8a645158b5">More...</a><br /></td></tr>
<tr class="separator:ad7ca2fa35e7bb080b5a35e8a645158b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf7d785013483e25d7353bcdf03d16d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aacf7d785013483e25d7353bcdf03d16d">optionalize</a> (self)</td></tr>
<tr class="memdesc:aacf7d785013483e25d7353bcdf03d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjunct the transducer with an epsilon transducer.  <a href="#aacf7d785013483e25d7353bcdf03d16d">More...</a><br /></td></tr>
<tr class="separator:aacf7d785013483e25d7353bcdf03d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e8f740ae5bedfc22cfaa7f2e007566"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ad5e8f740ae5bedfc22cfaa7f2e007566">output_project</a> (self)</td></tr>
<tr class="memdesc:ad5e8f740ae5bedfc22cfaa7f2e007566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the output language of the transducer.  <a href="#ad5e8f740ae5bedfc22cfaa7f2e007566">More...</a><br /></td></tr>
<tr class="separator:ad5e8f740ae5bedfc22cfaa7f2e007566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b04cb4acd1d71d114026c4962828f07"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a0b04cb4acd1d71d114026c4962828f07">priority_union</a> (self, another)</td></tr>
<tr class="memdesc:a0b04cb4acd1d71d114026c4962828f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make priority union of this transducer with <em>another</em>.  <a href="#a0b04cb4acd1d71d114026c4962828f07">More...</a><br /></td></tr>
<tr class="separator:a0b04cb4acd1d71d114026c4962828f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5c3005fa6de766d043ed3c52b27a19"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#afc5c3005fa6de766d043ed3c52b27a19">prune</a> (self)</td></tr>
<tr class="memdesc:afc5c3005fa6de766d043ed3c52b27a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make transducer coaccessible.  <a href="#afc5c3005fa6de766d043ed3c52b27a19">More...</a><br /></td></tr>
<tr class="separator:afc5c3005fa6de766d043ed3c52b27a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9debb84f56d27bdcf1b221ce17b0d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aad9debb84f56d27bdcf1b221ce17b0d0">push_weights_to_end</a> (self)</td></tr>
<tr class="memdesc:aad9debb84f56d27bdcf1b221ce17b0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push weights towards final state(s).  <a href="#aad9debb84f56d27bdcf1b221ce17b0d0">More...</a><br /></td></tr>
<tr class="separator:aad9debb84f56d27bdcf1b221ce17b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb198318cdad30f55f344fb6feb20374"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#abb198318cdad30f55f344fb6feb20374">push_weights_to_start</a> (self)</td></tr>
<tr class="memdesc:abb198318cdad30f55f344fb6feb20374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push weights towards initial state.  <a href="#abb198318cdad30f55f344fb6feb20374">More...</a><br /></td></tr>
<tr class="separator:abb198318cdad30f55f344fb6feb20374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6ece45b9a0ad857fb0294419896ec4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a2d6ece45b9a0ad857fb0294419896ec4">remove_epsilons</a> (self)</td></tr>
<tr class="memdesc:a2d6ece45b9a0ad857fb0294419896ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all <em>epsilon:epsilon</em> transitions from the transducer so that the resulting transducer is equivalent to the original one.  <a href="#a2d6ece45b9a0ad857fb0294419896ec4">More...</a><br /></td></tr>
<tr class="separator:a2d6ece45b9a0ad857fb0294419896ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bc1d1d4f9a6002888d8501799e1573"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a88bc1d1d4f9a6002888d8501799e1573">remove_from_alphabet</a> (self, symbol)</td></tr>
<tr class="memdesc:a88bc1d1d4f9a6002888d8501799e1573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>symbol</em> from the alphabet of the transducer.  <a href="#a88bc1d1d4f9a6002888d8501799e1573">More...</a><br /></td></tr>
<tr class="separator:a88bc1d1d4f9a6002888d8501799e1573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d92b9c093bb86b4fc56e1874b3d621a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a0d92b9c093bb86b4fc56e1874b3d621a">remove_optimization</a> (self)</td></tr>
<tr class="memdesc:a0d92b9c093bb86b4fc56e1874b3d621a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove lookup optimization.  <a href="#a0d92b9c093bb86b4fc56e1874b3d621a">More...</a><br /></td></tr>
<tr class="separator:a0d92b9c093bb86b4fc56e1874b3d621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaf770b28b9b24aab6e03ef8efdb55a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#abdaf770b28b9b24aab6e03ef8efdb55a">repeat_n</a> (self, n)</td></tr>
<tr class="memdesc:abdaf770b28b9b24aab6e03ef8efdb55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of <em>n</em> transducers.  <a href="#abdaf770b28b9b24aab6e03ef8efdb55a">More...</a><br /></td></tr>
<tr class="separator:abdaf770b28b9b24aab6e03ef8efdb55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab355e95028e8923f8a3c386aab1c7470"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab355e95028e8923f8a3c386aab1c7470">repeat_n_minus</a> (self, n)</td></tr>
<tr class="memdesc:ab355e95028e8923f8a3c386aab1c7470"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from zero to <em>n</em>, inclusive.  <a href="#ab355e95028e8923f8a3c386aab1c7470">More...</a><br /></td></tr>
<tr class="separator:ab355e95028e8923f8a3c386aab1c7470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ffbf1d270362c99698c0769c5594b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ac2ffbf1d270362c99698c0769c5594b9">repeat_n_plus</a> (self, n)</td></tr>
<tr class="memdesc:ac2ffbf1d270362c99698c0769c5594b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from <em>n</em> to infinity, inclusive.  <a href="#ac2ffbf1d270362c99698c0769c5594b9">More...</a><br /></td></tr>
<tr class="separator:ac2ffbf1d270362c99698c0769c5594b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d30dffa979f55681e6f002f4ac1422a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3d30dffa979f55681e6f002f4ac1422a">repeat_n_to_k</a> (self, n, k)</td></tr>
<tr class="memdesc:a3d30dffa979f55681e6f002f4ac1422a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from <em>n</em> to <em>k</em>, inclusive.  <a href="#a3d30dffa979f55681e6f002f4ac1422a">More...</a><br /></td></tr>
<tr class="separator:a3d30dffa979f55681e6f002f4ac1422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae5f0f4a450a584de527a3a8b067a04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a8ae5f0f4a450a584de527a3a8b067a04">repeat_plus</a> (self)</td></tr>
<tr class="memdesc:a8ae5f0f4a450a584de527a3a8b067a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from one to infinity.  <a href="#a8ae5f0f4a450a584de527a3a8b067a04">More...</a><br /></td></tr>
<tr class="separator:a8ae5f0f4a450a584de527a3a8b067a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54432a0b887e88067e5fb6f6fe52ac83"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a54432a0b887e88067e5fb6f6fe52ac83">repeat_star</a> (self)</td></tr>
<tr class="memdesc:a54432a0b887e88067e5fb6f6fe52ac83"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concatenation of N transducers where N is any number from zero to infinity.  <a href="#a54432a0b887e88067e5fb6f6fe52ac83">More...</a><br /></td></tr>
<tr class="separator:a54432a0b887e88067e5fb6f6fe52ac83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7def94945e05b11b4a98b276d8b372b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a7def94945e05b11b4a98b276d8b372b7">reverse</a> (self)</td></tr>
<tr class="memdesc:a7def94945e05b11b4a98b276d8b372b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the transducer.  <a href="#a7def94945e05b11b4a98b276d8b372b7">More...</a><br /></td></tr>
<tr class="separator:a7def94945e05b11b4a98b276d8b372b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a3155e2d11ecce6f6bdcbad8ab78d3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa7a3155e2d11ecce6f6bdcbad8ab78d3">set_final_weights</a> (self, weight)</td></tr>
<tr class="memdesc:aa7a3155e2d11ecce6f6bdcbad8ab78d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weights of all final states to <em>weight</em>.  <a href="#aa7a3155e2d11ecce6f6bdcbad8ab78d3">More...</a><br /></td></tr>
<tr class="separator:aa7a3155e2d11ecce6f6bdcbad8ab78d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4289b7f9eec09cb6e166c568d28b7521"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a4289b7f9eec09cb6e166c568d28b7521">set_name</a> (self, name)</td></tr>
<tr class="memdesc:a4289b7f9eec09cb6e166c568d28b7521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the transducer <em>name</em>.  <a href="#a4289b7f9eec09cb6e166c568d28b7521">More...</a><br /></td></tr>
<tr class="separator:a4289b7f9eec09cb6e166c568d28b7521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1d566ba462a21ec9f55c037577a7b1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a3b1d566ba462a21ec9f55c037577a7b1">set_property</a> (self, property, value)</td></tr>
<tr class="memdesc:a3b1d566ba462a21ec9f55c037577a7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set arbitrary string property <em>property</em> to <em>value</em>.  <a href="#a3b1d566ba462a21ec9f55c037577a7b1">More...</a><br /></td></tr>
<tr class="separator:a3b1d566ba462a21ec9f55c037577a7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ea73b7c585398d4a054107ecda0e33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a92ea73b7c585398d4a054107ecda0e33">shuffle</a> (self, another)</td></tr>
<tr class="memdesc:a92ea73b7c585398d4a054107ecda0e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle this transducer with transducer <em>another</em>.  <a href="#a92ea73b7c585398d4a054107ecda0e33">More...</a><br /></td></tr>
<tr class="separator:a92ea73b7c585398d4a054107ecda0e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30178efca5dcd21c56ac3d5c39abbff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ae30178efca5dcd21c56ac3d5c39abbff">substitute</a> (self, s, S=None, kwargs)</td></tr>
<tr class="memdesc:ae30178efca5dcd21c56ac3d5c39abbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute symbols or transitions in the transducer.  <a href="#ae30178efca5dcd21c56ac3d5c39abbff">More...</a><br /></td></tr>
<tr class="separator:ae30178efca5dcd21c56ac3d5c39abbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429afd8003e218241f4c338dd86b4713"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a429afd8003e218241f4c338dd86b4713">subtract</a> (self, another)</td></tr>
<tr class="memdesc:a429afd8003e218241f4c338dd86b4713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract transducer <em>another</em> from this transducer.  <a href="#a429afd8003e218241f4c338dd86b4713">More...</a><br /></td></tr>
<tr class="separator:a429afd8003e218241f4c338dd86b4713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bdf204c40983207546c4c14cb2c061"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a93bdf204c40983207546c4c14cb2c061">write</a> (self, ostr)</td></tr>
<tr class="memdesc:a93bdf204c40983207546c4c14cb2c061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in binary format to <em>ostr</em>.  <a href="#a93bdf204c40983207546c4c14cb2c061">More...</a><br /></td></tr>
<tr class="separator:a93bdf204c40983207546c4c14cb2c061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c39f9aeba79a81843b68c224c6afb9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#ab2c39f9aeba79a81843b68c224c6afb9">write_att</a> (self, f, write_weights=True)</td></tr>
<tr class="memdesc:ab2c39f9aeba79a81843b68c224c6afb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to file <em>f</em>, <em>write_weights</em> defined whether weights are written.  <a href="#ab2c39f9aeba79a81843b68c224c6afb9">More...</a><br /></td></tr>
<tr class="separator:ab2c39f9aeba79a81843b68c224c6afb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10de411e227b166597217ba56f87bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a6d10de411e227b166597217ba56f87bc">write_att</a> (self, ofile, write_weights=True)</td></tr>
<tr class="memdesc:a6d10de411e227b166597217ba56f87bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to file <em>ofile</em>, <em>write_weights</em> defines whether weights are written.  <a href="#a6d10de411e227b166597217ba56f87bc">More...</a><br /></td></tr>
<tr class="separator:a6d10de411e227b166597217ba56f87bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6421f14914a6421d9af6dc64ac566a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#aa6421f14914a6421d9af6dc64ac566a9">write_att</a> (self, filename, write_weights=True)</td></tr>
<tr class="memdesc:aa6421f14914a6421d9af6dc64ac566a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in AT&amp;T format to file named <em>filename</em>.  <a href="#aa6421f14914a6421d9af6dc64ac566a9">More...</a><br /></td></tr>
<tr class="separator:aa6421f14914a6421d9af6dc64ac566a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a690cb253c892938fb06e3863057b4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html#a90a690cb253c892938fb06e3863057b4">write_prolog</a> (self, f, name, write_weights=True)</td></tr>
<tr class="memdesc:a90a690cb253c892938fb06e3863057b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the transducer in prolog format with name <em>name</em> to file <em>f</em>, <em>write_weights</em> defined whether weights are written.  <a href="#a90a690cb253c892938fb06e3863057b4">More...</a><br /></td></tr>
<tr class="separator:a90a690cb253c892938fb06e3863057b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A synchronous finite-state transducer. </p>
<h1><a class="anchor" id="argument_handling"></a>
Argument handling</h1>
<p>Transducer functions modify their calling object and return a reference to the calling object after modification, unless otherwise mentioned. Transducer arguments are usually not modified. </p><pre class="fragment"> # transducer is reversed
 transducer.reverse()
 # transducer2 is not modified, but a copy of it is disjuncted with
 # transducer1
 transducer1.disjunct(transducer2)
 # a chain of functions is possible
 transducer.reverse().determinize().reverse().determinize()</pre><h1><a class="anchor" id="implementation_types"></a>
Implementation types</h1>
<p>Currently, an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> has three implementation types that are well supported. When an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is created, its type is defined with an argument. For functions that take a transducer as an argument, the type of the calling transducer must be the same as the type of the argument transducer: </p><pre class="fragment"> # this will cause a TransducerTypeMismatchException:
 tropical_transducer.disjunct(foma_transducer)
 # this works, but weights are lost in the conversion
 tropical_transducer.convert(hfst.ImplementationType.SFST_TYPE).disjunct(sfst_transducer)
 # this works, information is not lost
 tropical_transducer.disjunct(sfst_transducer.convert(hfst.ImplementationType.TROPICAL_OPENFST_TYPE))</pre><h1><a class="anchor" id="creating_transducers"></a>
Creating transducers</h1>
<p>With <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> constructors it is possible to create empty, epsilon, one-transition and single-path transducers. Transducers can also be created from scratch with <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">hfst.HfstBasicTransducer</a> and converted to an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>. More complex transducers can be combined from simple ones with various functions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae64f0875afe3067b97ba370b354b9213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty transducer. </p>
<pre class="fragment"> tr = hfst.HfstTransducer()
 assert(tr.compare(hfst.empty_fst()))</pre> 
</div>
</div>
<a class="anchor" id="ace5d0768e995f79324ada67326e24324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a deep copy of <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> <em>another</em> or a transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>another</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">another</td><td>An <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> or <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>An example:</p>
<pre class="fragment"> tr1 = hfst.regex('foo bar foo')
 tr2 = hfst.HfstTransducer(tr1)
 tr2.substitute('foo','FOO')
 tr1.concatenate(tr2)</pre> 
</div>
</div>
<a class="anchor" id="a60fcc97ee04ca2992dcf510a311edb0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an HFST transducer equivalent to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> <em>t</em>. </p>
<p>The type of the created transducer is defined by <em>type</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the resulting transducer. If you want to use the default type, you can just call <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer(fsm)</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a23e8041ce1015febe4fdace3225714f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An AT&amp;T representation of the transducer. </p>
<p>Defined for print command. An example: </p><pre class="fragment"> &gt;&gt;&gt; print(hfst.regex('[foo:bar::2]+'))
 0       1       foo     bar     2.000000
 1       1       foo     bar     2.000000
 1       0.000000</pre> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Works only for small transducers. </dd></dl>

</div>
</div>
<a class="anchor" id="a38c401a4558a2119398d13f82d5ca720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compare </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this transducer and <em>another</em> are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">another</td><td>The compared transducer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>self</em> and <em>another</em> must have the same implementation type.</dd></dl>
<p>Two transducers are equivalent iff they accept the same input/output string pairs with the same weights and the same alignments. </p><dl class="section note"><dt>Note</dt><dd>For weighted transducers, the function often returns false negatives due to weight precision issues. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2b5c758eb99dc9e29c23c61f0fee9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this transducer with <em>another</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">another</td><td>The second argument in the composition. Not modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a708343dbb05d960b7821b1e42a96d09d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compose_intersect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>invert</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose this transducer with the intersection of transducers in <em>v</em>. </p>
<p>If <em>invert</em> is true, then compose the intersection of the transducers in <em>v</em> with this transducer.</p>
<p>The algorithm used by this function is faster than intersecting all transducers one by one and then composing this transducer with the intersection.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The transducers in <em>v</em> are deterministic and epsilon-free. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A tuple of transducers. </td></tr>
    <tr><td class="paramname">invert</td><td>Whether the intersection of the transducers in <em>v</em> is composed with this transducer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76de872dbf5b970e8d299044ed20be9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def concatenate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="ad98b0d88e97832028c1f9b5744c4482b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def conjunct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for intersect. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a8be7b9b634adc0510fce694d413c6fee" title="Intersect this transducer with another. ">hfst.HfstTransducer.intersect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae23cbf79d7a7dd1604e29cec2a057878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def convert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the transducer into an equivalent transducer in format <em>type</em>. </p>
<p>If a weighted transducer is converted into an unweighted one, all weights are lost. In the reverse case, all weights are initialized to the semiring's one.</p>
<p>A transducer of type <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>, <a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a>, <a class="el" href="classhfst_1_1ImplementationType.html#ac6b38b4422b600ee9b8b6a6e27870102" title="An OpenFst transducer with logarithmic weights (limited support). ">hfst.ImplementationType.LOG_OPENFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> can be converted into an <a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac483b6adfb12973c57d1ba8df1cb9e78" title="An HFST optimized lookup transducer with weights. ">hfst.ImplementationType.HFST_OLW_TYPE</a> transducer, but an <a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac483b6adfb12973c57d1ba8df1cb9e78" title="An HFST optimized lookup transducer with weights. ">hfst.ImplementationType.HFST_OLW_TYPE</a> transducer cannot be converted to any other type.</p>
<dl class="section note"><dt>Note</dt><dd>For conversion between <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> and <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a>, see <a class="el" href="classhfst_1_1HfstTransducer.html#ae64f0875afe3067b97ba370b354b9213" title="Create an empty transducer. ">hfst.HfstTransducer.__init__</a> and <a class="el" href="classhfst_1_1HfstBasicTransducer.html#ae64f0875afe3067b97ba370b354b9213" title="Create a transducer with one initial state that has state number zero and is not a final state...">hfst.HfstBasicTransducer.__init__</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aebf6261b742ae694c16790726a8c77c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of the transducer. </p>
<pre class="fragment"> tr = hfst.regex('[foo:bar::0.3]*')
 TR = tr.copy()
 assert(tr.compare(TR))</pre> 
</div>
</div>
<a class="anchor" id="ae087cf82d6f773cc52b7e0cec911726a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def cross_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make cross product of this transducer with <em>another</em>. </p>
<p>It pairs every string of this with every string of <em>another</em>. If strings are not the same length, epsilon padding will be added in the end of the shorter string. </p><dl class="section pre"><dt>Precondition</dt><dd>Both transducers must be automata, i.e. map strings onto themselves. </dd></dl>

</div>
</div>
<a class="anchor" id="ad767ca32f0f0fa6940a513ecb8d1c725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def determinize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determinize the transducer. </p>
<p>Determinizing a transducer yields an equivalent transducer that has no state with two or more transitions whose input:output symbol pairs are the same. </p>

</div>
</div>
<a class="anchor" id="a88db6c55177ad7f29da4d27c51f645d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def disjunct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunct this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="af14b42f0c57e1e89d05353dfb6c9483a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def eliminate_flag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminate flag diacritic <em>symbol</em> from the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The flag to be eliminated. TODO: explain more.</td></tr>
  </table>
  </dd>
</dl>
<p>An equivalent transducer with no flags <em>symbol</em>. </p>

</div>
</div>
<a class="anchor" id="afcef97a45bf3fd350cd19e79da917fe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def eliminate_flags </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminate flag diacritics listed in <em>symbols</em> from the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbols</td><td>The flags to be eliminated. TODO: explain more.</td></tr>
  </table>
  </dd>
</dl>
<p>An equivalent transducer with no flags listed in <em>symbols</em>. </p>

</div>
</div>
<a class="anchor" id="a9ac7ffd38743271b525e85f26217398b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extract_longest_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract longest paths of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A dictionary. </dd></dl>

</div>
</div>
<a class="anchor" id="a864f12f946bcc935795d48960cf8850e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extract_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract paths that are recognized by the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are filter_flags, max_cycles, max_number, obey_flags, output, random. </td></tr>
    <tr><td class="paramname">filter_flags</td><td>Whether flags diacritics are filtered out from the result (default True). </td></tr>
    <tr><td class="paramname">max_cycles</td><td>Indicates how many times a cycle will be followed, with negative numbers indicating unlimited (default -1 i.e. unlimited). </td></tr>
    <tr><td class="paramname">max_number</td><td>The total number of resulting strings is capped at this value, with 0 or negative indicating unlimited (default -1 i.e. unlimited). </td></tr>
    <tr><td class="paramname">obey_flags</td><td>Whether flag diacritics are validated (default True). </td></tr>
    <tr><td class="paramname">output</td><td>Output format. Values recognized: 'text', 'raw', 'dict' (the default). 'text' returns a string where paths are separated by newlines and each path is represented as input_string + ":" + output_string + "\t" t weight. 'raw' yields a tuple of all paths where each path is a 2-tuple consisting of a weight and a tuple of all transition symbol pairs, each symbol pair being a 2-tuple of an input and an output symbol. 'dict' gives a dictionary that maps each input string into a list of possible outputs, each output being a 2-tuple of an output string and a weight. </td></tr>
    <tr><td class="paramname">random</td><td>Whether result strings are fetched randomly (default False). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted strings. <em>output</em> controls how they are represented.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The transducer must be acyclic, if both <em>max_number</em> and <em>max_cycles</em> have unlimited values. Else a <a class="el" href="classhfst_1_1exceptions_1_1TransducerIsCyclicException.html" title="Transducer is cyclic. ">hfst.exceptions.TransducerIsCyclicException</a> will be thrown.</dd></dl>
<p>An example:</p>
<pre class="fragment"> &gt;&gt;&gt; tr = hfst.regex('a:b+ (a:c+)')
 &gt;&gt;&gt; print(tr)
 0       1       a       b       0.000000
 1       1       a       b       0.000000
 1       2       a       c       0.000000
 1       0.000000
 2       2       a       c       0.000000
 2       0.000000

 &gt;&gt;&gt; print(tr.extract_paths(max_cycles=1, output='text'))
 a:b     0
 aa:bb   0
 aaa:bbc 0
 aaaa:bbcc       0
 aa:bc   0
 aaa:bcc 0

 &gt;&gt;&gt; print(tr.extract_paths(max_number=4, output='text'))
 a:b     0
 aa:bc   0
 aaa:bcc 0
 aaaa:bccc       0

 &gt;&gt;&gt; print(tr.extract_paths(max_cycles=1, max_number=4, output='text'))
 a:b     0
 aa:bb   0
 aa:bc   0
 aaa:bcc 0</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">TransducerIsCyclicException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a56ca204d2689e04b4d834d73038e8488" title="Extract n best paths of the transducer. ">hfst.HfstTransducer.n_best</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a href="Symbols.html">Special symbols</a> are printed as such. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>a link to flag diacritics </dd></dl>

</div>
</div>
<a class="anchor" id="a07a44813804643b56525724273e4638e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extract_shortest_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract shortest paths of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A dictionary. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e18faca5cb09062bcef65e75ab2ba29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the alphabet of the transducer. </p>
<p>The alphabet is defined as the set of symbols known to the transducer. </p><dl class="section return"><dt>Returns</dt><dd>A tuple of strings. </dd></dl>

</div>
</div>
<a class="anchor" id="ae13ea075e8de9101d02c0316ccb2ce79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the transducer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a4289b7f9eec09cb6e166c568d28b7521" title="Rename the transducer name. ">set_name</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af0bac1b337deef561b8808accc82f1ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_properties </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all properties from the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>A dictionary whose keys are properties and whose values are the values of those properties. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7c8f127eca03e8fb34b44ffda5bca34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_property </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>property</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get arbitrary string propert <em>property</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property whose value is returned. get_property('name') works like <a class="el" href="classhfst_1_1HfstTransducer.html#ae13ea075e8de9101d02c0316ccb2ce79" title="Get the name of the transducer. ">get_name()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1001d7b7b0e48724593b0a4334ca1b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The implementation type of the transducer. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhfst_1_1ImplementationType.html" title="Back-end implementations. ">hfst.ImplementationType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7fe034a1fee501b58ad82a40225bcc7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def has_flag_diacritics </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer has flag diacritics in its transitions. </p>

</div>
</div>
<a class="anchor" id="a599ccc41d74d4d138d1472c86f761151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def input_project </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the input language of the transducer. </p>
<p>All transition symbol pairs <em>isymbol:osymbol</em> are changed to <em>isymbol:isymbol</em>. </p>

</div>
</div>
<a class="anchor" id="aafcb3bb3892b2ecbbb7aa01169f194d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def insert_freely </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freely insert a transition or a transducer into the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>The transition or transducer to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>ins</em> is a transition, i.e. a 2-tuple of strings: A transition is added to each state in this transducer. The transition leads from that state to itself with input and output symbols defined by <em>ins</em>. The weight of the transition is zero.</p>
<p>If <em>ins</em> is an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer</a>: A copy of <em>ins</em> is attached with epsilon transitions to each state of this transducer. After the operation, for each state S in this transducer, there is an epsilon transition that leads from state S to the initial state of <em>ins</em>, and for each final state of <em>ins</em>, there is an epsilon transition that leads from that final state to state S in this transducer. The weights of the final states in <em>ins</em> are copied to the epsilon transitions leading to state S. </p>

</div>
</div>
<a class="anchor" id="a201c47a00472ac3168fd0bf52fa5d53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def insert_to_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly insert <em>symbol</em> to the alphabet of the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol (string) to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Usually this function is not needed since new symbols are added to the alphabet by default. </dd></dl>

</div>
</div>
<a class="anchor" id="a8be7b9b634adc0510fce694d413c6fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intersect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersect this transducer with <em>another</em>. </p>

</div>
</div>
<a class="anchor" id="a81367fa3878493d399477bdcd669f90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def invert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the input and output symbols of each transition in the transducer. </p>

</div>
</div>
<a class="anchor" id="af4ea2a6e45493b9f1291ce0898865f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_automaton </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether each transition in the transducer has equivalent input and output symbols. </p>
<dl class="section note"><dt>Note</dt><dd>Transition with <a class="el" href="namespacehfst.html#a51bd2ecc765c9934d3f6396d30ace19f" title="The string for unknown symbol. ">hfst.UNKNOWN</a> on both sides IS NOT a transition with equivalent input and output symbols. </dd>
<dd>
Transition with <a class="el" href="namespacehfst.html#a3b257e90982f934e0237c0bf2671a54b" title="The string for identity symbol. ">hfst.IDENTITY</a> on both sides IS a transition with equivalent input and output symbols. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9452d8d02395b50649219dd0efe0b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_cyclic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is cyclic. </p>

</div>
</div>
<a class="anchor" id="a3cdd28323c37f2fe35a1b47e64757d55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_implementation_type_available </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether HFST is linked to the transducer library needed by implementation type <em>type</em>. </p>

</div>
</div>
<a class="anchor" id="acfb2414b94924b588e296f82aefed272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the transducer is infinitely ambiguous. </p>
<p>A transducer is infinitely ambiguous if there exists an input that will yield infinitely many results, i.e. there are input epsilon loops that are traversed with that input. </p>

</div>
</div>
<a class="anchor" id="a3edfebc58029006dbfaf68fadcac9bab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def is_lookup_infinitely_ambiguous </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tok_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether lookup of path <em>input</em> will have infinite results. </p>
<p>Currently, this function will return whether the transducer is infinitely ambiguous on any lookup path found in the transducer, i.e. the argument <em>input</em> is ignored.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Do not ignore the argument <em>input</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4a6c997abe4c521f646de4da70effb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lenient_composition </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a lenient composition on this transducer and <em>another</em>. </p>
<p>TODO: explain more. </p>

</div>
</div>
<a class="anchor" id="ade6bbc0bd4b23c28e0dcac4c7e300eb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def longest_path_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length of longest path of the transducer. </p>

</div>
</div>
<a class="anchor" id="a2b12c93eabc7fc6a47eecb62d6884a68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def lookup_optimize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup string <em>input</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input. A string or a pre-tokenized tuple of symbols (i.e. a tuple of strings). </td></tr>
    <tr><td class="paramname">kwargs</td><td>Possible parameters and their default values are: obey_flags=True, max_number=-1, time_cutoff=0.0, output='tuple' </td></tr>
    <tr><td class="paramname">obey_flags</td><td>Whether flag diacritics are obeyed. Always True for HFST_OL(W)_TYPE transducers. </td></tr>
    <tr><td class="paramname">max_number</td><td>Maximum number of results returned, defaults to -1, i.e. infinity. </td></tr>
    <tr><td class="paramname">time_cutoff</td><td>How long the function can search for results before returning, expressed in seconds. Defaults to 0.0, i.e. infinitely. Always 0.0 for transducers that are not of HFST_OL(W)_TYPE. </td></tr>
    <tr><td class="paramname">output</td><td>Possible values are 'tuple', 'text' and 'raw', 'tuple' being the default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has an efficient implementation only for optimized lookup format (<a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac483b6adfb12973c57d1ba8df1cb9e78" title="An HFST optimized lookup transducer with weights. ">hfst.ImplementationType.HFST_OLW_TYPE</a>). Other formats perform the lookup via composition. Consider converting the transducer to optimized lookup format or to a <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a>. Conversion to HFST_OL(W)_TYPE might take a while but the lookup is fast. Conversion to <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">HfstBasicTransducer</a> is quick but lookup is slower. Optimize the transducer for lookup. This effectively converts the transducer into <a class="el" href="classhfst_1_1ImplementationType.html#a44467f3dabfb1b5a6cf6011ad63dcadb" title="An HFST optimized lookup transducer, unweighted. ">hfst.ImplementationType.HFST_OL_TYPE</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ef71bbd44f8b37500ffa115b9231349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def minimize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the transducer. </p>
<p>Minimizing a transducer yields an equivalent transducer with the smallest number of states.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>OpenFst's minimization algorithm seems to add epsilon transitions to weighted transducers? </dd></dl>

</div>
</div>
<a class="anchor" id="aa21be58472a1264bdf81446da6fac2ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def minus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for subtract. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#a429afd8003e218241f4c338dd86b4713" title="Subtract transducer another from this transducer. ">hfst.HfstTransducer.subtract</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a56ca204d2689e04b4d834d73038e8488"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def n_best </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract <em>n</em> best paths of the transducer. </p>
<p>In the case of a weighted transducer (<a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#ac6b38b4422b600ee9b8b6a6e27870102" title="An OpenFst transducer with logarithmic weights (limited support). ">hfst.ImplementationType.LOG_OPENFST_TYPE</a>), best paths are defined as paths with the lowest weight. In the case of an unweighted transducer (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), the function returns random paths.</p>
<p>This function is not implemented for <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>. If this function is called by an <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> of type <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>, it is converted to <a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a>, paths are extracted and it is converted back to <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a>. If HFST is not linked to OpenFst library, an <a class="el" href="classhfst_1_1exceptions_1_1ImplementationTypeNotAvailableException.html" title="The library required by the implementation type requested is not linked to HFST. ">hfst.exceptions.ImplementationTypeNotAvailableException</a> is thrown. </p>

</div>
</div>
<a class="anchor" id="a3dcfb8b43a1445f2dc523e2ac73e1ef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def number_of_arcs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of transitions in the transducer. </p>

</div>
</div>
<a class="anchor" id="ad7ca2fa35e7bb080b5a35e8a645158b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def number_of_states </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of states in the transducer. </p>

</div>
</div>
<a class="anchor" id="aacf7d785013483e25d7353bcdf03d16d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def optionalize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disjunct the transducer with an epsilon transducer. </p>

</div>
</div>
<a class="anchor" id="ad5e8f740ae5bedfc22cfaa7f2e007566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def output_project </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the output language of the transducer. </p>
<p>All transition symbol pairs <em>isymbol:osymbol</em> are changed to <em>osymbol:osymbol</em>. </p>

</div>
</div>
<a class="anchor" id="a0b04cb4acd1d71d114026c4962828f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def priority_union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make priority union of this transducer with <em>another</em>. </p>
<p>For the operation t1.priority_union(t2), the result is a union of t1 and t2, except that whenever t1 and t2 have the same string on left side, the path in t2 overrides the path in t1.</p>
<p>Example </p><pre class="fragment"> Transducer 1 (t1):
 a : a
 b : b

 Transducer 2 (t2):
 b : B
 c : C

 Result ( t1.priority_union(t2) ):
 a : a
 b : B
 c : C</pre><p> For more information, read <a href="http://www.fsmbook.com/">fsmbook</a>. </p>

</div>
</div>
<a class="anchor" id="afc5c3005fa6de766d043ed3c52b27a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def prune </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make transducer coaccessible. </p>
<p>A transducer is coaccessible iff there is a path from every state to a final state. </p>

</div>
</div>
<a class="anchor" id="aad9debb84f56d27bdcf1b221ce17b0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def push_weights_to_end </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push weights towards final state(s). </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), nothing is done.</p>
<p>An example: </p><pre class="fragment"> &gt;&gt;&gt; import hfst
 &gt;&gt;&gt; tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
 &gt;&gt;&gt; tr.push_weights_to_end()
 &gt;&gt;&gt; print(tr)
 0       1       a       a       0.000000
 1       2       a       b       0.000000
 2       3       b       b       0.000000
 2       2.000000
 3       2.000000</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#abb198318cdad30f55f344fb6feb20374" title="Push weights towards initial state. ">hfst.HfstTransducer.push_weights_to_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb198318cdad30f55f344fb6feb20374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def push_weights_to_start </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push weights towards initial state. </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), nothing is done.</p>
<p>An example: </p><pre class="fragment"> &gt;&gt;&gt; import hfst
 &gt;&gt;&gt; tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
 &gt;&gt;&gt; tr.push_weights_to_start()
 &gt;&gt;&gt; print(tr)
 0       1       a       a       2.000000
 1       2       a       b       0.000000
 2       3       b       b       0.000000
 2       0.000000
 3       0.000000</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#aad9debb84f56d27bdcf1b221ce17b0d0" title="Push weights towards final state(s). ">hfst.HfstTransducer.push_weights_to_end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d6ece45b9a0ad857fb0294419896ec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_epsilons </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all <em>epsilon:epsilon</em> transitions from the transducer so that the resulting transducer is equivalent to the original one. </p>

</div>
</div>
<a class="anchor" id="a88bc1d1d4f9a6002888d8501799e1573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_from_alphabet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <em>symbol</em> from the alphabet of the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol (string) to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>symbol</em> does not occur in any transition of the transducer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use with care, removing a symbol that occurs in a transition of the transducer can have unexpected results. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d92b9c093bb86b4fc56e1874b3d621a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def remove_optimization </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove lookup optimization. </p>
<p>This effectively converts transducer (back) into default fst type. </p>

</div>
</div>
<a class="anchor" id="abdaf770b28b9b24aab6e03ef8efdb55a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of <em>n</em> transducers. </p>

</div>
</div>
<a class="anchor" id="ab355e95028e8923f8a3c386aab1c7470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n_minus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from zero to <em>n</em>, inclusive. </p>

</div>
</div>
<a class="anchor" id="ac2ffbf1d270362c99698c0769c5594b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n_plus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from <em>n</em> to infinity, inclusive. </p>

</div>
</div>
<a class="anchor" id="a3d30dffa979f55681e6f002f4ac1422a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_n_to_k </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from <em>n</em> to <em>k</em>, inclusive. </p>

</div>
</div>
<a class="anchor" id="a8ae5f0f4a450a584de527a3a8b067a04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_plus </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from one to infinity. </p>

</div>
</div>
<a class="anchor" id="a54432a0b887e88067e5fb6f6fe52ac83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def repeat_star </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A concatenation of N transducers where N is any number from zero to infinity. </p>

</div>
</div>
<a class="anchor" id="a7def94945e05b11b4a98b276d8b372b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def reverse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the transducer. </p>
<p>A reverted transducer accepts the string 'n(0) n(1) ... n(N)' iff the original transducer accepts the string 'n(N) n(N-1) ... n(0)' </p>

</div>
</div>
<a class="anchor" id="aa7a3155e2d11ecce6f6bdcbad8ab78d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def set_final_weights </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the weights of all final states to <em>weight</em>. </p>
<p>If the <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> is of unweighted type (<a class="el" href="classhfst_1_1ImplementationType.html#af8aecd8e6f69ad8017031d652a34854f" title="An SFST transducer, unweighted. ">hfst.ImplementationType.SFST_TYPE</a> or <a class="el" href="classhfst_1_1ImplementationType.html#a6d227efc26ac837490b58ef9693b1c8d" title="A foma transducer, unweighted. ">hfst.ImplementationType.FOMA_TYPE</a>), nothing is done. </p>

</div>
</div>
<a class="anchor" id="a4289b7f9eec09cb6e166c568d28b7521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def set_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename the transducer <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the transducer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstTransducer.html#ae13ea075e8de9101d02c0316ccb2ce79" title="Get the name of the transducer. ">get_name</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b1d566ba462a21ec9f55c037577a7b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def set_property </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set arbitrary string property <em>property</em> to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>A string naming the property. </td></tr>
    <tr><td class="paramname">value</td><td>A string expressing the value of <em>property</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>set_property('name', 'name of the transducer') equals set_name('name of the transducer').</p>
<dl class="section note"><dt>Note</dt><dd>While this function is capable of creating endless amounts of arbitrary metadata, it is suggested that property names are drawn from central repository, or prefixed with "x-". A property that does not follow this convention may affect the behavior of transducer in future releases. </dd></dl>

</div>
</div>
<a class="anchor" id="a92ea73b7c585398d4a054107ecda0e33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def shuffle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle this transducer with transducer <em>another</em>. </p>
<p>If transducer A accepts string 'foo' and transducer B string 'bar', the transducer that results from shuffling A and B accepts all strings [(f|b)(o|a)(o|r)].</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both transducers must be automata, i.e. map strings onto themselves. </dd></dl>

</div>
</div>
<a class="anchor" id="ae30178efca5dcd21c56ac3d5c39abbff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def substitute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute symbols or transitions in the transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The symbol or transition to be substituted. Can also be a dictionary of substitutions, if S == None. </td></tr>
    <tr><td class="paramname">S</td><td>The symbol, transition, a tuple of transitions or a transducer (<a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer</a>) that substitutes <em>s</em>. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are 'input' and 'output', their values can be False or True, True being the default. These arguments are valid only if <em>s</em> and <em>S</em> are strings, else they are ignored. </td></tr>
    <tr><td class="paramname">input</td><td>Whether substitution is performed on input side, defaults to True. Valid only if <em>s</em> and <em>S</em> are strings. </td></tr>
    <tr><td class="paramname">output</td><td>Whether substitution is performed on output side, defaults to True. Valid only if <em>s</em> and \ S are strings.</td></tr>
  </table>
  </dd>
</dl>
<p>For more information, see <a class="el" href="classhfst_1_1HfstBasicTransducer.html#ae30178efca5dcd21c56ac3d5c39abbff" title="Substitute symbols or transitions in the transducer. ">hfst.HfstBasicTransducer.substitute</a>. The function works similarly, with the exception of argument <em>S</em>, which must be <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">hfst.HfstTransducer</a> instead of <a class="el" href="classhfst_1_1HfstBasicTransducer.html" title="A simple transducer class with tropical weights. ">hfst.HfstBasicTransducer</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstBasicTransducer.html#ae30178efca5dcd21c56ac3d5c39abbff" title="Substitute symbols or transitions in the transducer. ">hfst.HfstBasicTransducer.substitute</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a429afd8003e218241f4c338dd86b4713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def subtract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract transducer <em>another</em> from this transducer. </p>

</div>
</div>
<a class="anchor" id="a93bdf204c40983207546c4c14cb2c061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ostr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in binary format to <em>ostr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>A <a class="el" href="classhfst_1_1HfstOutputStream.html" title="A stream for writing binary transducers. ">hfst.HfstOutputStream</a> where the transducer is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2c39f9aeba79a81843b68c224c6afb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to file <em>f</em>, <em>write_weights</em> defined whether weights are written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A python file where transducer is written. </td></tr>
    <tr><td class="paramname">write_weights</td><td>Whether weights are written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d10de411e227b166597217ba56f87bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ofile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to file <em>ofile</em>, <em>write_weights</em> defines whether weights are written. </p>
<p>The fields in the resulting AT&amp;T format are separated by tabulator characters.</p>
<p>NOTE: If the transition symbols contain space characters,the spaces are printed as '@_SPACE_@' because whitespace characters are used as field separators in AT&amp;T format. Epsilon symbols are printed as '@0@'.</p>
<p>If several transducers are written in the same file, they must be separated by a line of two consecutive hyphens "--", so that they will be read correctly by hfst.read_att.</p>
<p>An example: </p><pre class="fragment"> tr1 = hfst.regex('[foo:bar baz:0 " "]::0.3')
 tr2 = hfst.empty_fst()
 tr3 = hfst.epsilon_fst(0.5)
 tr4 = hfst.regex('[foo]')
 tr5 = hfst.empty_fst()

 f = hfst.hfst_open('testfile.att', 'w')
 for tr in [tr1, tr2, tr3, tr4]:
     tr.write_att(f)
     f.write('--\n')
 tr5.write_att(f)
 f.close()</pre><p>This will yield a file 'testfile.att' that looks as follows: </p><pre class="fragment"> 0       1       foo     bar     0.299805
 1       2       baz     @0@     0.000000
 2       3       @_SPACE_@       @_SPACE_@       0.000000
 3       0.000000
 --
 --
 0       0.500000
 --
 0       1       foo     foo     0.000000
 1       0.000000
 --</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">StreamCannotBeWrittenException</td><td></td></tr>
    <tr><td class="paramname">StreamIsClosedException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhfst_1_1HfstOutputStream.html#a18785f734780de8be9a453559259a280" title="Write the transducer transducer in binary format to the stream. ">hfst.HfstOutputStream.write</a> </dd>
<dd>
<a class="el" href="classhfst_1_1HfstTransducer.html#ae64f0875afe3067b97ba370b354b9213" title="Create an empty transducer. ">hfst.HfstTransducer.__init__</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa6421f14914a6421d9af6dc64ac566a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_att </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in AT&amp;T format to file named <em>filename</em>. </p>
<p><em>write_weights</em> defines whether weights are written.</p>
<p>If the file exists, it is overwritten. If the file does not exist, it is created. </p>

</div>
</div>
<a class="anchor" id="a90a690cb253c892938fb06e3863057b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def write_prolog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>write_weights</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the transducer in prolog format with name <em>name</em> to file <em>f</em>, <em>write_weights</em> defined whether weights are written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A python file where the transducer is written. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the transducer that must be given in a prolog file. </td></tr>
    <tr><td class="paramname">write_weights</td><td>Whether weights are written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hfst/<a class="el" href="____init_____8py.html">__init__.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
