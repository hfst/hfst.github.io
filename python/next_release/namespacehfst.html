<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HFST - Helsinki Finite-State Transducer Technology - Python API: hfst Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HFST - Helsinki Finite-State Transducer Technology - Python API
   &#160;<span id="projectnumber">version 3.12.3 (under development)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hfst Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>HFST API for Python.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehfst_1_1exceptions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1exceptions.html">exceptions</a></td></tr>
<tr class="memdesc:namespacehfst_1_1exceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">exceptions... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehfst_1_1sfst__rules"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1sfst__rules.html">sfst_rules</a></td></tr>
<tr class="memdesc:namespacehfst_1_1sfst__rules"><td class="mdescLeft">&#160;</td><td class="mdescRight">rules... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehfst_1_1xerox__rules"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst_1_1xerox__rules.html">xerox_rules</a></td></tr>
<tr class="memdesc:namespacehfst_1_1xerox__rules"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xerox-type replace rules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1AttReader.html">AttReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for reading input in AT&amp;T text format and converting it into transducer(s).  <a href="classhfst_1_1AttReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstBasicTransducer.html">HfstBasicTransducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple transducer class with tropical weights.  <a href="classhfst_1_1HfstBasicTransducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstBasicTransition.html">HfstBasicTransition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transition class that consists of a target state, input and output symbols and a a tropical weight.  <a href="classhfst_1_1HfstBasicTransition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstInputStream.html">HfstInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for reading HFST binary transducers.  <a href="classhfst_1_1HfstInputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstOutputStream.html">HfstOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream for writing binary transducers.  <a href="classhfst_1_1HfstOutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTokenizer.html">HfstTokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tokenizer for creating transducers from UTF-8 strings.  <a href="classhfst_1_1HfstTokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1HfstTransducer.html">HfstTransducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synchronous finite-state transducer.  <a href="classhfst_1_1HfstTransducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1ImplementationType.html">ImplementationType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-end implementations.  <a href="classhfst_1_1ImplementationType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1MultiCharSymbolTrie.html">MultiCharSymbolTrie</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: documentation ???  <a href="classhfst_1_1MultiCharSymbolTrie.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1PmatchContainer.html">PmatchContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for performing pattern matching.  <a href="classhfst_1_1PmatchContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1PrologReader.html">PrologReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for reading input in prolog text format and converting it into transducer(s).  <a href="classhfst_1_1PrologReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhfst_1_1XreCompiler.html">XreCompiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A regular expression compiler.  <a href="classhfst_1_1XreCompiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace32745b6992d04328a0ac6db2fe6625"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ace32745b6992d04328a0ac6db2fe6625">compile_lexc_file</a> (filename, kwargs)</td></tr>
<tr class="memdesc:ace32745b6992d04328a0ac6db2fe6625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile lexc file <em>filename</em> into a transducer.  <a href="#ace32745b6992d04328a0ac6db2fe6625">More...</a><br /></td></tr>
<tr class="separator:ace32745b6992d04328a0ac6db2fe6625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30181452b303647d397859b513940216"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a30181452b303647d397859b513940216">compile_pmatch_expression</a> (expr)</td></tr>
<tr class="memdesc:a30181452b303647d397859b513940216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a pmatch expression into a tuple of transducers.  <a href="#a30181452b303647d397859b513940216">More...</a><br /></td></tr>
<tr class="separator:a30181452b303647d397859b513940216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada42a71a4c7ef02f20dc81e095958ccc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ada42a71a4c7ef02f20dc81e095958ccc">compile_pmatch_file</a> (filename)</td></tr>
<tr class="memdesc:ada42a71a4c7ef02f20dc81e095958ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile pmatch expressions as defined in <em>filename</em> and return a tuple of transducers.  <a href="#ada42a71a4c7ef02f20dc81e095958ccc">More...</a><br /></td></tr>
<tr class="separator:ada42a71a4c7ef02f20dc81e095958ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37e1069e89bc64e5c73d5241cbf85e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ae37e1069e89bc64e5c73d5241cbf85e9">compile_sfst_file</a> (filename, kwargs)</td></tr>
<tr class="memdesc:ae37e1069e89bc64e5c73d5241cbf85e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile sfst file <em>filename</em> into a transducer.  <a href="#ae37e1069e89bc64e5c73d5241cbf85e9">More...</a><br /></td></tr>
<tr class="separator:ae37e1069e89bc64e5c73d5241cbf85e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5da6d256c39436cc3196fc8784d627"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a1f5da6d256c39436cc3196fc8784d627">compile_xfst_file</a> (filename, kwargs)</td></tr>
<tr class="memdesc:a1f5da6d256c39436cc3196fc8784d627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile (is 'run' a better term?) xfst file <em>filename</em>.  <a href="#a1f5da6d256c39436cc3196fc8784d627">More...</a><br /></td></tr>
<tr class="separator:a1f5da6d256c39436cc3196fc8784d627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c362de59eace5c1a3bcc13ec6d1653"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ae1c362de59eace5c1a3bcc13ec6d1653">empty_fst</a> ()</td></tr>
<tr class="memdesc:ae1c362de59eace5c1a3bcc13ec6d1653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an empty transducer.  <a href="#ae1c362de59eace5c1a3bcc13ec6d1653">More...</a><br /></td></tr>
<tr class="separator:ae1c362de59eace5c1a3bcc13ec6d1653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2979f25d2a473466e373451e92d9a4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ad2979f25d2a473466e373451e92d9a4e">epsilon_fst</a> (weight=0)</td></tr>
<tr class="memdesc:ad2979f25d2a473466e373451e92d9a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an epsilon transducer.  <a href="#ad2979f25d2a473466e373451e92d9a4e">More...</a><br /></td></tr>
<tr class="separator:ad2979f25d2a473466e373451e92d9a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5658437f61218626ce08e027f0d06d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#aa5658437f61218626ce08e027f0d06d0">fsa_to_fst</a> (fsa, separator='')</td></tr>
<tr class="memdesc:aa5658437f61218626ce08e027f0d06d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer where each transition isymbolSosymbol:isymbolSosymbol of <em>fsa</em> is replaced a transition isymbol:osymbol, if <em>separator</em> is S.  <a href="#aa5658437f61218626ce08e027f0d06d0">More...</a><br /></td></tr>
<tr class="separator:aa5658437f61218626ce08e027f0d06d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e129afc76610f777b922e29a5d1410"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a99e129afc76610f777b922e29a5d1410">fst</a> (arg)</td></tr>
<tr class="memdesc:a99e129afc76610f777b922e29a5d1410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer that recognizes one or more paths.  <a href="#a99e129afc76610f777b922e29a5d1410">More...</a><br /></td></tr>
<tr class="separator:a99e129afc76610f777b922e29a5d1410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cff4c67deaa638fe5efa5a662baba62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a5cff4c67deaa638fe5efa5a662baba62">fst_to_fsa</a> (<a class="el" href="namespacehfst.html#a99e129afc76610f777b922e29a5d1410">fst</a>, separator='')</td></tr>
<tr class="memdesc:a5cff4c67deaa638fe5efa5a662baba62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer (automaton) where each transition symbol pair isymbol:osymbol of <em>fst</em> is replaced with a transition isymbolosymbol:isymbolosymbol, adding <em>separator</em> between isymbol and osymbol.  <a href="#a5cff4c67deaa638fe5efa5a662baba62">More...</a><br /></td></tr>
<tr class="separator:a5cff4c67deaa638fe5efa5a662baba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ed0a3a319ac2e5b7b05245f7be7eb8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a03ed0a3a319ac2e5b7b05245f7be7eb8">fst_type_to_string</a> (type)</td></tr>
<tr class="memdesc:a03ed0a3a319ac2e5b7b05245f7be7eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of transducer implementation type <em>type</em>.  <a href="#a03ed0a3a319ac2e5b7b05245f7be7eb8">More...</a><br /></td></tr>
<tr class="separator:a03ed0a3a319ac2e5b7b05245f7be7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e90bc39bf763696c3bebb61d694ff12"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a8e90bc39bf763696c3bebb61d694ff12">get_default_fst_type</a> ()</td></tr>
<tr class="memdesc:a8e90bc39bf763696c3bebb61d694ff12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default transducer implementation type.  <a href="#a8e90bc39bf763696c3bebb61d694ff12">More...</a><br /></td></tr>
<tr class="separator:a8e90bc39bf763696c3bebb61d694ff12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219be130c8f39789e401133e9081478f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a219be130c8f39789e401133e9081478f">is_diacritic</a> (symbol)</td></tr>
<tr class="memdesc:a219be130c8f39789e401133e9081478f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether symbol <em>symbol</em> is a flag diacritic.  <a href="#a219be130c8f39789e401133e9081478f">More...</a><br /></td></tr>
<tr class="separator:a219be130c8f39789e401133e9081478f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814aa4f32c3a5123311a837dff8a8e5f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a814aa4f32c3a5123311a837dff8a8e5f">read_att_input</a> ()</td></tr>
<tr class="memdesc:a814aa4f32c3a5123311a837dff8a8e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read AT&amp;T input from the user and return a transducer.  <a href="#a814aa4f32c3a5123311a837dff8a8e5f">More...</a><br /></td></tr>
<tr class="separator:a814aa4f32c3a5123311a837dff8a8e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d069ec5bbe53b24d4bf7df504fb2c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a05d069ec5bbe53b24d4bf7df504fb2c7">read_att_string</a> (att)</td></tr>
<tr class="memdesc:a05d069ec5bbe53b24d4bf7df504fb2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a multiline string <em>att</em> and return a transducer.  <a href="#a05d069ec5bbe53b24d4bf7df504fb2c7">More...</a><br /></td></tr>
<tr class="separator:a05d069ec5bbe53b24d4bf7df504fb2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c702ae7b2266706e1c2b5094a01043"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ac8c702ae7b2266706e1c2b5094a01043">read_att_transducer</a> (f, epsilonstr=<a class="el" href="namespacehfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2">hfst.EPSILON</a>)</td></tr>
<tr class="memdesc:ac8c702ae7b2266706e1c2b5094a01043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next transducer from AT&amp;T file pointed by <em>f</em>.  <a href="#ac8c702ae7b2266706e1c2b5094a01043">More...</a><br /></td></tr>
<tr class="separator:ac8c702ae7b2266706e1c2b5094a01043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b3cbcce992c6b68e9b0a072540e4df"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ad6b3cbcce992c6b68e9b0a072540e4df">read_prolog_transducer</a> (f)</td></tr>
<tr class="separator:ad6b3cbcce992c6b68e9b0a072540e4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37671a6472be0ea8b8cf875d37504bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#ab37671a6472be0ea8b8cf875d37504bb">regex</a> (regexp, kwargs)</td></tr>
<tr class="memdesc:ab37671a6472be0ea8b8cf875d37504bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer as defined by regular expression <em>regexp</em>.  <a href="#ab37671a6472be0ea8b8cf875d37504bb">More...</a><br /></td></tr>
<tr class="separator:ab37671a6472be0ea8b8cf875d37504bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc4722a7fdbd599f1bbf3359ac0e120"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a3fc4722a7fdbd599f1bbf3359ac0e120">set_default_fst_type</a> (impl)</td></tr>
<tr class="memdesc:a3fc4722a7fdbd599f1bbf3359ac0e120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default implementation type.  <a href="#a3fc4722a7fdbd599f1bbf3359ac0e120">More...</a><br /></td></tr>
<tr class="separator:a3fc4722a7fdbd599f1bbf3359ac0e120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ba3308143410b6bfbeca21b8e4e0d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a04ba3308143410b6bfbeca21b8e4e0d4">start_xfst</a> (kwargs)</td></tr>
<tr class="memdesc:a04ba3308143410b6bfbeca21b8e4e0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start interactive xfst compiler.  <a href="#a04ba3308143410b6bfbeca21b8e4e0d4">More...</a><br /></td></tr>
<tr class="separator:a04ba3308143410b6bfbeca21b8e4e0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851bc533f31bdcf015ce03b5ab378a81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a851bc533f31bdcf015ce03b5ab378a81">tokenized_fst</a> (arg, weight=0)</td></tr>
<tr class="memdesc:a851bc533f31bdcf015ce03b5ab378a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transducer that recognizes the concatenation of symbols or symbol pairs in <em>arg</em>.  <a href="#a851bc533f31bdcf015ce03b5ab378a81">More...</a><br /></td></tr>
<tr class="separator:a851bc533f31bdcf015ce03b5ab378a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2">EPSILON</a> = '@_EPSILON_SYMBOL_@'</td></tr>
<tr class="memdesc:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for epsilon symbol.  <a href="#a9c72aae3ca2a5e4c25a95cefe40704a2">More...</a><br /></td></tr>
<tr class="separator:a9c72aae3ca2a5e4c25a95cefe40704a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b257e90982f934e0237c0bf2671a54b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a3b257e90982f934e0237c0bf2671a54b">IDENTITY</a> = '@_IDENTITY_SYMBOL_@'</td></tr>
<tr class="memdesc:a3b257e90982f934e0237c0bf2671a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for identity symbol.  <a href="#a3b257e90982f934e0237c0bf2671a54b">More...</a><br /></td></tr>
<tr class="separator:a3b257e90982f934e0237c0bf2671a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bd2ecc765c9934d3f6396d30ace19f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehfst.html#a51bd2ecc765c9934d3f6396d30ace19f">UNKNOWN</a> = '@_UNKNOWN_SYMBOL_@'</td></tr>
<tr class="memdesc:a51bd2ecc765c9934d3f6396d30ace19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string for unknown symbol.  <a href="#a51bd2ecc765c9934d3f6396d30ace19f">More...</a><br /></td></tr>
<tr class="separator:a51bd2ecc765c9934d3f6396d30ace19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>HFST API for Python. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ace32745b6992d04328a0ac6db2fe6625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_lexc_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile lexc file <em>filename</em> into a transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the lexc file. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: verbosity, with_flags, output. </td></tr>
    <tr><td class="paramname">verbosity</td><td>The verbosity of the compiler, defaults to 0 (silent). Possible values are: 0, 1, 2. </td></tr>
    <tr><td class="paramname">with_flags</td><td>Whether lexc flags are used when compiling, defaults to False. </td></tr>
    <tr><td class="paramname">output</td><td>Where output is printed. Possible values are sys.stdout, sys.stderr, a StringIO, sys.stderr being the default? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success the resulting transducer, else None. </dd></dl>

</div>
</div>
<a class="anchor" id="a30181452b303647d397859b513940216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_pmatch_expression </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a pmatch expression into a tuple of transducers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>A string defining how pmatch is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#ada42a71a4c7ef02f20dc81e095958ccc" title="Compile pmatch expressions as defined in filename and return a tuple of transducers. ">hfst.compile_pmatch_file</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ada42a71a4c7ef02f20dc81e095958ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_pmatch_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile pmatch expressions as defined in <em>filename</em> and return a tuple of transducers. </p>
<p>An example:</p>
<p>If we have a file named streets.txt that contains:</p>
<p>define CapWord UppercaseAlpha Alpha* ; define StreetWordFr [{avenue} | {boulevard} | {rue}] ; define DeFr [ [{de} | {du} | {des} | {de la}] Whitespace ] | [{d'} | {l'}] ; define StreetFr StreetWordFr (Whitespace DeFr) CapWord+ ; regex StreetFr EndTag(FrenchStreetName) ;</p>
<p>we can run:</p>
<p>defs = <a class="el" href="namespacehfst.html#ada42a71a4c7ef02f20dc81e095958ccc" title="Compile pmatch expressions as defined in filename and return a tuple of transducers. ">hfst.compile_pmatch_file</a>('streets.txt') const = <a class="el" href="classhfst_1_1PmatchContainer.html" title="A class for performing pattern matching. ">hfst.PmatchContainer(defs)</a> assert cont.match("Je marche seul dans l'avenue des Ternes.") == "Je marche seul dans l'&lt;FrenchStreetName&gt;avenue des Ternes&lt;/FrenchStreetName&gt;." </p>

</div>
</div>
<a class="anchor" id="ae37e1069e89bc64e5c73d5241cbf85e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_sfst_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile sfst file <em>filename</em> into a transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the sfst file. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: verbose, output. </td></tr>
    <tr><td class="paramname">verbose</td><td>Whether sfst file is processed in verbose mode, defaults to False. </td></tr>
    <tr><td class="paramname">output</td><td>TODO: Where output is printed. Possible values are sys.stdout, sys.stderr, a StringI0, sys.stderr being the default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success the resulting transducer, else None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f5da6d256c39436cc3196fc8784d627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.compile_xfst_file </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile (is 'run' a better term?) xfst file <em>filename</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the xfst file. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: verbosity, quit_on_fail, output, type. </td></tr>
    <tr><td class="paramname">verbosity</td><td>The verbosity of the compiler, defaults to 0 (silent). Possible values are: 0, 1, 2. </td></tr>
    <tr><td class="paramname">quit_on_fail</td><td>Whether the script is exited on any error, defaults to True. </td></tr>
    <tr><td class="paramname">output</td><td>Where output is printed. Possible values are sys.stdout, sys.stderr, a StringIO, sys.stderr being the default? </td></tr>
    <tr><td class="paramname">type</td><td>Implementation type of the compiler, defaults to <a class="el" href="namespacehfst.html#a8e90bc39bf763696c3bebb61d694ff12" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success 0, else an integer greater than 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1c362de59eace5c1a3bcc13ec6d1653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.empty_fst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an empty transducer. </p>
<p>Empty transducer has one state that is not final, i.e. it does not recognize any string. </p>

</div>
</div>
<a class="anchor" id="ad2979f25d2a473466e373451e92d9a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.epsilon_fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an epsilon transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>The weight of the final state. Epsilon transducer has one state that is final (with final weight <em>weight</em>), i.e. it recognizes the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5658437f61218626ce08e027f0d06d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.fsa_to_fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>separator</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer where each transition isymbolSosymbol:isymbolSosymbol of <em>fsa</em> is replaced a transition isymbol:osymbol, if <em>separator</em> is S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fsa</td><td>The transducer. Must be an automaton, i.e. for each transition, the input and output symbols must be the same. Else, a TransducerIsNotAutomatonException is thrown. </td></tr>
    <tr><td class="paramname">separator</td><td>The symbol separating input and output symbol parts in <em>fsa</em>. If it is the empty string, length of each symbol in <em>fsa</em> (excluding special symbols of form "@...@") must be exactly 2. Else, a RuntimeError is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99e129afc76610f777b922e29a5d1410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer that recognizes one or more paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>See example below</td></tr>
  </table>
  </dd>
</dl>
<p>Possible inputs: </p><pre class="fragment"> One unweighted identity path:
 'foo'  -&gt;  [f o o]
 Weighted path: a tuple of string and number, e.g.
 ('foo',1.4)
 ('bar',-3)
 ('baz',0)
 Several paths: a list or a tuple of paths and/or weighted paths, e.g.
 ['foo', 'bar']
 ('foo', ('bar',5.0))
 ('foo', ('bar',5.0), 'baz', 'Foo', ('Bar',2.4))
 [('foo',-1), ('bar',0), ('baz',3.5)]
 A dictionary mapping strings to any of the above cases:
 {'foo':'foo', 'bar':('foo',1.4), 'baz':(('foo',-1),'BAZ')}</pre> 
</div>
</div>
<a class="anchor" id="a5cff4c67deaa638fe5efa5a662baba62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.fst_to_fsa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>separator</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer (automaton) where each transition symbol pair isymbol:osymbol of <em>fst</em> is replaced with a transition isymbolosymbol:isymbolosymbol, adding <em>separator</em> between isymbol and osymbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fst</td><td>The transducer. </td></tr>
    <tr><td class="paramname">separator</td><td>The separator symbol inserted between input and output symbols.</td></tr>
  </table>
  </dd>
</dl>
<p>Examples </p><pre class="fragment"> import hfst
 foo2bar = hfst.fst({'foo':'bar'})</pre><p> creates a transducer [f:b o:a o:r]. Calling </p><pre class="fragment"> foobar = hfst.fst_to_fsa(foo2bar)</pre><p> will create the transducer [fb:fb oa:oa or:or] and </p><pre class="fragment"> foobar = hfst.fst_to_fsa(foo2bar, '^')</pre><p> the transducer [f^b:f^b o^a:o^a o^r:o^r]. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehfst.html#aa5658437f61218626ce08e027f0d06d0" title="Get a transducer where each transition isymbolSosymbol:isymbolSosymbol of fsa is replaced a transitio...">hfst.fsa_to_fst</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a03ed0a3a319ac2e5b7b05245f7be7eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.fst_type_to_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string representation of transducer implementation type <em>type</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>An <a class="el" href="classhfst_1_1ImplementationType.html" title="Back-end implementations. ">hfst.ImplementationType</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e90bc39bf763696c3bebb61d694ff12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.get_default_fst_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default transducer implementation type. </p>
<p>If the default type is not set, it defaults to <a class="el" href="classhfst_1_1ImplementationType.html#a7d0d4616ee4e5a966d6e336035721b20" title="An OpenFst transducer with tropical weights. ">hfst.ImplementationType.TROPICAL_OPENFST_TYPE</a> </p>

</div>
</div>
<a class="anchor" id="a219be130c8f39789e401133e9081478f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.is_diacritic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether symbol <em>symbol</em> is a flag diacritic. </p>
<p>Flag diacritics are of the form </p><pre class="fragment"> @[PNDRCU][.][A-Z]+([.][A-Z]+)?@</pre> 
</div>
</div>
<a class="anchor" id="a814aa4f32c3a5123311a837dff8a8e5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_att_input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read AT&amp;T input from the user and return a transducer. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> whose type is <a class="el" href="namespacehfst.html#a8e90bc39bf763696c3bebb61d694ff12" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. Read one AT&amp;T line at a time from standard input and finally return an equivalent transducer. An empty line signals the end of input. </dd></dl>

</div>
</div>
<a class="anchor" id="a05d069ec5bbe53b24d4bf7df504fb2c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_att_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>att</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a multiline string <em>att</em> and return a transducer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">att</td><td>A string in AT&amp;&amp; format that defines the transducer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhfst_1_1HfstTransducer.html" title="A synchronous finite-state transducer. ">HfstTransducer</a> whose type is <a class="el" href="namespacehfst.html#a8e90bc39bf763696c3bebb61d694ff12" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. Read <em>att</em> and create a transducer as defined in it. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8c702ae7b2266706e1c2b5094a01043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_att_transducer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>epsilonstr</em> = <code><a class="el" href="namespacehfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2">hfst.EPSILON</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next transducer from AT&amp;T file pointed by <em>f</em>. </p>
<p><em>epsilonstr</em> defines the symbol used for epsilon in the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A python file </td></tr>
    <tr><td class="paramname">epsilonstr</td><td>How epsilon is represented in the file. By default, "@_EPSILON_SYMBOL_@" and "@0@" are both recognized.</td></tr>
  </table>
  </dd>
</dl>
<p>If the file contains several transducers, they must be separated by "--" lines. In AT&amp;T format, the transition lines are of the form:</p>
<pre class="fragment"> [0-9]+[\w]+[0-9]+[\w]+[^\w]+[\w]+[^\w]([\w]+(-)[0-9]+(\.[0-9]+))</pre><p>and final state lines:</p>
<pre class="fragment"> [0-9]+[\w]+([\w]+(-)[0-9]+(\.[0-9]+))</pre><p>If several transducers are listed in the same file, they are separated by lines of two consecutive hyphens "--". If the weight </p><pre class="fragment"> ([\w]+(-)[0-9]+(\.[0-9]+))</pre><p> is missing, the transition or final state is given a zero weight.</p>
<p>NOTE: If transition symbols contains spaces, they must be escaped as '@_SPACE_@' because spaces are used as field separators. Both '@0@' and '@_EPSILON_SYMBOL_@' are always interpreted as epsilons.</p>
<p>An example: </p><pre class="fragment"> 0      1      foo      bar      0.3
 1      0.5
 --
 0      0.0
 --
 --
 0      0.0
 0      0      a        &lt;eps&gt;    0.2</pre><p>The example lists four transducers in AT&amp;T format: one transducer accepting the string pair &lt;'foo','bar'&gt;, one epsilon transducer, one empty transducer and one transducer that accepts any number of 'a's and produces an empty string in all cases. The transducers can be read with the following commands (from a file named 'testfile.att'): </p><pre class="fragment"> transducers = []
 ifile = open('testfile.att', 'r')
 try:
     while (True):
         t = hfst.read_att_transducer(ifile, '&lt;eps&gt;')
         transducers.append(t)
         print("read one transducer")
 except hfst.exceptions.NotValidAttFormatException as e:
     print("Error reading transducer: not valid AT&amp;T format.")
 except hfst.exceptions.EndOfStreamException as e:
     pass
 ifile.close()
 print("Read %i transducers in total" % len(transducers))</pre><p>Epsilon will be represented as <a class="el" href="namespacehfst.html#a9c72aae3ca2a5e4c25a95cefe40704a2" title="The string for epsilon symbol. ">hfst.EPSILON</a> in the resulting transducer. The argument <em>epsilon_symbol</em> only denotes how epsilons are represented in <em>ifile</em>.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Empty transducers are in theory represented as empty strings in AT&amp;T format. However, this sometimes results in them getting interpreted as end-of-file. To avoid this, use an empty line instead, i.e. a single newline character.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NotValidAttFormatException</td><td></td></tr>
    <tr><td class="paramname">StreamNotReadableException</td><td></td></tr>
    <tr><td class="paramname">StreamIsClosedException</td><td></td></tr>
    <tr><td class="paramname">EndOfStreamException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>#write_att </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b3cbcce992c6b68e9b0a072540e4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.read_prolog_transducer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab37671a6472be0ea8b8cf875d37504bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.regex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>regexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer as defined by regular expression <em>regexp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regexp</td><td>The regular expression defined with <a href="http://www.fsmbook.com/">Xerox transducer notation</a>. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: error. </td></tr>
    <tr><td class="paramname">error</td><td>Where warnings and errors are printed. Possible values are sys.stdout, sys.stderr (the default), a StringIO or None, indicating a quiet mode.</td></tr>
  </table>
  </dd>
</dl>
<p>Regular expression operators:</p>
<pre class="fragment"> ~   complement
 \   term complement
 &amp;   intersection
 -   minus

 $.  contains once
 $?  contains optionally
 $   contains once or more
 ( ) optionality

 +   Kleene plus
 *   Kleene star

 ./. ignore internally (not yet implemented)
 /   ignoring

 |   union

 &lt;&gt;  shuffle
 &lt;   before
 &gt;   after

 .o.   composition
 .O.   lenient composition
 .m&gt;.  merge right
 .&lt;m.  merge left
 .x.   cross product
 .P.   input priority union
 .p.   output priority union
 .-u.  input minus
 .-l.  output minus
 `[ ]  substitute

 ^n,k  catenate from n to k times, inclusive
 ^&gt;n   catenate more than n times
 ^&gt;n   catenate less than n times
 ^n    catenate n times

 .r   reverse
 .i   invert
 .u   input side
 .l   output side

 \\\  left quotient

 Two-level rules:

  \&lt;=   left restriction
  &lt;=&gt;   left and right arrow
  &lt;=    left arrow
  =&gt;    right arrow

 Replace rules:

  -&gt;    replace right
  (-&gt;)  optionally replace right
  &lt;-    replace left
  (&lt;-)  optionally replace left
  &lt;-&gt;   replace left and right
  (&lt;-&gt;) optionally replace left and right
  @-&gt;   left-to-right longest match
  @&gt;    left-to-right shortest match
  -&gt;@   right-to-left longest match
  &gt;@    right-to-left shortest match

 Rule contexts, markers and separators:

  ||   match contexts on input sides
  //   match left context on output side and right context on input side
  \\   match left context on input side and right context on output side
  \/   match contexts on output sides
  _    center marker
  ...  markup marker
  ,,   rule separator in parallel rules
  ,    context separator
  [. .]  match epsilons only once

 Read from file:

  @bin" "  read binary transducer
  @txt" "  read transducer in att text format
  @stxt" " read spaced text
  @pl" "   read transducer in prolog text format
  @re" "   read regular expression

 Symbols:

  .#.  word boundary symbol in replacements, restrictions
  0    the epsilon
  ?    any token
  %    escape character
  { }  concatenate symbols
  " "  quote symbol

 :    pair separator
 ::   weight

 ;   end of expression
 !   starts a comment until end of line
 #   starts a comment until end of line</pre> 
</div>
</div>
<a class="anchor" id="a3fc4722a7fdbd599f1bbf3359ac0e120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.set_default_fst_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default implementation type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>An <a class="el" href="classhfst_1_1ImplementationType.html" title="Back-end implementations. ">hfst.ImplementationType</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the implementation type (SFST_TYPE, TROPICAL_OPENFST_TYPE, FOMA_TYPE) that is used by default by all operations that create transducers. The default value is TROPICAL_OPENFST_TYPE </p>

</div>
</div>
<a class="anchor" id="a04ba3308143410b6bfbeca21b8e4e0d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.start_xfst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start interactive xfst compiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kwargs</td><td>Arguments recognized are: type, quit_on_fail. </td></tr>
    <tr><td class="paramname">quit_on_fail</td><td>Whether the compiler exits on any error, defaults to False. </td></tr>
    <tr><td class="paramname">type</td><td>Implementation type of the compiler, defaults to <a class="el" href="namespacehfst.html#a8e90bc39bf763696c3bebb61d694ff12" title="Get default transducer implementation type. ">hfst.get_default_fst_type()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a851bc533f31bdcf015ce03b5ab378a81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def hfst.tokenized_fst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transducer that recognizes the concatenation of symbols or symbol pairs in <em>arg</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The symbols or symbol pairs that form the path to be recognized.</td></tr>
  </table>
  </dd>
</dl>
<p>Example </p><pre class="fragment"> import hfst
 tok = hfst.HfstTokenizer()
 tok.add_multichar_symbol('foo')
 tok.add_multichar_symbol('bar')
 tr = hfst.tokenized_fst(tok.tokenize('foobar', 'foobaz'))</pre><p> will create the transducer [foo:foo bar:b 0:a 0:z] </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a9c72aae3ca2a5e4c25a95cefe40704a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string EPSILON = '@_EPSILON_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for epsilon symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = hfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, 2.0)
 fsm.add_transition(0, 1, "foo", hfst.EPSILON)
 if not hfst.HfstTransducer(fsm).compare(hfst.regex('foo:0::2.0')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, "0" is used for the epsilon. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b257e90982f934e0237c0bf2671a54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string IDENTITY = '@_IDENTITY_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for identity symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = hfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, 1.5)
 fsm.add_transition(0, 1, hfst.IDENTITY, hfst.IDENTITY)
 if not hfst.HfstTransducer(fsm).compare(hfst.regex('?::1.5')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, a single "?" is used for the identity symbol. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51bd2ecc765c9934d3f6396d30ace19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string UNKNOWN = '@_UNKNOWN_SYMBOL_@'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string for unknown symbol. </p>
<p>An example: </p><pre class="fragment"> fsm = hfst.HfstBasicTransducer()
 fsm.add_state(1)
 fsm.set_final_weight(1, -0.5)
 fsm.add_transition(0, 1, "foo", hfst.UNKNOWN)
 fsm.add_transition(0, 1, "foo", "foo")
 if not hfst.HfstTransducer(fsm).compare(hfst.regex('foo:?::-0.5')):
     raise RuntimeError('')</pre> <dl class="section note"><dt>Note</dt><dd>In regular expressions, "?" on either or both sides of a transition is used for the unknown symbol. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="Symbols.html">Symbols</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
